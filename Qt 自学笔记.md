Qt 自学笔记





## textedit

其实&QAction::triggered()就是 Qaction类 的一个信号罢了，如果我们触发这个信号与槽函数进行连接

```c++
QAction *action = new QAction("My Action", this);
connect(action, &QAction::triggered, this, &MyClass::mySlot);

```

1. action 是一个 QAction 对象，它代表你在菜单或工具栏中的一个操作。
2. &QAction::triggered 是 QAction 的一个信号，当用户触发此操作时（例如点击菜单项），它会发射这个信号。（triggered-》引发）
3. this 是当前对象（通常是窗口类），它包含槽函数（也就是事件处理函数）。
4. mySlot 是一个槽函数，当 triggered 信号发射时，Qt 会调用这个槽函数来处理这个事件。

##### 常见问题

**是否每次都要使用 `connect`**: 是的，当你希望捕捉某个信号并处理它时，必须通过 `connect` 函数连接信号与槽。否则，即使信号被触发，你的程序也不会做出响应。

**多个信号连接到一个槽**: 多个不同的信号可以连接到同一个槽函数。例如，你可能有多个不同的 `QAction`，但是点击它们时都会执行相同的处理逻辑。

**信号与槽参数不匹配**: 信号和槽的参数必须匹配。如果信号带有参数，槽也需要接收相同的参数，否则会编译失败或运行时报错。



解释信号与槽函数的区别

#### 1. 信号（Signal）

**信号**是用来表示某个事件已经发生。它通常在某个动作或状态变化时被触发（即发射）。信号不做任何具体的处理，它只负责发射，告诉外界 "某件事发生了"。

- 信号本质上是一个声明，表示某个条件满足了，或者某个事件发生了。
- 信号不包含具体的执行逻辑。
- 信号是由类定义的，当某种条件触发时，信号会被发射（emitted）。
- 任何与该信号连接的槽函数都会被调用。

例如：在 `QPushButton` 类中，当用户点击按钮时，会发射 `clicked()` 信号。

```
cpp复制代码QPushButton *button = new QPushButton("Click Me", this);

// 按钮点击时发射 clicked() 信号
connect(button, &QPushButton::clicked, this, &MyClass::buttonClicked);
```

在这个例子中，当按钮被点击时，`clicked()` 信号被发射。

#### 2. 槽函数（Slot）

**槽函数**是一个普通的成员函数，但它被用来响应信号。当信号发射时，连接到该信号的槽函数会被自动调用，从而处理该信号表示的事件。

- 槽函数是执行特定动作的函数，通常包含与信号相关的业务逻辑。
- 当信号被触发，连接到该信号的槽函数会被调用，执行相应的逻辑。
- 槽函数是信号的处理者，因此当一个信号发射时，槽函数接收信号并响应它。

例如：我们定义一个槽函数 `buttonClicked()`，它会在按钮被点击（`clicked()` 信号发射时）调用。

```
cpp复制代码public slots:
    void buttonClicked() {
        // 槽函数内容，处理信号
        qDebug() << "Button was clicked!";
    }
```

#### 3. 信号和槽之间的关系

信号和槽通过 `connect()` 函数连接起来。当一个信号发射时，所有与该信号连接的槽函数都会被调用。信号与槽之间的关系类似于事件与处理器之间的关系。

1. **信号发射**：信号是被某个对象发射的，当特定事件发生时（如按钮被点击、窗口关闭等），对象会发射信号。
2. **槽函数执行**：当信号被发射后，与该信号关联的槽函数会被调用，从而对信号进行处理。
3. **多对多连接**：一个信号可以连接多个槽函数，一个槽函数也可以连接多个信号。这提供了灵活的事件处理机制。

#### 4. 信号和槽的特性

- **参数匹配**：信号和槽的参数必须匹配，即信号发射的参数数量和类型要与槽函数一致或兼容。信号的参数可以比槽函数多，槽函数只会接收它能处理的参数。
- **类型安全**：Qt 的信号槽机制是类型安全的，信号和槽的参数在编译时会进行类型检查，确保它们匹配。
- **松耦合**：信号与槽机制实现了松耦合的设计。信号的发射者（信号源）并不关心槽函数是谁，也不关心是否有槽连接。它只是发射信号。槽函数的执行者只负责处理信号，而不关心信号是如何发射的。

#### 5. 举个完整的例子

```
cpp复制代码#include <QApplication>
#include <QPushButton>
#include <QDebug>

class MyClass : public QObject {
    Q_OBJECT

public slots:
    void buttonClicked() {
        qDebug() << "Button was clicked!";
    }
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QPushButton button("Click Me");
    MyClass myClass;

    // 信号和槽的连接：按钮点击信号连接到槽函数
    QObject::connect(&button, &QPushButton::clicked, &myClass, &MyClass::buttonClicked);

    button.show();
    return app.exec();
}
```

在这个例子中：

- `QPushButton` 发射 `clicked()` 信号。
- `MyClass` 类中的 `buttonClicked()` 槽函数响应该信号并执行相应的逻辑。

#### 小结

- **信号** 是一种通知机制，表示某个事件发生了（比如按钮被点击）。
- **槽函数** 是处理信号的函数，当信号发射时，槽函数会被调用以执行响应操作。
- 信号和槽通过 `connect()` 函数连接在一起，实现对象之间的通信。





#### 槽函数在头文件中声明的原因：

1. **编译器需要函数声明**：C++ 编译器在编译一个类时，需要知道类的所有成员函数的声明，包括普通成员函数和槽函数。如果槽函数没有在头文件中声明，编译器在编译类时就不知道这些函数的存在，会导致编译错误。
2. **Qt 的元对象系统（MOC）需要处理槽函数**：Qt 使用一种叫做 MOC（Meta-Object Compiler）的工具来处理信号和槽。MOC 通过扫描头文件中的类声明来生成与信号和槽相关的代码。如果槽函数没有在头文件中声明，MOC 就无法识别这些槽函数，导致它们无法正确连接到信号。