![image-20240525191239287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191239287.png)

不是所有的inline函数都会被编译器执行

在debug版本里面inline是不会被触发，只会咋release版本才会出现

内联函数和普通函数的区别，减少消耗，如果生成内联就不会生成函数符号

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191819982.png" alt="image-20240525191819982" style="zoom:80%;" />

可以进行查询





const

![image-20240525193453250](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525193453250.png)

可以通过指针进行修改，但是不推荐，因为不安全

![image-20240525211905648](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525211905648.png)

![image-20240525215017148](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525215017148.png)

单个元素的释放时不加中括号的，数组内存的释放才是加中括号的

![image-20240525220539564](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525220539564.png)

delete和free
free无论时释放一个元素内存，还是释放数组内存都是一个标准的函数调用，传入这个内存的起始地址就好了

左值引用和初识右值引用那个



引用必须初始化

指针可以不用初始化，最好初始化





函数重载部分

![image-20240604101959870](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604101959870.png)

产生规则不同



重载需要 注意什么

首先得在一个作用域

不在一个作用域就不存在重载

什么是函数重载？

![image-20240604154750624](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604154750624.png)

编译时期决定重载哪个版本

什么是多态？

静态（编译时期的）多态：函数重载

动态（运行时候的）多态：

c++在编译代码的时候产生函数符号的时候，是由这个函数名+参数类型组成的，c语言是不能重载的，产生函数符号的时候是由函数名来决定的



c++ 调用c ：无法直接调用

![image-20240605175858792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605175858792.png)

这样子就可以调用，把c函数的声明括在extern“c”里面



c 调用c ++无法调用的话，那就也是extern

![image-20240605180403463](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180403463.png)

__FILE__

__LINE__

只要是c++编译器，都内置了这个宏__cplusplus

![image-20240605180725445](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180725445.png)

![image-20240605181008848](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605181008848.png)

这种方式更加通用

在c和c++的编译器里面都是通用的

const修饰的变量不能够再作为左值，初始化完成后，值不能被修改。

**c里面可以不用初始化，c++必需初始化**

c里面const的不叫常量，叫做常变量

通过指针地址可以修改，const只是在表层不可以作为左值修改

c++的const

必须初始化的，叫常量

如果是通过传递的，那就叫常变量，因为初始值不是一个立即数，是一个变量

![image-20240605202005153](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605202005153.png)

得到的值是30 30 30



常量和普通变量的区别

1. 编译方式不同
2. 不能作为左值了

const修饰的量常出现的错误是：

1. 常量不能作为一个左值《= 直接修改常量的值
2. 不能把常量的地址泄露给一个普通的指针或者普通的引用变量《=可以间接修改



const和一级指针的结合：有两种情况

![image-20240605221540812](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605221540812.png)

通过指针解引用（*）指向内存的值，也就是说  p指向 a的地址， *p可以被复制，只是p被定为常量而已

const和指针转换的类型转换公式

int*   <=   const int*---->不允许的

const int*  <= int *  可以的



**const如果右边没有指针*的话，const是不参与类型的**

![image-20240605231656426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605231656426.png)

以上的都是正确的



const和多级指针结合的时候必须两边都有const，否则就是错误

const 和二级指针的结合

![image-20240605232838210](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605232838210.png)



![image-20240605233107574](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605233107574.png)

反正就是** 转 ** ，不能两边不匹配

如果是const后面有 * ，那么就直接变成 const*   《  *

这样子是可以的



![image-20240605234134074](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605234134074.png)

如果是这样会发生错误

const int ** <= int **,小变大了

改成const int *p = &a；就可以了



又或者const int* const* q = &p;那就是*q不可以赋值



在给定的代码中，我们有以下声明和初始化：

```cpp
int a = 10;
int *p = &a;
const int **q = &p;
```

让我们逐步解释这些声明和初始化的含义。

1. `int a = 10;`：声明并初始化一个整型变量 `a`，其值为 `10`。

2. `int *p = &a;`：声明并初始化一个整型指针 `p`，将 `p` 的值设置为 `a` 的地址。这意味着 `p` 指向了 `a`。

3. `const int **q = &p;`：声明并初始化一个指向指针的指针 `q`，该指针指向 `const int` 类型的数据。将 `q` 的值设置为指向 `p` 的地址。

现在我们来解释指针和 `const` 的传递。

- 一级指针 `p`：它是一个指向 `int` 类型数据的指针。通过 `p`，我们可以修改 `a` 的值。也就是说，`p` 是一个可变指针。

- 二级指针 `q`：它是一个指向指针的指针，指向 `const int` 类型的数据。这意味着 `q` 指向的指针 `p` 是一个指向 `const int` 类型数据的指针。通过 `q`，我们可以修改 `p` 的值，即改变 `p` 指向的地址。但是，由于 `q` 指向的指针 `p` 是指向 `const int` 类型的数据，所以我们不能通过 `q` 来修改 `a` 的值。

换句话说，指针的 `const` 传递是从右往左进行的。在这个例子中，`const` 限制了 `q` 指针指向的数据类型，即 `*p` 的类型，使其不能通过 `q` 修改数据。但是，我们仍然可以通过 `p` 来修改 `a` 的值，因为 `p` 不是 `const` 指针。

总结起来，一级指针 `p` 是可变指针，可以修改 `a` 的值，而二级指针 `q` 是指向 `const int` 类型的指针，可以修改 `p` 的值，但不能修改 `a` 的值。





![image-20240606221957506](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240606221957506.png)

类似这种，因为a是int，然后进行&a取地址，相当与int *，所以第二个语句没有毛病

然后总体的话是int* 和int*





引用和指针的区别

1. 左值引用和右值引用
2. 引用的示例

引用是一种更安全的指针

引用变量是把所引用的内存的地址先存下来

实参和形参是按照值传递

![image-20240608221002279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221002279.png)

有类型是引用，没类型是取地址

引用变量的时候会有一个解引用操作

![image-20240608221722288](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221722288.png)

第一个输出等于第三个输出

右值引用

![image-20240608222002322](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222002322.png)

![image-20240608222506499](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222506499.png)

这两种方式是一样的，都是右值引用，不同的是，下面哪个是被const定死了，上面那个是可以被修改的 

一个右值引用变量，本身是一个左值，在应用的时候必须产生临时量

右值引用

1. int && c =20;专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;
2. 右值引用变量本身是一个左值，只能用左值引用来引用他
3. 不能用一个右值引用变量，来引用一个左值

如果遇到很复杂的*&q = p；

那我们就进行还原，**q = &p；

如果p上面是常量指针，那就是错误的





详解new 和 delete

new 和malloc 

delete 和free

malloc  和 free 是c 的库函数

new和delete 是运算符

new 不仅可以做内存开辟，还可以做内存初始化操作

malloc开辟内存失败，是通过返回值和nullptr作比较；而new开辟内存失败，是通过抛出bad_alloc 类型的一场来判断的

```c++
int *q1 = new int[20]();
delete[]q1;
//这种写法是为了释放数组内存
//如果是释放一个元素的你直接delete就好了
int *p1 = new int[20]();
delete p1;
```

free是直接释放起始地址就好了，相对方便很多

new有多少种？

```c++
  //new有多少种？
  int *p1 = new int(20);//抛出异常
  cout << p1 <<endl;
  cout << *p1 <<endl;
  int *p2 = new (nothrow) int;//不抛出异常
  cout << p2 <<endl;
  cout << *p2 <<endl;
  const int *p3 = new const int(40);//在堆上生成常量
  cout << p3 <<endl;
  cout << *p3 <<endl;
  //定位new
  int data = 0;
  int *p4 = new (&data) int(50);//意思就是指定的内存块，定为int类型的值，值为50
  cout << data <<endl;
  
  return 0;

//输出结果
0xed4300
20
0xed4340
-1163005939
0xed4380
40
50
```

![image-20240609100951053](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609100951053.png)

OOP语言的四大特征是什么？

抽象，封装/隐藏，继承，多态

对象的内存是在栈上的

![image-20240609111710657](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609111710657.png)

对象的内存大小，只和成员变量有关

![image-20240610122225073](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122225073.png)

Windows查看内存情况👆



![image-20240610122440334](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122440334.png)

![image-20240610122918587](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122918587.png)

成员变量其实默认编译器会给我们加一个指针，只是我么可以不用手写，直接默认加上

类的成员方法一经编译，所有的成员方法参数都会加上一个this指针，接受调用该方法的一个地址

![image-20240610123054970](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610123054970.png)

函数的析构和构造相当于一个出栈的问题

先构造的后析构，析构函数不带参数，每个析构函数只能有一个，构造函数时可以带参数的，因此可以提供多个构造函数的重载

析构之后对象就不存在了

如果析构之后就会发生对内存的非法访问



堆上的对象什么时候进行析构，在new和delete这个的时候进行析构

delete相当于先析构掉对象，然后再释放内存

![image-20240612003839524](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612003839524.png)

在执行 `delete ps;` 时，会按照以下步骤进行操作：

1. 首先，会调用 `SeqStack` 类的析构函数 `~SeqStack()`，执行对象的清理操作，释放对象内部可能存在的资源。把指针外部的堆内存先释放掉
2. 然后，会释放 `ps` 所指向的动态分配的内存，这是通过 `new` 运算符分配的内存。然后再把对象的内存释放掉

注意两点：

1. 析构函数的调用是由 `delete` 操作自动触发的，不需要显式调用析构函数。
2. `delete` 操作会同时处理对象的析构和内存的释放，不需要显式调用 `free` 函数。

new相当于先内存开辟操作，然后对象构造操作

![image-20240612100044204](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612100044204.png)



#### 深拷贝与浅拷贝

三种类型的对象

在C++中，对象的内存可以分配在不同的区域，包括数据段（静态存储区）、堆和栈。这些区域在分配和释放对象内存以及对象的生命周期方面有所不同。

1. 数据段（静态存储区）：

   - 对象在编译时就分配了固定的内存空间，通常用于存储全局变量和静态成员变量。

   - 对象在程序运行期间一直存在，直到程序结束才会被释放。

   - 对象的构造和析构函数会在程序的启动和结束时自动调用。

     ```c++
     #include <iostream>
     
     // 在数据段中定义一个全局对象
     class GlobalObject {
     public:
         GlobalObject() {
             std::cout << "GlobalObject constructed!" << std::endl;
         }
     
         ~GlobalObject() {
             std::cout << "GlobalObject destroyed!" << std::endl;
         }
     };
     
     GlobalObject global; // 全局对象
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在主函数中定义一个静态对象
         static GlobalObject staticObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`GlobalObject` 类的对象 `global` 是在数据段中定义的全局对象。程序运行时，全局对象会在程序启动时构造，在程序结束时销毁。

2. 堆（动态存储区）：

   - 对象通过使用 `new` 运算符在堆上进行动态分配。

   - 对象的内存分配和释放需要显式地使用 `new` 和 `delete` 或 `new[]` 和 `delete[]` 进行操作。

   - 对象的生命周期由程序员手动管理，需要在不再需要时手动释放内存。

   - 对象在堆上分配的内存，可以在对象的任何作用域中访问。

     ```c++
     #include <iostream>
     
     class HeapObject {
     public:
         HeapObject() {
             std::cout << "HeapObject constructed!" << std::endl;
         }
     
         ~HeapObject() {
             std::cout << "HeapObject destroyed!" << std::endl;
         }
     };
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在堆上动态分配一个对象
         HeapObject* heapObj = new HeapObject();
     
         // 使用对象
     
         // 释放堆上分配的对象
         delete heapObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`HeapObject` 类的对象 `heapObj` 是通过 `new` 运算符在堆上进行动态分配的。程序员需要手动使用 `delete` 运算符释放对象所占用的内存。

3. 栈：

   - 对象通过直接声明或作为局部变量在栈上分配。
   - 对象的内存分配和释放是由编译器自动管理的，遵循栈的后进先出（LIFO）原则。
   - 对象的生命周期与其所在的作用域相对应，当作用域结束时，对象的内存会自动释放。
   - 对象在栈上分配的内存，只能在其声明的作用域内访问。

```c++
#include <iostream>

class StackObject {
public:
    StackObject() {
        std::cout << "StackObject constructed!" << std::endl;
    }

    ~StackObject() {
        std::cout << "StackObject destroyed!" << std::endl;
    }
};

void foo() {
    std::cout << "Inside foo function!" << std::endl;

    // 在函数中定义一个局部对象
    StackObject stackObj;

    std::cout << "Exiting foo function!" << std::endl;
}

int main() {
    std::cout << "Main function started!" << std::endl;

    foo();

    std::cout << "Main function ended!" << std::endl;

    return 0;
}
```

在这个例子中，`StackObject` 类的对象 `stackObj` 是在函数的栈帧中定义的局部对象。当进入函数 `foo` 时，局部对象被构造，当离开函数 `foo` 时，局部对象被析构。栈上的对象的生命周期与其所在作用域相关，无需手动释放内存。





如果拷贝的过程中，内存拷贝，指向的同一块内存指针被释放了，就会产生错误，因为按序析构，被指向的对象已经被释放， 所以报错

```c++
#include <iostream>
using namespace std;
class SeqStack
{
public:
//  void init(int size = 10)
//  {
//    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
//    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
//    _size = size; // 记录栈的总大小
//  }
  SeqStack(int size = 10)
  {
    cout << this << " SeqStack()" << endl;
    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
    _size = size; // 记录栈的总大小
  }
  ~SeqStack()
  {
    cout << this << " ~SeqStack()" << endl;
    delete[] _pstack; // 释放动态分配的数组内存
    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
  }

//  void release(){
//    delete[] _pstack; // 释放动态分配的数组内存
//    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
//  }

  void push(int val)
  {
    if (full()) // 检查栈是否已满，如果已满则进行扩容
      resize();
    _pstack[++_top] = val; // 将新元素 val 入栈，同时栈顶指针加一
  }

  void pop()
  {
    if (empty()) // 检查栈是否为空，如果为空则不执行出栈操作
      return;
    --_top; // 栈顶指针减一，表示将栈顶元素出栈
  }

  int top()
  {
    return _pstack[_top]; // 返回栈顶元素的值，但不修改栈顶指针
  }

  bool empty() { return _top == -1; } // 检查栈是否为空，栈空时栈顶指针为 -1

  bool full() { return _top == _size - 1; } // 检查栈是否已满，栈满时栈顶指针为总大小减一

private:
  int* _pstack; // 动态开辟数组，用于存储顺序栈的元素
  int _top;    // 指向栈顶元素的位置
  int _size;   // 数组扩容的总大小

  void resize()
  {
    int* ptmp = new int[_size * 2]; // 创建一个新的两倍大小的数组
    for (int i = 0; i < _size; ++i) {
      ptmp[i] = _pstack[i]; // 将旧数组中的元素复制到新数组
    }
    delete[] _pstack; // 释放旧数组的内存
    _pstack = ptmp; // 更新指针，指向新数组
    _size *= 2; // 更新栈的总大小为新数组的大小
  }
};
int main()
{
  SeqStack S;//没提供任何构造函数的时候，会位移生成默认的构造和析构函数，是空函数
  SeqStack s1(10);
  SeqStack s2 = s1;//拷贝构造函数，内存的拷贝
  SeqStack s3(s1);//拷贝构造函数
  return 0;//依次析构函数
}
```

![image-20240612102024130](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612102024130.png)

此处为浅拷贝，发生了错误，多个对象指向了同一个资源，同一个资源不可能释放两次，对象默认的拷贝构造，是做内存的数据拷贝

关键是对象如果占用外部资源，那么浅拷贝就出现问题了

```c++
SeqStack(const SeqStack &src)
  {
    cout << this << " &src" <<endl;
    _pstack = new int[src._size];
    for (int i = 0; i < src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这个拷贝构造函数实现了深拷贝，就是不单单复制内存指向，还要修改指针方向
```

修改一下，变成深拷贝，修改指针方向

![image-20240612103541138](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612103541138.png)

当使用 `&src` 这样的引用作为参数时，它适用于传递对象进行拷贝操作。这意味着，如果您传递给拷贝构造函数的参数是一个对象（例如 `MyClass` 类型），它将匹配并执行相应的拷贝操作。

例如，在拷贝构造函数 `MyClass(const MyClass& src)` 中，如果您调用 `MyClass obj1; MyClass obj2 = obj1;`，拷贝构造函数将使用 `obj1` 作为参数 `src`，并执行适当的深拷贝操作。

然而，如果您尝试使用一个不同的类型（例如 `int`）作为参数调用该拷贝构造函数，它将不会匹配该函数的参数类型，因为 `const MyClass&` 不匹配 `int` 类型。在这种情况下，编译器将寻找其他匹配的构造函数或转换函数。

因此，拷贝构造函数的参数类型和函数签名决定了它适用的情况。对于拷贝构造函数 `MyClass(const MyClass& src)`，它适用于接收 `MyClass` 类型的对象，并执行相应的拷贝操作。

而对于其他构造函数，如 `SeqStack(int size = 10)`，它使用 `int` 类型作为参数，适用于创建 `SeqStack` 对象，并初始化对象的大小。

综上所述，通过函数参数的类型和函数签名，可以确定函数适用的情况，从而实现不同类型的对象的创建和拷贝操作。

##### 深浅拷贝的对比

浅拷贝（shallow copy）只是简单地复制指针的值，使得两个对象的指针指向相同的内存块。这样，在两个对象之间进行修改时，它们会共享同一块内存，可能会导致意外的副作用。如果一个对象释放了共享内存，另一个对象仍然引用该内存，就会出现悬空指针的问题。

相比之下，深拷贝（deep copy）会为新对象分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。这样，两个对象就拥有各自独立的内存块，彼此之间的修改不会相互影响。

深拷贝通常涉及以下步骤：

1. 分配新的内存空间，用于存储新对象的资源。
2. 将原始对象的数据复制到新对象的内存空间中。
3. 如果有指针成员变量指向动态分配的内存，需要为新对象的指针成员变量分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。

深拷贝确保了新对象与原始对象具有独立的资源，修改一个对象不会影响另一个对象。

并非所有的对象都需要深拷贝。有些情况下，浅拷贝可能是合适的，例如当对象不包含动态分配的内存，或者两个对象确实需要共享相同的资源时（例如共享缓冲区的多个对象）。

面向对象的拷贝里面基本都是使用for循环，除非我确认我现在的资源数据，**没有占用外部资源**



```c++
void operator = (const SeqStack &src)
  {
    cout << " operator" << endl;
    if (this == &src)
      return;//防止自赋值
    delete[]_pstack;
    _pstack = new int[src._size];
    for (int i = 0; i <= src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这是为了给s2=s1这种操作做一个赋值函数，防止自赋值
//实现逻辑是防止自赋值，然后释放当前对象占用的外部资源，然后实现深拷贝的操作
```

如果前拷贝发生问题，需要做构造自定义的拷贝构造函数和赋值重载函数（s2=s1这种操作)

#### 类和对象代码实践

##### 普通构造函数（字符串or指针）

![image-20240612114147287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114147287.png)如果判断指针的话，对字符串操作的话，最好要判断是否为空

拷贝构造函数

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114343362.png" alt="image-20240612114343362" style="zoom:80%;" />

为什么+1呢，因为要给\0留个位置



析构函数

![image-20240612114507179](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114507179.png)

写完之后要给这个指针制成一个nullptr。

为什么？因为要防止野指针的存在



赋值重载函数

![](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114806184.png)

三步走（防止自赋值->delete->拷贝赋值

![image-20240612114846727](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114846727.png)

![image-20240612114933585](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114933585.png)

这样子写法就会出现，如果重载函数是void，就返回一个void，然后str3就无法接受数据了，或者说接受的是void

string& 是为了支持连续的operator操作

##### 尝试写循环队列

![image-20240612120802943](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612120802943.png)

![1718165564279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\1718165564279.png)

![image-20240612181716652](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612181716652.png)

![image-20240612182318377](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612182318377.png)

构造函数初始化列表

1.  效率：通过构造函数初始值列表，可以避免先调用默认构造函数创建对象，再在构造函数体内对成员变量进行赋值的额外开销。直接在构造函数初始值列表中初始化成员变量，可以减少不必要的对象初始化和赋值操作，提高效率。
2.  成员变量常量性：构造函数初始值列表可以用于初始化成员变量，即使这些成员变量被声明为 `const` 或引用类型。在构造函数体内部，无法对 `const` 成员变量进行赋值操作，所以使用构造函数初始值列表是唯一的选择。
3.  初始化顺序：构造函数初始值列表指定了成员变量初始化的顺序，可以确保成员变量按照指定的顺序进行初始化，而不是按照它们在类中声明的顺序。这对于成员变量之间存在依赖关系的情况很有用。

```c++
#include <cstring>
#include <string>
class Date {
private:
  int _year;
  int _month;
  int _day;
public:
  Date(int year, int month, int day) : _year(year), _month(month), _day(day) {}

  void printDate() {
    std::cout << "Date: " << _year << "-" << _month << "-" << _day << std::endl;
  }
};

class Goods {
private:
  char* _name;
  int _amount;
  double _price;
  Date _data;
public:
  Goods(char* name, int amount, double price, int year, int month, int day)
      : _data(year, month, day), _amount(amount), _price(price) {
    // 对 _name 进行内存分配，并将 name 的内容复制到 _name
    _name = new char[strlen(name) + 1];
    strcpy(_name, name);
  }

  void printDetails() {
    std::cout << "Name: " << _name << std::endl;
    std::cout << "Amount: " << _amount << std::endl;
    std::cout << "Price: " << _price << std::endl;
    _data.printDate();
      //可以将其理解为在 Goods 类的构造函数中，通过构造函数初始化列表对 _data 进行初始化。这个初始化过程是将参数 y、m 和 d 传递给 Date 类的构造函数，在 Date 类内部进行处理，然后返回一个 Date 类的对象，最终将这个对象赋值给 Goods 类的成员变量 _data。
  }

  ~Goods() {
    delete[] _name; // 释放 _name 的内存
  }
};

int main() {
  Goods item("Example Item", 10, 2.99, 2024, 6, 12);
  item.printDetails();

  return 0;
}
```

![image-20240612193533434](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612193533434.png)

相当于直接定义+初始化一把搞定---初始化列表

2的那种方式是麻烦一点的简单

成员变量的初始化与他们的定义的顺序有关，跟构造函数初始化列表中出现的先后顺序无关



##### 掌握类的各种成员方法以及区别

static静态成员变量一定要在类外定义和初始化

![image-20240613212922404](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240613212922404.png)

👆，因为比如一个count，那你每个类对象都会调用一个count，这样子事不行的，所以需要吧他放出来做静态成员变量，但是，尽可能不要用太多全局变量

else 静态成员变量是在栈上的，不属于对象的，属于类级别的，他相当于就是个全局变量，只是作用在类里面而已

![image-20240614204038397](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204038397.png)

区别是普通方法存在this指针，静态方法是没有this指针的

静态方法是不需要对象的，不产生this指针，就不需要对象的地址，可以在作用域里面调用它

static静态成员方法

![image-20240614204812277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204812277.png)

普通成员方法

![image-20240614204829141](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204829141.png)

常成员方法

![image-20240614205207642](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205207642.png)

const类型的形参👆

常对象的方法必须使用常对象的指针

只要是只读操作的成员方法，一律定义成常成员方法

const常成员方法-》const CGOODS *this

1. 属于类的作用域
2. 调用依赖一个对象，普通对象或者常成员对象都可以
3. 可以调用访问对象的私有成员，但是只能读，不能写

![image-20240614205743776](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205743776.png)

三种成员方法总结

![image-20240614205823292](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205823292.png)

如果定义一个普通类的成员变量，我们需要添加一个类的作用域

指向一个普通成员的时候一定要带上对象

![image-20240614210732783](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614210732783.png)

指向成员方法的指针

一定要依赖对象

![image-20240614212710062](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614212710062.png)

如何定义函数指针指向类的static成员方法

```c++
#include <iostream>

class MyClass {
public:
    static void staticMethod(int value) {
        std::cout << "Static method called with value: " << value << std::endl;
    }
};

int main() {
    // 定义函数指针类型
    typedef void (*StaticMethodPtr)(int);

    // 声明并初始化函数指针，指向类的静态成员方法
    StaticMethodPtr ptr = &MyClass::staticMethod;

    // 使用函数指针调用静态成员方法
    ptr(42);

    return 0;
}
```





#### 模板

##### 理解模板

c++模板的意义是：可以对类型也可以进行参数化了

int sum(int a,int b){return a+b;}

函数模板《=是不进行编译的,因为类型不知道

模板的实例化《= 函数调用点进行实例化

模板函数《《=才是编译器所编译的



模板类型参数 typename/class

模板非类型参数



模板的实参推演==》可以根据用户传入的实参类型进行推断

模板的特例化（专用化）

模板函数，模板的特例化，非模板函数的重载关系







![image-20240616140824969](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616140824969.png)

模板函数实例化只用实例一次

如果是这里的compare函数是（10.5，20）；

![image-20240616141123517](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616141123517.png)

这样子会导致错误，类型错误

所以需要compare<int>(30,40.5);这样子，强制转换了一下

所以在这里说，函数模板是不参加编译的

在调用点进行实例化，注重功能实现

对于某些类型来说，编译器根据用户给的数据进行的推断是有错误的-》这个时候需要进行特例化

比如针对compare模板函数，提供const char*类型特例化版本

![image-20240616143827353](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143827353.png)

还有非模板函数

![image-20240616143958255](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143958255.png)

这三个的共存时候，比如compare（"aaa","bbb");

会优先调用非模板函数

如果是

![image-20240616144141339](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616144141339.png)

则优先调用特例化模板，看他有没有指明模板的使用，优先把compare处理成函数名字，没有的话，才去找compare模板

模板声明

![image-20240616152024668](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152024668.png)

因为模板是不编译的，所以别再一个文件定义了，别的文件就直接使用，你得进行声明

所以一般是放在头文件中，然后再源文件中使用include包含

![image-20240616152512220](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152512220.png)





##### 函数模板

模板的非类型参数，都是常量，只能使用而不能修改

这里面只能用整形的int，char，short，long

![image-20240616153659948](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616153659948.png)

指定类型，常量，

函数的非类型模板参数必须是整数类型（整数或者地址/引用都可以）都是常量

 ![image-20240616154037174](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616154037174.png)

##### 

##### 类模板

```c++
template<typename T>
class SeqStack // 模板名称+类型参数列表=类名称
{
public:
    //构造和析构函数名不用加<T> ,其他的出现模板的地方都加上类型参数列表
  SeqStack(int size=10);
  ~SeqStack()；
  SeqStack(const SeqStack<T> &stack);
  
private:
  T *_pstack;
  int _top;
  int _size;

};
int main()
{
  return 0;
}
```

如果写成员方法，只读操作的话，那就const加上限制，这样子普通对象能调用，常对象也能调用

赋值三部曲

1. 防止自赋值![image-20240616204121844](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204121844.png)

2. 释放原来的空间![image-20240616204145882](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204145882.png)
3. 根据大小开辟空间![image-20240616204206595](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204206595.png)

以上是赋值运算符的重载

```c++
T *ptmp = new T[_size * 2];
//像这样子的写法，就是一个模板类的使用，T作为一个占位符，将在具体实例化时由实际类型进行使用，如果是int那就是编译器自动确认为int
```

class类名的时候会实例化一个类

##### 简单介绍下类模板的选择性实例化

在 C++ 中，类模板的选择性实例化（Explicit Specialization）和部分实例化（Partial Specialization）是非常有用的特性，允许你为某些特定类型或类型组合提供特化的实现，而无需影响到其他类型的实现。以下是对这两种技术的详细讲解：

###### 1. 类模板的完全特化（Explicit Specialization）

完全特化是为特定类型提供完全不同的实现。在这种情况下，你可以为模板参数的特定类型定义一个特殊版本的类。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化版本，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;
    MyClass<int> obj2;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

###### 2. 类模板的部分特化（Partial Specialization）

部分特化允许你为模板参数的某些特定组合提供特化实现，而不需要完全特化整个模板。部分特化比完全特化更灵活，因为它只需特化部分参数。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T, typename U>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 部分特化，针对第二个参数为 int 的情况
template <typename T>
class MyClass<T, int> {
public:
    void display() {
        std::cout << "Partial specialization: second parameter is int" << std::endl;
    }
};

// 部分特化，针对第一个参数为 int 的情况
template <typename U>
class MyClass<int, U> {
public:
    void display() {
        std::cout << "Partial specialization: first parameter is int" << std::endl;
    }
};

int main() {
    MyClass<double, double> obj1;
    MyClass<double, int> obj2;
    MyClass<int, double> obj3;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Partial specialization: second parameter is int
    obj3.display();  // 输出: Partial specialization: first parameter is int

    return 0;
}
```

###### 选择性实例化的应用

选择性实例化在以下情况下特别有用：

1. **优化特定类型**：为特定类型提供优化实现。例如，针对常用的 `int` 类型，可以提供更高效的算法或数据结构。
2. **处理特殊行为**：某些类型可能需要特殊处理。例如，处理指针类型时可能需要特化模板以避免常见的错误或提供特殊的行为。
3. **类型特性**：某些类型可能具有不同的特性，需要不同的实现来处理。例如，浮点数和整数的处理方式可能有所不同。

##### 总结

类模板的选择性实例化通过完全特化和部分特化提供了灵活性，允许你为特定类型或类型组合提供特化实现。理解和掌握这两个特性，可以使你的模板代码更加通用和高效，同时在需要时提供特定的优化和行为。



### 简单讲解模板类，类模板，实例化

在C++中，类模板、模板类、和类模板的实例化是模板编程的重要概念。这些概念之间的关系如下：

##### 类模板（Class Template）

类模板是一种蓝图或模板，用于定义一个可以处理多种不同数据类型的类。它允许你编写通用的类定义，并在需要时使用具体的类型进行实例化。

##### 定义类模板

```cpp
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};
```

- `template <typename T>`：这是模板参数列表，告诉编译器这是一个模板类，`T`是一个占位符，表示某种类型。
- `class MyClass`：定义了一个类模板`MyClass`，这个类可以处理任何类型`T`。

##### 模板类（Template Class）

当类模板使用具体类型进行实例化时，生成的类称为模板类。模板类是类模板的具体化版本，每个模板参数对应一个具体类型。

##### 实例化模板类

```cpp
MyClass<int> intObj;     // 实例化一个模板类，T 被替换为 int
MyClass<double> dblObj;  // 实例化一个模板类，T 被替换为 double
```

- `MyClass<int>`：表示一个模板类，`T`被具体化为`int`类型。
- `MyClass<double>`：表示一个模板类，`T`被具体化为`double`类型。

##### 类模板的实例化（Instantiation of Class Template）

类模板的实例化是将类模板用具体的类型参数替换模板参数，从而生成模板类的过程。这个过程可以是显式的（用户在代码中明确指定类型）或隐式的（编译器自动推导类型）。

#### 显式实例化

```cpp
MyClass<int> intObj;     // 显式实例化
MyClass<double> dblObj;  // 显式实例化
```

##### 隐式实例化

当类模板用于函数模板中时，编译器可以根据传递的参数类型自动推导模板参数，从而隐式实例化类模板。

```cpp
template <typename T>
void function() {
    MyClass<T> obj;  // 隐式实例化，编译器根据函数模板的参数推导 T 的类型
}
```

##### 关系总结

1. **类模板**：是一种通用的类定义，使用模板参数（如`typename T`）来表示将来的类型。它是一个蓝图，定义了类的结构和行为，但没有具体化任何类型。

2. **模板类**：是类模板经过实例化后的具体版本，模板参数被替换为具体类型。例如，当类模板`MyClass`使用`int`类型实例化时，就得到了一个模板类`MyClass<int>`。

3. **类模板的实例化**：是将类模板中的模板参数替换为具体类型的过程。可以通过显式指定类型来实例化（如`MyClass<int> intObj`），也可以在使用模板类时由编译器自动推导。

##### 示例

完整的示例展示了类模板的定义、实例化和生成模板类的过程：

```cpp
#include <iostream>

// 定义类模板
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化类模板，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;  // 使用 double 实例化类模板，生成模板类 MyClass<double>
    MyClass<int> obj2;     // 使用 int 实例化类模板，生成模板类 MyClass<int>，并使用特化版本

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

在这个示例中：
- `MyClass`是一个类模板。
- `MyClass<double>`和`MyClass<int>`是模板类。
- `MyClass<double> obj1`和`MyClass<int> obj2`是类模板的实例化过程。

通过理解这三个概念及其关系，你可以更好地利用模板编程的强大功能来编写通用、灵活和高效的代码。





##### 容器空间配置器，在vector里面的

将内存开辟和析构分开

析构容器里面的元素，然后释放指针指向的容器里面的堆内存

在容器里面删除一个元素应该是 析构掉这个元素的对象，而不是释放这个元素的堆内存

###### 主要是做四件事

1. 内存开辟
2. 内存释放
3. 对象构造
4. 对象析构





#### 运算符重载

##### 学习复数类CComplex

* 不能返回一个局部对象或者局部变量的指针，或者引用等

```c++
//c++的运算符重载

class CComplex
{
public:
  CComplex(int r = 0,int i = 0)
      :mreal(r),mimage(i){}
  //CComplex operator+(const CComplex &src)
  //{
//    CComplex comp;
//    comp.mreal = this->mreal + src.mreal;
//    comp.mimage = this->mimage + src.mimage;
//    return comp;//不能返回一个局部对象或者局部变量的指针，或者引用等
  //    return CComplex(this->mreal + src.mreal,
   //             this->mimage + src.mimage);
  //}
  //因为已经由全局的了，可以屏蔽掉局部的函数
  CComplex operator++(int)
  {
    CComplex comp = *this;
    mreal += 1;
    mimage += 1;
    return comp;
    //为什么这个不可以返回引用呢，因为这是一个局部对象，所以不能这样子
  }
  CComplex& operator++()//返回辅助对象的一个引用，可以不产生临时对象
  {
    mreal += 1;
    mimage += 1;
    return *this;
  }
  void operator+=(const CComplex &src)
  {
    mreal += src.mreal;
    mimage += src.mimage;

  }
  void show(){cout << "real: " << mreal << " image: " << mimage << endl;}
private:
  int mreal;
  int mimage;
  friend CComplex operator+(const CComplex &lhs,const CComplex &rhs);
  friend ostream& operator<< (ostream &out ,const CComplex &src);
  friend istream& operator >> (istream &in ,CComplex &src);
};
CComplex operator+(const CComplex &lhs,const CComplex &rhs)
{
  cout << "nice" << endl;
  return CComplex(lhs.mreal + rhs.mreal,lhs.mimage+rhs.mimage);
}//全局的方法

ostream& operator<< (ostream &out ,const CComplex &src)
{
  out << "mreal: " << src.mreal << "mimage: " << src.mimage <<endl;
  return out;
}
istream& operator >> (istream &in ,CComplex &src)
{
  in >> src.mreal >> src.mimage;
  return in;

}//输入运算符的重载
int main(){
  CComplex complex(10,10);
  CComplex complex1(20,20);
  //加法运算符的重载函数
  CComplex complex2 = complex + complex1;
  complex2.show();
  CComplex complex3 = complex + 20;//相当于comp.operator + (20) int ->CCom CComplex(int);
  complex3.show();

//  CComplex complex4 =  20+complex ;
                                   // 这个就不行了，30在这里面没有生成形参对象，所以不存在生成临时对象
  //编译器在做对象运算的时候，会调用对线的运算重载函数（优先调用成员方法）；如果没有成员方法，那就在全局做哟ing与找合适的运算符重载函数
    CComplex complex4 =  20+complex ;
    complex4.show();
    complex4 = complex++;//++ 和-- 是单目运算符
    complex.show();
    complex4.show();
    complex4 = ++complex;
    complex.show();
    complex4.show();
    cout << "hh " << endl;

    complex2 +=complex;
    complex.show();
    complex2.show();
    cin >> complex >> complex1;
    cout << complex << complex1 << endl;

}
template<typename T>
void show(T a)
{
  cout << a << endl;

}
```



##### 单目运算符---->  ++ 和 --

在C++中，`++`运算符可以通过运算符重载进行自定义，以便适用于用户定义的类型。`++`运算符有两种形式：前置形式（prefix）和后置形式（postfix）。它们可以通过成员函数或友元函数来重载。下面我们分别介绍这两种形式的重载方法。

###### 前置形式（Prefix）

前置形式的运算符重载用于实现`++obj`的行为。其重载函数通常返回对自身的引用。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    ++counter;
    counter.display();  // 输出: Counter value: 1

    return 0;
}
```

在这个示例中，我们重载了前置形式的`++`运算符，使其对`value`执行自增操作，然后返回当前对象的引用。

###### 后置形式（Postfix）

后置形式的运算符重载用于实现`obj++`的行为。其重载函数需要一个整数类型的哑参数来与前置形式区分开。后置形式的运算符重载通常返回对象的副本。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    // 重载后置 ++ 运算符
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    counter++;
    counter.display();  // 输出: Counter value: 1

    ++counter;
    counter.display();  // 输出: Counter value: 2

    return 0;
}
```

在这个示例中，我们重载了后置形式的`++`运算符。该运算符先保存当前对象的副本，执行自增操作，然后返回保存的副本。

###### 总结

- 前置形式的`++`运算符重载不带参数，返回当前对象的引用。
- 后置形式的`++`运算符重载带有一个整数哑参数，返回自增前对象的副本。

通过重载这两种形式的`++`运算符，我们可以为自定义类型实现与内置类型类似的自增操作。





![image-20240618002923453](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240618002923453.png)



数组底层其实都是char类型，所以需要用char类型返回

![image-20240621004352323](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004352323.png)

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135342315.png" alt="image-20240620135342315" style="zoom:80%;" />

比如这里，因为我要返回括号里面的数字，所以重载了 [] ，然后返回，返回对象，可以修改

如果是加const在开头则不允许修改

![image-20240620135601765](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135601765.png)





const char* c_str

![image-20240620230405890](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620230405890.png)

![image-20240620233018119](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233018119.png)

这种foreach的做法还是通过迭代器完成的

![image-20240620233136189](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233136189.png)

哈希和红黑树不适合用[]这个，这是支持随机存取的，其他的不支持





#### 迭代器失效问题

![image-20240621001905994](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621001905994.png)

非法操作👆

原因是这样，在你完成一次删除之后，会导致在这个范围内的迭代器失效了

![image-20240621002347928](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002347928.png)

![image-20240621002502908](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002502908.png)

在删除和增加之后的迭代器会失效的，所以需要进行break

扩容也会发生失效，原来的迭代器就全部失效

进行这些操作之后，it就失效了

新的iteratr返回当前位置，后边的元素会往前挪，**那就是在容器的过程中，如果需要增加或者删除，就是连续多次的操作，一定需要进行更新**

![image-20240621004130942](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004130942.png)

这里需要添加两次，从而完成添加



以下是迭代器的初始条件

![image-20240621004609197](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004609197.png)



2. 不同迭代器是不能进行比较的

![image-20240621004510557](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004510557.png)

![image-20240621004905995](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004905995.png)

👆迭代器失效增加代码

![image-20240621101634450](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621101634450.png)

通过这段代码，我们新生成容器某一个位置的迭代器





帮助理解，删除末尾元素的pop_back，我们可以理解成删除末尾元素，然后让迭代器失效

![image-20240621102156449](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102156449.png)

![image-20240621102226757](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102226757.png)

verify做检查迭代器

如果发现这个迭代器失效了，就把这个容器指针置为空指针





检查迭代器有效性

![image-20240621102711792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102711792.png)



## 迭代器失效问题总结

在容器中进行删除和插入操作时，迭代器失效（iterator invalidation）是一个常见的问题。迭代器失效意味着在删除或插入操作之后，先前有效的迭代器可能会变得无效，不能再被安全地使用。如果在删除和插入操作之后不进行适当处理而继续使用这些迭代器，可能会导致程序崩溃或未定义行为。

### 迭代器失效的原因

#### 删除操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 当从 `std::vector` 或 `std::deque` 中删除元素时，**删除位置之后的所有迭代器**都会失效，因为元素需要被移动以填补空隙。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中删除元素时，只有指向被删除元素的迭代器会失效，其他迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中，删除操作只会使指向被删除元素的迭代器失效。

#### 插入操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 在 `std::vector` 或 `std::deque` 中插入元素时，如果插入导致容器重新分配内存，则所有迭代器都会失效。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中插入元素时，所有迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中插入元素不会使任何现有的迭代器失效。

### 处理迭代器失效的方法

1. **删除操作后的处理**:
   - 使用删除操作返回的新迭代器继续循环。
   - 在 `std::list` 这样的链表中，使用删除元素前的迭代器来继续操作。

2. **插入操作后的处理**:
   - 在序列容器中插入元素后，重新获取容器的迭代器。

### 示例代码

#### 删除操作

假设我们有一个 `std::vector<int>`，需要删除所有的偶数元素：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end();) {
        if (*it % 2 == 0) {
            it = vec.erase(it);  // erase 返回一个指向被删除元素之后的迭代器
        } else {
            ++it;
        }
    }

    // 输出剩余元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
//先检查这个，使其迭代器失效然后析构当前的对象，然后再构造一个新对象出来，然后把元素进行拷贝，完成拷贝构造，然后迭代器++
```

![image-20240621104413117](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621104413117.png)

#### 插入操作

假设我们有一个 `std::vector<int>`，需要在偶数前面插入 -1：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it % 2 == 0) {
            it = vec.insert(it, -1);  // insert 返回一个指向插入元素的迭代器
            ++it;  // 跳过新插入的元素
        }
    }

    // 输出修改后的元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
```

### 总结

- **删除操作**: 在删除元素后，必须使用 `erase` 返回的新迭代器继续循环。
- **插入操作**: 在插入元素后，必须更新迭代器以继续循环。

在容器进行插入和删除操作时，正确处理迭代器非常重要，以避免迭代器失效导致的程序错误。

## 深入理解new和delete原理

![image-20240621114916231](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621114916231.png)

```c++
Test *p2 = new Test[5];
delete []p2;

```

这看上去消耗了5*4=20个字节，实际上还要多一个，因为还得存储多一个，用来存储对象的个数5个

![image-20240621154742278](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621154742278.png)

然后存储完成之后，指针返回的地址是哪个呢，是0*104这个

，因为不需要让用户知道你的开辟内存地址，只需要知道你第一个对象的地址就好了

![image-20240621155521021](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155521021.png)

总结：free和delete的区别

![image-20240621155741578](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155741578.png)





对象池部分

![image-20240621172300956](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621172300956.png)

节点归还就直接吧节点归还的地方用作首届点





## 继承的本质

**继承的本质：**

1. 代码的复用![image-20240622093809546](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622093809546.png)在这个派生类下面的成员也可以是使用的，可以定义多一个ma，不会发生冲突，只要在这个作用域里面使用就行

2. 组和类之间的关系：a：组合 a part of ... 一部分关系 
   继承 b: a kind of 。。。 一种关系

3. | 继承方式                                                     | 基类的访问限定                                               | 派生类的访问限定                       | (main)外部的访问限定 |
   | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- | -------------------- |
   | public                                                       | public<br />protected<br />private(只有自己或者友元才能访问) | public<br />protected<br />不可见的    | Y<br />N<br />N      |
   | protected<br />（基类成员的访问限定，在派生类里面不可能超过继承方式的） | public<br />protected<br />private                           | protected<br />protected<br />不可见的 | N<br />N<br />N      |
   | private                                                      | public<br />protected<br />private                           | private<br />private<br />不可见的     | N<br />N<br />N      |

   **Public继承**：

   - 公有成员（public members）在派生类中保持为公有。
   - 保护成员（protected members）在派生类中保持为保护。
   - 私有成员（private members）在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Protected继承**：

   - 公有成员在派生类中变为保护。
   - 保护成员在派生类中保持为保护。
   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Private继承**：

   - 公有成员在派生类中变为私有。

   - 保护成员在派生类中变为私有。

   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

     **总结**：

     1. 外部只能访问对象public对象成员，另外两个类型的成员无法直接访问
     2. 在继承结构中，派生类可以继承过来的Private的成员，但是派生类却无法直接访问
     3. Protected 和 Private的区别？在基类中定义的对象，想被派生类访问，但是不想被外部访问，那么在基类中，把相关成员定义成Protected保护的，如果派生类和外部都不打算访问，那么在基类中，就把相关成员定义成Private私有的

**默认的继承方式是什么：**

要看派生类是class定义的，还是struct定义的？

class定义派生类，默认继承方式是Private

struct定义派生类，默认继承方式是Public

##### 问题合集

1. 派生类从继承可以继承来所有成员（变量和方法），除过构造函数和析构函数
   **派生类如何初始化从基类继承来的成员变量呢？**

   解答：通过调用基类相应的构造函数来初始化
   派生类的构造函数和析构函数，负责初始化和清理派生类部分
   派生类从基类继承来的成员的初始化和清理由谁来负责呢？是由基类的构造和析构函数来负责
   派生类对象构造和析构的过程是：

   ![image-20240622103246769](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622103246769.png)

   1. 派生类调用基类的构造函数，初始化从基类继承来的对象
   2. 调用派生类自己的构造函数，初始化派生类自己特有的成员
   3. 调用派生类的析构函数，释放派生类成员可能调用的外部资源（堆内存，文件）
   4. 调用基类的析构函数，释放派生类内存，从基类继承来的成员可能占用的外部资源（堆内存，文件）

## 重载，隐藏，覆盖

1. 重载关系：一组函数要重载，必须处于同一个作用域当中，而且函数名字相同，参数列表不同

2. 隐藏（作用域的隐藏）关系：在继承结构当中，派生类的同名成员，把基类的同名成员给隐藏调用了

   ===============================================================================

   ![image-20240622111630005](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622111630005.png)

![image-20240622113023118](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622113023118.png)

继承结构中的类型转换

1. 基类指针可以指向派生类对象，但只能访问基类部分的成员。 
2. 派生类指针指向基类对象会导致内存非法访问，因为指针类型与对象实际类型不匹配。 
3. 类型转换默认支持从派生类到基类的转换，但反向转换是不安全的。



**覆盖 **

基类和派生类的方法，返回值，函数名以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理程序函数，他们之间成为覆盖关系



## 虚函数，静态绑定和动态绑定

静态调用

![image-20240622115313795](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115313795.png)

![image-20240622115449046](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115449046.png)

总结一：

一个类里面定义了虚函数，那么编译阶段，编译器给这个类类型产生了一个位移的Vftable虚函数标，虚函数标重主要存储的内容是RTTI指针和虚函数的地址

![image-20240622115907217](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115907217.png)

![image-20240622134440166](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622134440166.png)

总结四：如果派生类中的方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，而且派生类的方法是virtual虚函数，那么派生类的这个方法，自动处理成虚函数

覆盖指的是虚函数表里面的覆盖

![image-20240622141121060](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141121060.png)

动态绑定--》指的是函数的调用

![image-20240622141428550](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141428550.png)

不带参数的先绑定

![image-20240622142316447](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622142316447.png)

![image-20240622143116277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622143116277.png)

判断这些函数指向的时候的思路



### 静态绑定和动态绑定

**静态绑定**（Static Binding）和**动态绑定**（Dynamic Binding）是两种方法，用来在程序运行时确定函数调用的具体实现。

1. **静态绑定**：
   - 也称为早绑定（Early Binding）。
   - 在编译时确定函数调用。
   - 非虚函数和普通函数通常使用静态绑定。

2. **动态绑定**：
   - 也称为晚绑定（Late Binding）。
   - 在运行时确定函数调用。
   - 通过虚函数实现。

### 虚函数

**虚函数**是C++中的一种特殊成员函数，可以在基类中声明，并在派生类中重写（override）。虚函数使得在运行时通过基类指针或引用调用派生类的实现成为可能，这就是动态绑定的实现方式。

### 示例

让我们通过一个具体的例子来说明这些概念：

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    // 基类中的虚函数
    virtual void speak() {
        cout << "Animal speaks" << endl;
    }
    
    // 基类中的非虚函数
    void run() {
        cout << "Animal runs" << endl;
    }
};

class Dog : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Dog barks" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Dog runs" << endl;
    }
};

class Cat : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Cat meows" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Cat runs" << endl;
    }
};

int main() {
    Animal* animalPtr;
    Dog myDog;
    Cat myCat;

    // 静态绑定：调用非虚函数
    myDog.run(); // 输出 "Dog runs"
    myCat.run(); // 输出 "Cat runs"

    // 动态绑定：调用虚函数
    animalPtr = &myDog;
    animalPtr->speak(); // 输出 "Dog barks"

    animalPtr = &myCat;
    animalPtr->speak(); // 输出 "Cat meows"

    return 0;
}
```

### 解释

1. **Animal 类**：
   - `Animal` 是基类，包含一个虚函数 `speak()` 和一个非虚函数 `run()`。
   - `virtual` 关键字告诉编译器这个函数可以在派生类中重写。

2. **Dog 类和 Cat 类**：
   - `Dog` 和 `Cat` 是从 `Animal` 派生的类。
   - 它们都重写了 `speak()` 和 `run()` 函数，提供自己的实现。

3. **静态绑定**：
   - 当调用 `myDog.run()` 或 `myCat.run()` 时，编译器在编译时已经确定了具体调用 `Dog::run()` 或 `Cat::run()`。
   - 因此，这些调用是静态绑定的。

4. **动态绑定**：
   - 当通过基类指针 `animalPtr` 调用虚函数 `speak()` 时，编译器在运行时根据指针指向的具体对象类型（`Dog` 或 `Cat`）确定调用哪个 `speak()` 实现。
   - 这种在运行时确定函数调用的机制就是动态绑定。

### 动态绑定的实现

动态绑定通过虚函数表（vtable）和虚指针（vptr）实现。每个包含虚函数的类在编译时都会生成一个虚函数表，表中存储了该类的虚函数的地址。每个对象包含一个指向其类的虚函数表的指针。当通过基类指针调用虚函数时，程序会通过虚指针找到虚函数表，再从表中找到具体的函数地址并调用它。

### 总结

- **静态绑定**：在编译时确定函数调用，通常用于非虚函数。
- **动态绑定**：在运行时确定函数调用，通常用于虚函数，通过虚函数表实现。
- **虚函数**：使动态绑定成为可能，允许在基类中声明函数，并在派生类中重写。

理解这些概念可以帮助你更好地掌握面向对象编程和多态性的实现，从而编写出更灵活和可扩展的代码。





**问题一:哪些函数不能实现成虚函数?**
虚函数依赖:

1. 虚函数能产生地址，存储在vftable当中虚函数地址)

2. 对象必须存在(vfptr ->vftable ->虚函数地址）

   构造函数

   1. virtual+构造函数 NO!

      构造函数中(调用的任何函数，都是静态绑定的)调用虚函数，也不会发生静态绑定

      派生类对象构造过程   

      1. 先调用的是基类的构造函数

      2.  才调用派生类的构造函数

         **static静态成员方法  No!   virtual + static**

基类的析构函数是virtual虚函数，那么派生类的析构函数自动成为虚函数，

**问题二 ：虚析构函数，析构函数调用的时候对象是存在的！**

什么时候把基类的析构函数必须实现成虚函数?

基类的指针(引用)指向堆上new出来的派生类对象的时候， delete pb(基类的指针）

它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用

![image-20240622212335687](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622212335687.png)

## 什么时候动态绑定，什么时候静态绑定？

在C++中，是否使用动态绑定取决于是否通过基类指针或引用调用虚函数。让我们深入探讨何时使用静态绑定，何时使用动态绑定，以及虚函数在什么情况下不会触发动态绑定。

### 静态绑定 vs. 动态绑定

**静态绑定（Static Binding）**：
- 在编译时确定函数调用。
- 适用于普通函数和非虚函数。
- 适用于通过对象直接调用函数的情况。

**动态绑定（Dynamic Binding）**：
- 在运行时通过虚函数表确定函数调用。
- 适用于虚函数。
- 适用于通过基类指针或引用调用虚函数的情况。

### 何时使用动态绑定

动态绑定发生在以下情况下：
1. **通过基类指针或引用调用虚函数**：
   - 当使用基类指针或引用调用虚函数时，编译器无法在编译时确定具体调用的是哪一个派生类的实现，因此在运行时通过虚函数表进行解析。

```cpp
class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 动态绑定
}
```

2. **多态性**：
   - 当我们希望在运行时根据对象的实际类型执行不同的操作时，使用动态绑定。

### 何时使用静态绑定

静态绑定发生在以下情况下：
1. **非虚函数调用**：
   - 对于非虚函数，编译器在编译时已经知道该调用哪个函数实现，因此直接绑定。

```cpp
class Base {
public:
    void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 静态绑定
}
```

2. **通过对象直接调用虚函数**：
   - 当通过具体对象（而不是基类指针或引用）调用虚函数时，编译器在编译时也可以确定具体的调用。

```cpp
Derived d;
d.show(); // 静态绑定，因为对象类型已知
```

### 虚函数不触发动态绑定的情况

有几种情况下，尽管函数声明为虚函数，但不会触发动态绑定：

1. **通过对象直接调用虚函数**：
   - 如果你使用具体对象调用虚函数，编译器已经知道该对象的类型，因此不需要在运行时解析。

```cpp
Base b;
b.show(); // 静态绑定，调用 Base::show
Derived d;
d.show(); // 静态绑定，调用 Derived::show
```

2. **在构造函数或析构函数中调用虚函数**：
   - 在构造函数或析构函数中调用虚函数时，会使用当前类的版本，而不是派生类的版本。这是因为在构造函数和析构函数执行期间，派生类的部分可能尚未初始化或已经销毁。

```cpp
class Base {
public:
    Base() {
        show(); // 调用 Base::show
    }
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    Derived() : Base() {}
    void show() override {
        cout << "Derived::show" << endl;
    }
};

Derived d; // 构造函数期间调用 Base::show
```

### 例子总结

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }

    void display() {
        cout << "Base::display" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }

    void display() {
        cout << "Derived::display" << endl;
    }
};

int main() {
    Base b;
    Derived d;
    Base* basePtr = &d;

    b.show();          // 静态绑定，调用 Base::show
    d.show();          // 静态绑定，调用 Derived::show
    basePtr->show();   // 动态绑定，调用 Derived::show

    b.display();       // 静态绑定，调用 Base::display
    d.display();       // 静态绑定，调用 Derived::display
    basePtr->display(); // 静态绑定，调用 Base::display (因为 display 不是虚函数)

    return 0;
}
```

### 结论

- **静态绑定**：在编译时确定函数调用。适用于非虚函数或通过对象直接调用虚函数的情况。
- **动态绑定**：在运行时确定函数调用。适用于通过基类指针或引用调用虚函数的情况。
- 虚函数在特定情况下（如通过对象直接调用或在构造函数和析构函数中调用）不会触发动态绑定。

![image-20240622220619120](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220619120.png)

![image-20240622220417219](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220417219.png)

### **解释在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本。**

理解 "在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本" 需要深入了解 C++ 的对象构造和虚函数的工作机制。以下是详细解释：

#### 背景知识

**虚函数表（vtable）**：
- 每个包含虚函数的类都有一个虚函数表（vtable），表中存储了该类的虚函数指针。
- 每个对象都有一个隐藏的指针（vptr），指向它所属类的虚函数表。

**动态绑定**：
- 当通过基类指针或引用调用虚函数时，实际调用的函数在运行时通过虚函数表决定。这称为动态绑定。

#### 构造函数和析构函数中的行为

#### 构造函数

1. **构造对象的顺序**：
   - 当一个派生类对象被构造时，首先会调用基类的构造函数，然后再调用派生类的构造函数。
   
2. **虚指针（vptr）的设置**：
   - 在调用基类构造函数时，对象的虚指针（vptr）指向基类的虚函数表。
   - 只有在派生类的构造函数开始执行时，对象的虚指针（vptr）才会被更新为指向派生类的虚函数表。

#### 析构函数

1. **析构对象的顺序**：
   - 当一个派生类对象被销毁时，首先会调用派生类的析构函数，然后再调用基类的析构函数。
   
2. **虚指针（vptr）的更新**：
   - 在派生类析构函数执行期间，对象的虚指针（vptr）指向派生类的虚函数表。
   - 只有在基类的析构函数开始执行时，对象的虚指针（vptr）才会被更新为指向基类的虚函数表。

#### 具体例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Base constructor\n";
        show(); // 调用 Base::show
    }
    virtual ~Base() {
        show(); // 调用 Base::show
        cout << "Base destructor\n";
    }
    virtual void show() {
        cout << "Base::show\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived constructor\n";
    }
    ~Derived() {
        cout << "Derived destructor\n";
    }
    void show() override {
        cout << "Derived::show\n";
    }
};

int main() {
    Derived d;
    return 0;
}
```

#### 分析

1. **构造过程**：
   - `Derived d;` 执行时，首先调用 `Base` 的构造函数。
   - 在 `Base` 的构造函数中，`show()` 被调用。
   - 此时，`Derived` 部分还未构造完成，对象的虚指针（vptr）仍然指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

2. **析构过程**：
   - `d` 离开作用域时，首先调用 `Derived` 的析构函数。
   - 在 `Derived` 的析构函数执行期间，对象的虚指针（vptr）指向 `Derived` 的虚函数表。
   - 因此，如果在 `Derived` 的析构函数中调用虚函数，将调用 `Derived` 的版本。
   - 接着调用 `Base` 的析构函数。
   - 在 `Base` 的析构函数中，`show()` 被调用。
   - 此时，`Derived` 部分已被销毁，对象的虚指针（vptr）已被更新为指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

#### 输出

```
Base constructor
Base::show
Derived constructor
Derived destructor
Base::show
Base destructor
```

#### 总结

- **构造函数中调用虚函数**：由于对象的虚指针（vptr）还未指向派生类的虚函数表，虚函数调用会绑定到当前类（基类）的版本。
- **析构函数中调用虚函数**：由于对象的虚指针（vptr）已被更新为指向当前类（基类）的虚函数表，虚函数调用会绑定到当前类（基类）的版本。

这样设计的目的是为了确保在对象构造和析构过程中，调用的函数是已知的、有效的，并且不会导致访问未初始化或已销毁的对象部分。

## 理解多态

如何解释多态?

静态(编译时期)的多态: 函数重载、模板(函数模板和类模板)

```c++
boo1compare(int,int){}
boo1compare(double,double){}

compare(10，20);call compare_int_int 在编译阶段就确定好调用的函数版本
compare(10.5，20.5);call compare_double_double 在编译阶段就确定好调用的函类
    
template<typename T>
bool compare(Ta Tb){}

compare<int>(10，20);=>int  实例化一个Compare<int>
compare(10.5，20.5);=>double 实例化一个compare<double>
```

动态（运行时候）多态：
Base Derive
在继承结构中，基类指针(引用)指向派生类对象，通过该指针(引用)调用同名覆盖方法(虚函基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态

pbase->show():

**多态底层是通过动态绑定来实现的** ，pbase-》访问谁的vfptr=》继续访问谁的vftable
								=》当然调用的是对应的派生类对象的方法了

![image-20240622231807139](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622231807139.png)

## 抽象类

类-》抽象一个实体的类型



![image-20240622232849101](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622232849101.png)

抽象类不能再实例化对象，但是可以定义指针和引用对象

好的，来解释一下抽象类，让初学者也能轻松理解。

### 什么是抽象类

抽象类是一种特殊的类，它不能被实例化，也就是说，你不能创建抽象类的对象。抽象类通常用作基类，目的是为派生类提供一个统一的接口或定义一些必须在派生类中实现的函数。

### 为什么需要抽象类

抽象类的主要目的是通过定义一组函数来规范派生类的行为。这在大型项目中尤为重要，因为它确保了所有派生类都具有某些共同的功能，即使这些功能的具体实现可能有所不同。

### 抽象类的定义

在C++中，抽象类有一个或多个纯虚函数。纯虚函数是指在基类中没有实现的函数，只定义了函数的接口，具体的实现留给派生类去完成。

### 纯虚函数的定义

纯虚函数的语法如下：

```cpp
virtual void functionName() = 0;
```

### 抽象类示例

下面是一个简单的例子来说明抽象类的定义和使用：

```cpp
#include <iostream>
using namespace std;

// 定义一个抽象类 Shape
class Shape {
public:
    // 纯虚函数，不需要在 Shape 类中实现
    virtual void draw() = 0;
    virtual double area() = 0;
};

// 定义一个派生类 Circle
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    // 实现抽象类中的纯虚函数
    void draw() override {
        cout << "Drawing a Circle" << endl;
    }

    double area() override {
        return 3.14 * radius * radius;
    }
};

// 定义另一个派生类 Rectangle
class Rectangle : public Shape {
private:
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    // 实现抽象类中的纯虚函数
    void draw() override {
        cout << "Drawing a Rectangle" << endl;
    }

    double area() override {
        return width * height;
    }
};

int main() {
    // 不能创建抽象类的实例
    // Shape s; // 这行会报错，因为 Shape 是抽象类

    // 创建派生类的实例
    Circle c(5);
    Rectangle r(4, 6);

    // 使用基类指针调用派生类的函数
    Shape* shapes[2];
    shapes[0] = &c;
    shapes[1] = &r;

    for (int i = 0; i < 2; ++i) {
        shapes[i]->draw();
        cout << "Area: " << shapes[i]->area() << endl;
    }

    return 0;
}
```

### 解释

1. **Shape类**：
    - `Shape`是一个抽象类，因为它有两个纯虚函数 `draw()` 和 `area()`。
    - 这些纯虚函数定义了一个接口，所有从 `Shape` 派生的类都必须实现这些函数。

2. **Circle类**和**Rectangle类**：
    - `Circle` 和 `Rectangle` 是从 `Shape` 派生出来的类，它们实现了 `Shape` 类中的纯虚函数 `draw()` 和 `area()`。
    - 这两个类提供了各自的实现：`Circle` 计算圆的面积，而 `Rectangle` 计算矩形的面积。

3. **main函数**：
    - 尝试直接创建 `Shape` 类的实例会导致编译错误，因为 `Shape` 是抽象类。
    - 你可以创建 `Circle` 和 `Rectangle` 的实例，然后使用基类 `Shape` 的指针来调用它们的函数。这展示了多态性：同一个基类指针可以调用不同派生类的实现。

### 总结

- **抽象类**：不能实例化，通常用作基类。
- **纯虚函数**：没有实现的函数，只定义接口，派生类必须实现。
- **多态性**：通过基类指针或引用调用派生类的实现。

抽象类和纯虚函数在设计模式中非常有用，它们帮助我们定义一组通用接口，同时允许不同的类提供各自的实现。

![image-20240624102542061](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624102542061.png)

如果没有虚继承的时候，有一个vfptr在里面，然后占用4字节

如果有虚继承在里面的话，那就多一个vbptr在里面，因为在一个vbtable里面了

那就变成8字节了（虚继承指的是virtual public A这个地方

![image-20240624102724327](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624102724327.png)

## 虚基类和虚继承

虚基类和虚继承是C++中为了解决多重继承中的**菱形继承问题**（又称**钻石继承问题**）而引入的概念。下面详细解释虚基类和虚继承，以及它们的作用和使用方法。

### 菱形继承问题

菱形继承问题发生在以下情况下：
- 一个类A被两个类B和C继承。
- 然后另一个类D同时继承B和C。

```
    A
   / \
  B   C
   \ /
    D
```

在这种结构中，D类通过B和C两次继承了A类，这会导致A类的成员在D类中出现两份，造成资源浪费和二义性问题。

### 虚继承

**虚继承**是一种特殊的继承方式，它确保在多重继承中基类只会有一个共享的实例，从而避免菱形继承问题。通过虚继承，派生类共享同一个基类实例。

### 虚基类

**虚基类**是通过虚继承实现的基类。派生类在继承基类时，使用`virtual`关键字来声明虚继承。

### 示例代码

下面是一个简单的示例，演示如何使用虚继承解决菱形继承问题。

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
    A() : value(0) {
        cout << "A constructed" << endl;
    }
    void show() {
        cout << "Value: " << value << endl;
    }
};

class B : virtual public A {
public:
    B() {
        cout << "B constructed" << endl;
    }
};

class C : virtual public A {
public:
    C() {
        cout << "C constructed" << endl;
    }
};

class D : public B, public C {
public:
    D() {
        cout << "D constructed" << endl;
    }
};

int main() {
    D d;
    d.value = 10;
    d.show(); // 访问虚基类A的成员

    return 0;
}
```

### 输出结果

```
A constructed
B constructed
A constructed
C constructed
D constructed
Value: 10
```

### 解释

1. **虚基类A**：
    - 在类B和C中，使用`virtual`关键字继承A，表示A是一个虚基类。
    - `class B : virtual public A` 和 `class C : virtual public A`。

2. **类D继承B和C**：
    - 由于B和C都是通过虚继承方式继承自A，所以D中只存在一个A的实例。
    - 在`main`函数中创建D的实例时，只调用了一次A的构造函数。

3. **访问虚基类成员**：
    - 可以直接通过D的对象访问A的成员，如`d.value`。

### 总结

- **虚继承**通过在继承时使用`virtual`关键字，确保派生类中只有一个基类实例，从而避免了菱形继承问题。
- **虚基类**是被虚继承的基类，通过虚继承机制共享其实例。
- 通过虚继承，可以解决多重继承中的资源浪费和二义性问题，使类的结构更加清晰和高效。

掌握虚继承和虚基类的概念和使用方法，有助于更好地设计和实现复杂的类层次结构，避免多重继承带来的潜在问题。





-------------------------------------------------------------------------------------------------------------------

区分一下多重继承和虚继承的区别

多重继承和虚继承是C++中用于设计类层次结构的两种不同方式。它们各有优缺点，适用于不同的场景。下面详细对比它们的区别及各自的优缺点。

#### 多重继承

**多重继承**允许一个类从多个基类继承。它使得类可以同时继承多个类的功能和接口。

##### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    void funcA() {
        cout << "Function A" << endl;
    }
};

class B {
public:
    void funcB() {
        cout << "Function B" << endl;
    }
};

class C : public A, public B {
};

int main() {
    C obj;
    obj.funcA();
    obj.funcB();
    return 0;
}
```

##### 优点

1. **灵活性**：可以同时继承多个类的接口和实现。
2. **代码重用**：能够复用多个基类的功能，减少代码重复。

##### 缺点

1. **复杂性**：类层次结构变得复杂，难以理解和维护。
2. **菱形继承问题**：在多重继承中，如果多个基类继承自同一个基类，会导致重复继承，带来二义性和资源浪费。

#### 虚继承

**虚继承**是一种特殊的多重继承方式，解决了菱形继承问题。它确保在多重继承中，基类只会有一个共享的实例。

##### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
    A() : value(0) {
        cout << "A constructed" << endl;
    }
    void show() {
        cout << "Value: " << value << endl;
    }
};

class B : virtual public A {
public:
    B() {
        cout << "B constructed" << endl;
    }
};

class C : virtual public A {
public:
    C() {
        cout << "C constructed" << endl;
    }
};

class D : public B, public C {
public:
    D() {
        cout << "D constructed" << endl;
    }
};

int main() {
    D d;
    d.value = 10;
    d.show();
    return 0;
}
```

##### 优点

1. **解决菱形继承问题**：确保基类在派生类中只有一个实例，避免重复继承带来的问题。
2. **明确的继承关系**：虚继承使得继承关系更加清晰，减少二义性。

##### 缺点

1. **性能开销**：虚继承需要维护虚基类表（vbptr），会带来额外的内存开销和性能损耗。
2. **复杂性增加**：虽然解决了菱形继承问题，但引入了虚基类表，增加了实现的复杂性。

#### 总结

##### 多重继承
- **优点**：
  - 高灵活性。
  - 代码重用。
- **缺点**：
  - 复杂性高。
  - 存在菱形继承问题。

##### 虚继承
- **优点**：
  - 解决菱形继承问题。
  - 继承关系更加明确。
- **缺点**：
  - 性能开销。
  - 实现复杂性增加。

##### 选择建议

- **使用多重继承**：当类层次结构简单，且不涉及菱形继承问题时，多重继承可以带来较高的灵活性和代码重用。
- **使用虚继承**：当涉及菱形继承问题时，应使用虚继承来确保基类实例唯一，避免二义性和资源浪费。

根据具体情况选择合适的继承方式，可以设计出更清晰、可维护和高效的类层次结构。



---------------------------------------------------------------------------------------------------------------

### 虚继承还有虚函数还有虚基类这些的地址问题



在C++中，虚继承、虚函数和虚基类涉及到一些底层的地址管理问题。理解这些机制如何管理地址有助于更好地理解C++的面向对象编程。以下是对这些概念的详细解释。

#### 虚继承和虚基类的地址问题

#### 虚继承

虚继承通过`virtual`关键字确保基类在多重继承中的实例只出现一次。这会影响对象的内存布局，需要通过虚基类指针（`vbptr`）来访问基类。

#### 内存布局

当使用虚继承时，编译器会在派生类对象中添加一个虚基类指针（`vbptr`）。`vbptr`指向虚基类表（`vbtable`），`vbtable`中记录了虚基类的偏移量。

#### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int a;
    A() : a(0) {}
};

class B : virtual public A {
public:
    int b;
    B() : b(0) {}
};

class C : virtual public A {
public:
    int c;
    C() : c(0) {}
};

class D : public B, public C {
public:
    int d;
    D() : d(0) {}
};

int main() {
    D obj;
    obj.a = 10;
    obj.b = 20;
    obj.c = 30;
    obj.d = 40;

    cout << "a: " << obj.a << endl;
    cout << "b: " << obj.b << endl;
    cout << "c: " << obj.c << endl;
    cout << "d: " << obj.d << endl;

    return 0;
}
```

#### 内存布局图示

```
+---------+------------------+
|  B::vbptr| --> [A offset]  |
+---------+------------------+
|    b    |                  |
+---------+------------------+
|  C::vbptr| --> [A offset]  |
+---------+------------------+
|    c    |                  |
+---------+------------------+
|    d    |                  |
+---------+------------------+
|    A    |                  |
+---------+------------------+
```

#### 地址访问

- `obj.a` 通过 `vbptr` 查找 `vbtable`，确定 `A` 的偏移量，然后访问 `A` 的成员 `a`。
- `obj.b`、`obj.c` 和 `obj.d` 直接按偏移量访问。

#### 虚函数的地址问题

#### 虚函数

虚函数使得在运行时能够通过基类指针或引用调用派生类的函数。虚函数表（`vtable`）和虚函数指针（`vptr`）实现了这一机制。

#### 内存布局

每个包含虚函数的类对象都有一个 `vptr`，指向 `vtable`。`vtable` 是一个函数指针数组，指向该类的虚函数。

#### 示例

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }
};

int main() {
    Derived obj;
    Base* pBase = &obj;
    pBase->show();  // 调用 Derived::show

    return 0;
}
```

#### 内存布局图示

```
+--------+---------------+
| vptr   | --> [vtable]  |
+--------+---------------+
| data   |               |
+--------+---------------+
```

#### 地址访问

- `pBase->show()` 通过 `vptr` 查找 `vtable`，找到 `Derived::show` 的地址并调用。

#### 总结

#### 虚基类和虚继承

- **虚基类指针（vbptr）**：用于定位虚基类在多重继承中的偏移量。
- **虚基类表（vbtable）**：记录了虚基类的偏移量。

#### 虚函数

- **虚函数指针（vptr）**：指向虚函数表。
- **虚函数表（vtable）**：存储虚函数的地址，实现动态绑定。

#### 内存布局影响

- **虚继承**：引入 `vbptr` 和 `vbtable`，确保虚基类只实例化一次。
- **虚函数**：引入 `vptr` 和 `vtable`，实现多态性和动态绑定。

通过虚继承和虚函数，C++ 提供了强大的面向对象特性，但也带来了额外的内存和性能开销。理解这些底层机制有助于更好地设计和优化 C++ 程序。



## 菱形继承的问题

![image-20240624130928614](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624130928614.png)

其实能够解决多重继承等等的问题，可以在一个基类的数据

就是在A这里使用虚函数，这样子可以虚继承，产生位偏移获取数据

## c++的四种转换类型

C++ 提供了多种类型转换方式，主要分为两大类：**C风格的类型转换**和**C++风格的类型转换**。C++风格的类型转换引入了一些新的运算符，以提供更严格和更安全的类型转换机制。以下是详细的介绍：

### C风格的类型转换

C风格的类型转换是从C语言继承过来的，语法如下：

```cpp
(type)expression
```

或

```cpp
type(expression)
```

这种转换方式简单直接，但缺乏类型检查，容易引发错误。

### C++风格的类型转换

C++引入了四种类型转换运算符，分别是：

1. **`static_cast`**
2. **`dynamic_cast`**
3. **`const_cast`**
4. **`reinterpret_cast`**

#### 1. `static_cast`

`static_cast` 用于**在编译时执行显式类型转换**，主要用于标准类型之间的转换、类层次结构中基类和派生类之间的转换（上行转换安全，下行转换需谨慎）。

提供编译器认为安全的类型转换，没有任何联系的类型之间的转换就会被否认

初始化的时候使用这个

```cpp
int main() {
    int a = 10;
    double b = static_cast<double>(a);  // int 转 double
    return 0;
}
```

#### 2. `dynamic_cast`

`dynamic_cast` 用于**在运行时执行类型转换**，主要用于类层次结构中基类和派生类之间的转换。它依赖于运行时类型识别（RTTI），可以确保下行转换的安全性。只能用于指针和引用。

主要用在继承结构中，支持RTTI类型识别的上下转换

制作api的时候尽可能使用这个

```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void derivedMethod() {}
};

int main() {
    Base* b = new Derived();
    Derived* d = dynamic_cast<Derived*>(b);  // 安全的下行转换
    if (d) {
        d->derivedMethod();
    }
    delete b;
    return 0;
}
```

#### 3. `const_cast`

`const_cast` 用于移除或添加对象的`const`或`volatile`属性。它是唯一能够移除`const`属性的类型转换运算符。

去掉常量属性的一个类型转换

去掉指针和引用的 时候进行使用

```cpp
void func(const int* p) {
    int* q = const_cast<int*>(p);
    *q = 20;
}

int main() {
    const int a = 10;
    func(&a);
    return 0;
}
```

#### 4. `reinterpret_cast`

`reinterpret_cast` 用于执行低级别的类型转换，例如指针类型之间的转换。它几乎不进行任何检查，仅仅是对比特模式的重新解释。

类C风格的强制转换

```cpp
int main() {
    int a = 10;
    void* p = &a;
    int* q = reinterpret_cast<int*>(p);  // void* 转 int*
    return 0;
}
```

### 总结

- **C风格的类型转换**：`(type)expression` 或 `type(expression)`，简单直接，但缺乏类型检查。
- **C++风格的类型转换**：
  - `static_cast`：用于编译时类型转换，适用于标准类型转换和安全的类层次结构转换。
  - `dynamic_cast`：用于运行时类型转换，适用于安全的类层次结构下行转换，依赖于RTTI。
  - `const_cast`：用于移除或添加`const`或`volatile`属性。
  - `reinterpret_cast`：用于低级别的类型转换，不进行任何检查。

这些类型转换方式各有其适用场景，选择合适的类型转换方式有助于编写安全、高效和可维护的代码。





# STL标准库

![image-20240624141032373](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624141032373.png)

![image-20240624141208888](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624141208888.png)

## vector容器

底层数据结构：动态开辟的数组，每次一原来的2倍进行扩容

`std::vector` 是 C++ 标准库中提供的一个动态数组容器，可以存储任意类型的元素。它提供了方便的接口来进行元素的添加、删除、访问和遍历操作。相比于普通数组，`std::vector` 的大小是动态可变的，可以根据需要自动扩展。

#### 基本使用

##### 包含头文件

使用 `std::vector` 需要包含头文件 `<vector>`：

```cpp
#include <vector>
```

##### 定义一个 vector

```cpp
#include <iostream>
#include <vector>

int main() {
    // 定义一个存储 int 类型元素的 vector
    std::vector<int> vec;

    return 0;
}
```

#### 常用操作

##### 添加元素

- `push_back()`: 在末尾添加元素。
- `emplace_back()`: 在末尾原地构造元素，比 `push_back()` 效率更高。

```cpp
int main() {
    std::vector<int> vec;

    vec.push_back(1);         // 在末尾添加 1
    vec.push_back(2);         // 在末尾添加 2
    vec.emplace_back(3);      // 在末尾原地构造 3

    for (int val : vec) {
        std::cout << val << " ";  // 输出: 1 2 3
    }

    return 0;
}
```

##### 访问元素

- `operator[]`: 通过下标访问元素，不进行边界检查。
- `at()`: 通过下标访问元素，进行边界检查。
- `front()`: 访问第一个元素。
- `back()`: 访问最后一个元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    std::cout << vec[0] << std::endl;  // 输出: 1
    std::cout << vec.at(1) << std::endl;  // 输出: 2
    std::cout << vec.front() << std::endl;  // 输出: 1
    std::cout << vec.back() << std::endl;  // 输出: 3

    return 0;
}
```

##### 修改元素

- 直接通过下标或迭代器修改元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    vec[0] = 10;  // 修改第一个元素为 10

    for (int val : vec) {
        std::cout << val << " ";  // 输出: 10 2 3
    }

    return 0;
}
```

##### 删除元素

- `pop_back()`: 删除最后一个元素。
- `erase()`: 删除指定位置的元素或一个范围内的元素。
- `clear()`: 删除所有元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3, 4};

    vec.pop_back();  // 删除最后一个元素

    vec.erase(vec.begin());  // 删除第一个元素

    vec.clear();  // 删除所有元素

    return 0;
}
```

PS：在进行连续的插入或者删除操作（insert/erase），一定要更新迭代器，否则第一次insert或者erase完成，迭代器失效了

![image-20240624142305782](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624142305782.png)

![image-20240624142355881](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624142355881.png)

解决失效问题就是做一次赋值

对值进行一个更新，就是类似于 it2 = vec.erase(its);这样子的操作

##### 大小和容量

- `size()`: 返回当前元素个数。
- `empty()`: 判断是否为空。
- `resize()`: 改变元素个数。
- `capacity()`: 返回当前容量。
- `reserve()`: 预留指定容量。只给容器底层开辟指定大小的内存空间，并不会添加新的元素

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    std::cout << "Size: " << vec.size() << std::endl;  // 输出: Size: 3
    std::cout << "Capacity: " << vec.capacity() << std::endl;  // 输出: Capacity: 3

    vec.reserve(10);  // 预留 10 个元素的空间

    std::cout << "Capacity after reserve: " << vec.capacity() << std::endl;  // 输出: Capacity after reserve: 10

    return 0;
}
```

##### 遍历

可以使用迭代器、范围 for 循环或者传统的 for 循环来遍历 `std::vector`。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    // 使用范围 for 循环
    for (int val : vec) {
        std::cout << val << " ";  // 输出: 1 2 3
    }
    std::cout << std::endl;

    // 使用迭代器
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";  // 输出: 1 2 3
    }
    std::cout << std::endl;

    // 使用传统的 for 循环
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";  // 输出: 1 2 3
    }

    return 0;
}
```

#### 总结

`std::vector` 是一个非常强大的动态数组容器，支持灵活的增删改查操作。通过合理使用 `std::vector`，可以大大简化数组管理的工作，提高代码的可读性和维护性。



----

## deque容器和list容器

扩容方式



![image-20240624150350200](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150350200.png)

![image-20240624150400538](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150400538.png)

![image-20240624150420112](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150420112.png)

扩容空间，旧的放在中间，方便进行添加和删除

![image-20240624150700313](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150700313.png)

对比vec的话时间效率快很多，如果经常需要进行首部尾部 添加那就deque

数量越多时间越久

![image-20240624150909426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150909426.png)

在C++标准库中，`deque`（双端队列）和`list`（双向链表）是两种常用的序列容器。它们各自有独特的特性和适用场景。

### `deque` 容器

`deque` 是一种双端队列，支持高效的头部和尾部插入和删除操作，同时也支持随机访问。它内部实现通常由多个连续的内存块组成，可以动态调整大小。

#### 特性

1. **双端插入和删除**：在头部和尾部进行插入和删除操作都非常高效，时间复杂度为O(1)。
2. **随机访问**：支持下标操作和随机访问，时间复杂度为O(1)。
3. **动态调整大小**：可以根据需要动态扩展或收缩。

#### 常用操作

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;

    // 在头部和尾部插入元素
    dq.push_back(1);
    dq.push_front(2);

    // 访问元素
    std::cout << dq[0] << std::endl; // 输出 2
    std::cout << dq[1] << std::endl; // 输出 1

    // 删除头部和尾部元素
    dq.pop_front();
    dq.pop_back();

    // 检查是否为空
    if (dq.empty()) {
        std::cout << "Deque is empty" << std::endl;
    }

    return 0;
}
```

### `list` 容器

`list` 是一种双向链表，支持高效的插入和删除操作，但不支持随机访问。适用于需要频繁在中间位置进行插入和删除操作的场景。

#### 特性

1. **双向链表**：每个节点包含指向前一个和后一个节点的指针。
2. **高效插入和删除**：在任意位置插入和删除操作时间复杂度为O(1)。
3. **不支持随机访问**：访问元素时需要遍历链表，时间复杂度为O(n)。

#### 常用操作

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst;

    // 在头部和尾部插入元素
    lst.push_back(1);
    lst.push_front(2);

    // 访问元素
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " "; // 输出 2 1
    }
    std::cout << std::endl;

    // 删除头部和尾部元素
    lst.pop_front();
    lst.pop_back();

    // 检查是否为空
    if (lst.empty()) {
        std::cout << "List is empty" << std::endl;
    }

    return 0;
}
```

### `deque` vs `list`

| 特性                    | `deque`                    | `list`                     |
| ----------------------- | -------------------------- | -------------------------- |
| 插入/删除（头部和尾部） | O(1)                       | O(1)                       |
| 插入/删除（中间）       | O(n)                       | O(1)                       |
| 随机访问                | O(1)                       | O(n)                       |
| 内存连续性              | 部分连续                   | 不连续                     |
| 适用场景                | 需要快速头尾插入和随机访问 | 需要快速任意位置插入和删除 |

#### 选择使用

- **`deque`**：适合需要在头部和尾部频繁插入和删除，同时需要高效随机访问的场景。
- **`list`**：适合需要在任意位置频繁插入和删除，但不需要随机访问的场景。

#### 示例代码

##### 使用 `deque` 实现双端队列操作

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;

    dq.push_back(1); // 末尾插入
    dq.push_front(2); // 头部插入

    dq.insert(dq.begin() + 1, 3); // 中间插入
    dq.erase(dq.begin() + 1); // 中间删除

    for (int val : dq) {
        std::cout << val << " "; // 输出 2 1
    }
    std::cout << std::endl;

    return 0;
}
```

##### 使用 `list` 实现链表操作

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst;

    lst.push_back(1); // 末尾插入
    lst.push_front(2); // 头部插入

    auto it = lst.begin();
    ++it;
    lst.insert(it, 3); // 中间插入
    lst.erase(--it); // 中间删除

    for (int val : lst) {
        std::cout << val << " "; // 输出 3 1
    }
    std::cout << std::endl;

    return 0;
}
```

#### 总结

- **`deque`** 是双端队列，适合需要快速头尾插入删除和随机访问的场景。
- **`list`** 是双向链表，适合需要频繁中间插入和删除，但不需要随机访问的场景。

通过合理选择容器，可以提高程序的效率和可读性。

![image-20240624151431951](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624151431951.png)

## Vector和deque和list 的区别

在 C++ 标准库中，`vector`、`deque` 和 `list` 是三种常用的序列容器。它们各自有不同的实现方式和适用场景。以下从多个角度详细说明它们的区别：





### 底层数据结构

- **`vector`**：动态数组，内存连续。
- **`deque`**：双端队列，由多个连续内存块组成。
- **`list`**：双向链表，内存不连续，每个节点包含数据和指向前后节点的指针。

### 插入和删除元素的复杂度

- **`vector`**：
  - 头部插入/删除：O(n)
  - 尾部插入/删除：O(1)（摊销）
  - 中间插入/删除：O(n)

- **`deque`**：
  - 头部插入/删除：O(1)
  
  - 尾部插入/删除：O(1)

  - 中间插入/删除：O(n)
  
    ![image-20240624154056014](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624154056014.png)
  
- **`list`**：
  - 头部插入/删除：O(1)
  - 尾部插入/删除：O(1)
  - 中间插入/删除：O(1)

### 内存使用效率

- **`vector`**：
  - 内存是连续分配的，空间利用率高。
  - 可能会因为扩容而导致多次重新分配和拷贝操作，造成一定的内存浪费。
  
- **`deque`**：
  - 内存是分段分配的，头部和尾部有额外的管理开销。
  - 内存利用率较高，但比 `vector` 略低。
  
- **`list`**：
  - 每个元素都需要额外存储两个指针，内存开销较大。
  - 内存利用率较低，容易造成内存碎片化。

### 访问元素的复杂度

- **`vector`**：
  - 随机访问：O(1)
  - 顺序访问：O(1)

- **`deque`**：
  - 随机访问：O(1)
  - 顺序访问：O(1)

- **`list`**：
  - 随机访问：O(n)
  - 顺序访问：O(1)

### 中间插入和删除效率

- **`vector`**：
  - 中间插入/删除操作需要移动大量元素，效率较低。
  - 时间复杂度为 O(n)。

- **`deque`**：
  - 中间插入/删除操作需要在内存块之间移动元素，效率较低。
  - 时间复杂度为 O(n)。

- **`list`**：
  - 中间插入/删除操作只需修改相邻节点的指针，效率高。
  - 时间复杂度为 O(1)。

### 迭代器的有效性

- **`vector`**：
  - 插入和删除操作可能会使迭代器失效，尤其是扩容时。
  
- **`deque`**：
  - 插入和删除操作也可能会使迭代器失效，但不如 `vector` 严重。
  
- **`list`**：
  - 插入和删除操作不会使迭代器失效（除非是被删除的元素的迭代器）。

### 应用场景

- **`vector`**：
  - 适用于需要频繁随机访问和顺序访问的场景。
  - 不适合频繁在中间插入和删除的场景。

- **`deque`**：
  - 适用于需要频繁在头部和尾部插入和删除的场景。
  - 在中间插入和删除的场景下表现不佳。

- **`list`**：
  - 适用于需要频繁在任意位置插入和删除的场景。
  - 不适合需要随机访问的场景。

### 示例代码

#### `vector` 示例

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.push_back(4); // O(1)

    vec.insert(vec.begin() + 1, 5); // O(n)

    for (const auto& val : vec) {
        std::cout << val << " "; // 输出: 1 5 2 3 4
    }
    std::cout << std::endl;

    vec.erase(vec.begin() + 1); // O(n)

    for (const auto& val : vec) {
        std::cout << val << " "; // 输出: 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

#### `deque` 示例

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq = {1, 2, 3};
    dq.push_back(4); // O(1)
    dq.push_front(0); // O(1)

    dq.insert(dq.begin() + 2, 5); // O(n)

    for (const auto& val : dq) {
        std::cout << val << " "; // 输出: 0 1 5 2 3 4
    }
    std::cout << std::endl;

    dq.erase(dq.begin() + 2); // O(n)

    for (const auto& val : dq) {
        std::cout << val << " "; // 输出: 0 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

#### `list` 示例

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3};
    lst.push_back(4); // O(1)
    lst.push_front(0); // O(1)

    auto it = lst.begin();
    std::advance(it, 2);
    lst.insert(it, 5); // O(1)

    for (const auto& val : lst) {
        std::cout << val << " "; // 输出: 0 1 5 2 3 4
    }
    std::cout << std::endl;

    it = lst.begin();
    std::advance(it, 2);
    lst.erase(it); // O(1)

    for (const auto& val : lst) {
        std::cout << val << " "; // 输出: 0 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### 总结

- **`vector`** 适用于需要频繁随机访问和顺序访问的场景，但在中间插入和删除时性能较差。
- **`deque`** 适用于需要频繁在头部和尾部插入和删除的场景，支持随机访问，但中间插入和删除的性能不如 `list`。
- **`list`** 适用于需要频繁在任意位置插入和删除的场景，不支持随机访问，但插入和删除操作不会使迭代器失效。

## 详细介绍容器适配器

容器适配器是 C++ 标准库的一部分，它们通过对现有的容器进行封装，提供了特定的功能和接口。标准库中有三种主要的容器适配器：`stack`、`queue` 和 `priority_queue`。这些适配器对底层容器进行包装，使其具有特定的数据访问模式。以下是对这三种容器适配器的详细介绍。

### `stack` 容器适配器

`stack` 是一种后进先出（LIFO，Last In First Out）的数据结构。它仅允许在栈顶进行插入和删除操作。

#### 底层容器
- 默认使用 `deque` 作为底层容器。
- 也可以使用 `vector` 或 `list` 作为底层容器。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 压入栈顶。
- `pop()`: 移除栈顶元素。
- `top()`: 返回栈顶元素的引用。
- `empty()`: 检查栈是否为空。
- `size()`: 返回栈中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;
    s.push(1);
    s.push(2);
    s.push(3);

    while (!s.empty()) {
        std::cout << s.top() << " "; // 输出: 3 2 1
        s.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### `queue` 容器适配器

`queue` 是一种先进先出（FIFO，First In First Out）的数据结构。它允许在队尾插入元素，在队头移除元素。

#### 底层容器
- 默认使用 `deque` 作为底层容器。
- 也可以使用 `list` 作为底层容器。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 插入队尾。
- `pop()`: 移除队头元素。
- `front()`: 返回队头元素的引用。
- `back()`: 返回队尾元素的引用。
- `empty()`: 检查队列是否为空。
- `size()`: 返回队列中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) {
        std::cout << q.front() << " "; // 输出: 1 2 3
        q.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### `priority_queue` 容器适配器

`priority_queue` 是一种基于堆实现的优先队列。默认情况下，它是一个大顶堆(大根堆)，堆顶元素是优先级最高的元素。

#### 底层容器
- 默认使用 `vector` 作为底层容器，并通过 `make_heap`、`push_heap` 和 `pop_heap` 算法来维护堆结构。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 插入优先队列。
- `pop()`: 移除堆顶元素。
- `top()`: 返回堆顶元素的引用。
- `empty()`: 检查优先队列是否为空。
- `size()`: 返回优先队列中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    std::priority_queue<int> pq;
    pq.push(3);
    pq.push(1);
    pq.push(4);
    pq.push(1);
    pq.push(5);
    pq.push(9);
    
    while (!pq.empty()) {
        std::cout << pq.top() << " "; // 输出: 9 5 4 3 1 1
        pq.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### 适配器的特点和用途

#### `stack`
- **特点**：
  - 后进先出（LIFO）的操作顺序。
  - 只允许在栈顶进行插入和删除操作。
- **用途**：
  - 适用于需要逆序处理的场景，如深度优先搜索、递归模拟等。

#### `queue`
- **特点**：
  - 先进先出（FIFO）的操作顺序。
  - 允许在队尾插入元素，在队头移除元素。
- **用途**：
  - 适用于按顺序处理元素的场景，如广度优先搜索、任务调度等。

#### `priority_queue`
- **特点**：
  - 基于堆的数据结构。
  - 默认是大顶堆，可通过指定比较函数实现小顶堆。
  - 允许按优先级处理元素。
- **用途**：
  - 适用于需要按优先级处理元素的场景，如任务调度、最短路径算法等。

### 适配器的底层容器选择

- **`stack`**：
  - 默认使用 `deque`，也可以使用 `vector` 或 `list`。
  - 使用 `deque` 和 `list` 时，头部和尾部的操作性能较好。
  - 使用 `vector` 时，尾部操作性能较好，但扩容可能影响性能。
  
- **`queue`**：
  - 默认使用 `deque`，也可以使用 `list`。
  - 使用 `deque` 和 `list` 时，头部和尾部的操作性能较好。
  
- **`priority_queue`**：
  - 默认使用 `vector`，并通过堆算法维护堆结构。
  - 使用 `vector` 时，性能较好，因为堆操作的时间复杂度为 O(log n)。

### 总结

容器适配器通过封装底层容器，提供了特定的数据访问模式，使得编写代码更加方便和直观。了解每种适配器的特点和用途，可以更好地选择适合的容器来解决特定的问题。

**PS : ** ![image-20240624160456998](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624160456998.png)









------

![image-20240624160718086](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624160718086.png)

## 关联容器

C++ 标准库中的关联容器（Associative Containers）用于高效地存储和检索元素。它们根据键值对元素进行排序和管理，并提供对元素的快速查找、插入和删除操作。C++ 标准库中提供了四种主要的关联容器：`set`、`multiset`、`map` 和 `multimap`。

### `set` 容器

`set` 是一个存储唯一元素的容器，元素按特定顺序（默认按键值升序）排列。

#### 特点
- 元素唯一：每个元素只能出现一次。
- 元素自动排序：元素按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数（对于 `set`，结果是 0 或 1）。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;
    s.insert(3);
    s.insert(1);
    s.insert(4);
    s.insert(1); // 重复元素，不会插入

    for (int x : s) {
        std::cout << x << " "; // 输出: 1 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### `multiset` 容器

`multiset` 是一个允许存储重复元素的容器，元素按特定顺序排列。

#### 特点
- 元素可重复：同一个元素可以出现多次。
- 元素自动排序：元素按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> ms;
    ms.insert(3);
    ms.insert(1);
    ms.insert(4);
    ms.insert(1); // 允许重复元素

    for (int x : ms) {
        std::cout << x << " "; // 输出: 1 1 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### `map` 容器

`map` 是一个存储键值对（key-value pair）的关联容器，键值唯一且按特定顺序排列。

#### 特点
- 键唯一：每个键只能出现一次。
- 键自动排序：键按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `operator[](const Key& key)`: 访问或插入键值对。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> m;
    m[1] = "one";
    m[2] = "two";
    m[3] = "three";

    for (const auto& p : m) {
        std::cout << p.first << ": " << p.second << std::endl;
    }

    return 0;
}
```

### `multimap` 容器

`multimap` 是一个允许存储重复键的关联容器，键值对按键的特定顺序排列。

#### 特点
- 键可重复：同一个键可以出现多次。
- 键自动排序：键按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `count(const Key& key)`: 返回键 `key` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> mm;
    mm.insert({1, "one"});
    mm.insert({2, "two"});
    mm.insert({1, "uno"});

    for (const auto& p : mm) {
        std::cout << p.first << ": " << p.second << std::endl;
    }

    return 0;
}
```

### 关联容器的特点和性能

#### 底层数据结构
- 所有关联容器（`set`、`multiset`、`map`、`multimap`）都基于红黑树实现，这是一种自平衡二叉搜索树。

#### 时间复杂度
- **查找、插入、删除操作**：平均时间复杂度为 O(log n)。

#### 内存使用
- 关联容器需要额外的内存来维护树结构，因此在内存使用上可能比序列容器（如 `vector` 和 `deque`）更高。

#### 迭代器
- 关联容器的迭代器是双向迭代器，可以前向和后向遍历元素。
- 迭代器在插入和删除操作后仍然有效，但可能不再指向原来的元素。

### 关联容器的选择

- **`set`**：用于需要唯一元素集合的场景，支持高效的元素查找和删除操作。
- **`multiset`**：用于需要存储重复元素集合的场景，支持高效的元素查找和删除操作。
- **`map`**：用于需要键值对映射的场景，键唯一且按顺序排列。
- **`multimap`**：用于需要存储重复键的键值对映射的场景，键按顺序排列。

### 总结

关联容器在需要高效查找、插入和删除操作的场景中非常有用。它们通过红黑树结构提供了稳定的 O(log n) 时间复杂度，同时保持元素的有序性。选择合适的关联容器可以帮助简化代码逻辑，提高程序性能。





## 无序关联容器详解

无序关联容器是 C++11 引入的容器，它们提供了一种基于哈希表的数据结构，以常数时间复杂度 O(1) 进行查找、插入和删除操作。标准库中的无序关联容器包括 `unordered_set`、`unordered_multiset`、`unordered_map` 和 `unordered_multimap`。这些容器提供了一种高效的方式来处理大量数据，并且与有序关联容器不同，它们不会维护元素的有序性。

### `unordered_set` 容器

`unordered_set` 是一个存储唯一元素的容器，使用哈希表实现，元素无序。

#### 特点
- 元素唯一：每个元素只能出现一次。
- 元素无序：不保证元素的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数（对于 `unordered_set`，结果是 0 或 1）。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> uset;
    uset.insert(3);
    uset.insert(1);
    uset.insert(4);
    uset.insert(1); // 重复元素，不会插入

    for (int x : uset) {
        std::cout << x << " "; // 输出顺序不确定
    }
    std::cout << std::endl;

    return 0;
}
```

### `unordered_multiset` 容器

`unordered_multiset` 是一个允许存储重复元素的容器，使用哈希表实现，元素无序。

#### 特点
- 元素可重复：同一个元素可以出现多次。
- 元素无序：不保证元素的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_multiset<int> umset;
    umset.insert(3);
    umset.insert(1);
    umset.insert(4);
    umset.insert(1); // 允许重复元素

    for (int x : umset) {
        std::cout << x << " "; // 输出顺序不确定
    }
    std::cout << std::endl;

    return 0;
}
```

### `unordered_map` 容器

`unordered_map` 是一个存储键值对（key-value pair）的容器，键值唯一且无序。

#### 特点
- 键唯一：每个键只能出现一次。
- 键值对无序：不保证键值对的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `operator[](const Key& key)`: 访问或插入键值对。具有查询功能，如果key不在，则会插入一对数据![image-20240624162305391](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624162305391.png)
- `size()`: 返回容器中元素的数量。

##### 一些操作

###### 怎么使用 `p.first` 和 `p.second`？

- **获取键和值**：`p.first` 可以用来获取 `unordered_map` 中的键，`p.second` 则可以获取与该键相关联的值。
- **条件判断**：在上述示例中，通过检查 `p.second` 是否大于1，可以找出在原始数组中出现多次的键。
- **修改值**：如果需要修改 `unordered_map` 中的值，可以直接通过 `p.second` 进行修改，例如增加计数或执行其他操作。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> umap;
    umap[1] = "one";
    umap[2] = "two";
    umap[3] = "three";

    for (const auto& p : umap) {
        std::cout << p.first << ": " << p.second << std::endl; // 输出顺序不确定
    }

    return 0;
}
```

#### 示例代码2

```c++
#include <unordered_map>
int main(){
  const int ARR_LEN = 10000;
  int arr[ARR_LEN] = { 0 };
  for (int i = 0; i < ARR_LEN; ++i) {
    arr[i] = rand() % 20 +1 ;
  }
  unordered_map<int,int> map1;
  for (int k : arr) {
    auto it = map1.find(k);
    if (it == map1.end()){
      map1.insert({k,1});
    }
    else{
      it->second++;
    }
  }
  for (pair<int,int> p : map1)
  {
    if(p.second > 1)
    {
      cout << "key: " << p.first << " count : " << p.second << endl;
    }
  }
  cout << endl;
cout <<"--------------"<< endl;
  auto it = map1.begin();
  for (; it != map1.end() ; ++it) {
    if(it->second > 1)
    {
      cout << "key: " << it->first << " count : " << it->second << endl;
    }
  }
}
```



### `unordered_multimap` 容器

`unordered_multimap` 是一个允许存储重复键的关联容器，键值对无序。

#### 特点
- 键可重复：同一个键可以出现多次。
- 键值对无序：不保证键值对的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `count(const Key& key)`: 返回键 `key` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_multimap<int, std::string> ummap;
    ummap.insert({1, "one"});
    ummap.insert({2, "two"});
    ummap.insert({1, "uno"});

    for (const auto& p : ummap) {
        std::cout << p.first << ": " << p.second << std::endl; // 输出顺序不确定
    }

    return 0;
}
```

### 无序关联容器的特点和性能

#### 底层数据结构
- 所有无序关联容器（`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`）都基于哈希表实现。

#### 时间复杂度
- **查找、插入、删除操作**：平均时间复杂度为 O(1)，最坏情况下为 O(n)，当发生哈希冲突时性能可能降低。

#### 内存使用
- 无序关联容器需要额外的内存来存储哈希表结构和处理哈希冲突，因此在内存使用上可能比有序关联容器更高。

#### 迭代器
- 无序关联容器的迭代器是双向迭代器。
- 迭代器在插入和删除操作后仍然有效，但可能不再指向原来的元素。

### 无序关联容器的选择

- **`unordered_set`**：用于需要唯一元素集合的场景，支持高效的元素查找和删除操作，但不要求有序。
- **`unordered_multiset`**：用于需要存储重复元素集合的场景，支持高效的元素查找和删除操作，但不要求有序。
- **`unordered_map`**：用于需要键值对映射的场景，键唯一且无序，支持高效的查找和删除操作。
- **`unordered_multimap`**：用于需要存储重复键的键值对映射的场景，键无序，支持高效的查找和删除操作。

### 总结

无序关联容器在需要高效查找、插入和删除操作的场景中非常有用，尤其是在不要求元素有序的情况下。它们通过哈希表结构提供了常数时间复杂度的操作，可以显著提高程序性能。选择合适的无序关联容器可以帮助简化代码逻辑，提高程序效率。



## 有序关联容器

![image-20240625004529144](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625004529144.png)

有序关联容器（Ordered Associative Containers）是 C++ 标准模板库（STL）中的一类容器，用于在内存中存储键值对，并根据键的顺序自动排序和高效检索。主要的有序关联容器包括：

1. `std::map`
2. `std::multimap`
3. `std::set`
4. `std::multiset`

### 1. `std::map`

`std::map` 是一种键值对的有序关联容器，具有以下特点：

- **唯一键**：每个键在 `map` 中必须是唯一的。
- **自动排序**：键值对会根据键自动排序（默认使用 `<` 运算符）。
- **快速查找**：查找、插入、删除操作的时间复杂度为 O(log n)。

**示例代码**：

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";

    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 2. `std::multimap`

`std::multimap` 与 `std::map` 类似，但允许相同的键有多个值。即，一个键可以对应多个值。

**示例代码**：

```cpp
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> myMultimap;
    myMultimap.insert({1, "one"});
    myMultimap.insert({2, "two"});
    myMultimap.insert({2, "deux"});
    myMultimap.insert({3, "three"});

    for (const auto& pair : myMultimap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 3. `std::set`

`std::set` 是一种只包含键的有序关联容器，具有以下特点：

- **唯一键**：每个键在 `set` 中必须是唯一的。
- **自动排序**：键会根据 `<` 运算符自动排序。
- **快速查找**：查找、插入、删除操作的时间复杂度为 O(log n)。

**示例代码**：

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet;
    mySet.insert(1);
    mySet.insert(2);
    mySet.insert(3);

    for (int elem : mySet) {
        std::cout << elem << std::endl;
    }

    return 0;
}
```



**PS：**为了更好地理解 `<` 运算符的重载作用，我们需要详细解释一下运算符重载的机制以及在 `std::set` 中具体发挥作用的地方。

#### 运算符重载的概念

运算符重载允许你定义或重新定义某些运算符的行为，以便它们可以与用户自定义的类一起使用。例如，通过重载 `<` 运算符，你可以定义两个 `Student` 对象如何进行比较。

#### 重载 `<` 运算符的代码

以下是 `Student` 类中重载 `<` 运算符的代码：

```cpp
bool operator<(const Student &stu) const {
    return _id < stu._id;
}
```

这个函数的作用是：当我们使用 `<` 运算符比较两个 `Student` 对象时，实际上是比较它们的 `_id` 值。

#### `std::set` 使用 `<` 运算符的地方

`std::set` 是一个有序集合，其内部使用红黑树（或其他平衡二叉树）来存储元素。为了保持元素有序，`std::set` 需要知道如何比较两个元素。这正是 `<` 运算符重载发挥作用的地方。

#### 具体示例

以下是一个使用 `std::set` 的完整示例，详细解释重载 `<` 运算符如何发挥作用：

```cpp
#include <iostream>
#include <set>
#include <string>

class Student {
public:
    Student(int id, std::string name) : _id(id), _name(name) {}

    // 重载 < 运算符
    bool operator<(const Student &stu) const {
        return _id < stu._id;
    }

    // 打印学生信息
    void print() const {
        std::cout << "ID: " << _id << ", Name: " << _name << std::endl;
    }

private:
    int _id;
    std::string _name;
};

int main() {
    // 创建 std::set 容器
    std::set<Student> studentSet;
    
    // 插入 Student 对象
    studentSet.insert(Student(3, "Alice"));
    studentSet.insert(Student(1, "Bob"));
    studentSet.insert(Student(2, "Charlie"));

    // 输出 Student 对象，按 id 排序
    for (const auto &student : studentSet) {
        student.print();
    }

    return 0;
}
```

#### 输出结果

```plaintext
ID: 1, Name: Bob
ID: 2, Name: Charlie
ID: 3, Name: Alice
```

#### 解释

1. **插入顺序**：我们按任意顺序插入 `Student` 对象到 `std::set` 中。
2. **排序顺序**：`std::set` 使用 `<` 运算符来比较 `Student` 对象，并自动对其进行排序。

在 `std::set` 中插入元素时，它会根据 `<` 运算符确定元素之间的相对顺序。例如，当插入 `Student(3, "Alice")` 时：

- `std::set` 首先比较 `3` 和已存在的元素（如果有的话）的 `_id` 值。
- 如果 `3` 小于某个已存在元素的 `_id`，则 `Alice` 将插入到该元素之前。
- 如果 `3` 大于某个已存在元素的 `_id`，则 `Alice` 将插入到该元素之后。

同理，当插入 `Student(1, "Bob")` 和 `Student(2, "Charlie")` 时，`std::set` 通过 `<` 运算符进行比较并确定它们在集合中的位置。

#### 运算符重载的具体作用

- **比较**：每当 `std::set` 需要比较两个 `Student` 对象时，它都会调用重载的 `<` 运算符。例如，在插入新元素、查找元素或删除元素时，`std::set` 都会使用 `<` 运算符来确定元素的顺序。
- **排序**：通过 `<` 运算符的比较结果，`std::set` 可以确保所有元素按 `_id` 值排序。

#### 总结

重载 `<` 运算符的关键作用在于定义了对象之间的比较规则，使 `std::set` 可以使用这个规则来维护元素的顺序。这种机制使得 `std::set` 在插入、删除和查找元素时能够高效地保持元素的有序性。

### 4. `std::multiset`

`std::multiset` 与 `std::set` 类似，但允许相同的键出现多次。

**示例代码**：

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> myMultiset;
    myMultiset.insert(1);
    myMultiset.insert(2);
    myMultiset.insert(2);
    myMultiset.insert(3);

    for (int elem : myMultiset) {
        std::cout << elem << std::endl;
    }

    return 0;
}
```

### 底层实现

有序关联容器通常使用红黑树（Red-Black Tree）来实现。这种自平衡二叉搜索树使得查找、插入、删除操作的时间复杂度保持在 O(log n)。

### 常用操作

- **插入**：`insert` 方法用于插入元素。对于 `std::map` 和 `std::set`，插入一个已经存在的键不会改变容器内容。
- **删除**：`erase` 方法用于删除指定键或迭代器位置的元素。
- **查找**：`find` 方法返回一个指向指定键的迭代器，如果未找到则返回 `end`。
- **迭代**：有序关联容器支持双向迭代器，可以使用范围 `for` 循环或标准算法进行遍历。

### 优缺点对比

#### 优点

- **自动排序**：元素按键值自动排序，适合需要按序访问元素的场景。
- **高效查找**：使用红黑树实现，查找、插入、删除操作时间复杂度为 O(log n)。
- **稳定性**：标准库实现，广泛使用，具有较好的兼容性和稳定性。

#### 缺点

- **较高的内存开销**：相比于无序关联容器（如 `unordered_map`），红黑树需要额外的内存来维护树的结构。
- **插入删除效率较低**：由于需要保持平衡和排序，插入和删除操作比无序关联容器稍慢。

### 总结

有序关联容器在需要自动排序和高效查找的场景中非常有用。理解它们的底层实现和操作特性，可以帮助我们在编程中选择最合适的容器来解决问题。



## 迭代器iterator

迭代器（Iterator）是C++标准模板库（STL）中的一个重要概念，用于遍历容器（如vector、deque、list、set、map等）中的元素。迭代器提供了一种抽象方式来访问容器中的元素，而不需要了解容器的底层实现细节。它们类似于指针，但具有更高层次的抽象性和更广泛的应用范围。

### 迭代器的种类

迭代器根据其功能和操作特性分为五种主要类型：

1. **输入迭代器（Input Iterator）**：
   - 只能读取元素，不允许修改。
   - 只能单向移动，支持 `++` 操作。
   - 用于一次性读取操作，如读取文件。

2. **输出迭代器（Output Iterator）**：
   - 只能写入元素，不允许读取。
   - 只能单向移动，支持 `++` 操作。
   - 用于一次性写入操作，如写入文件。

3. **前向迭代器（Forward Iterator）**：
   - 既可以读取也可以写入元素。
   - 只能单向移动，支持 `++` 操作。
   - 可多次遍历同一容器。

4. **双向迭代器（Bidirectional Iterator）**：
   - 既可以读取也可以写入元素。
   - 支持双向移动，支持 `++` 和 `--` 操作。
   - 用于list、set、map等容器。

5. **随机访问迭代器（Random Access Iterator）**：
   - 既可以读取也可以写入元素。
   - 支持双向移动，支持 `++`、`--`、`+`、`-` 操作，支持随机访问 `[]` 操作。
   - 用于vector、deque等容器。

### 迭代器的基本操作

以下是一些常见的迭代器操作：

1. **初始化和赋值**：
   ```cpp
   std::vector<int> vec = {1, 2, 3, 4, 5};
   std::vector<int>::iterator it = vec.begin(); // 初始化迭代器指向容器的开始
   ```

2. **访问元素**：
   ```cpp
   int value = *it; // 通过解引用访问元素
   ```

3. **迭代遍历**：
   ```cpp
   for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
       std::cout << *it << std::endl; // 输出每个元素的值
   }
   ```

4. **修改元素**：
   ```cpp
   *it = 10; // 修改迭代器指向的元素的值
   ```

5. **移动迭代器**：
   ```cpp
   ++it; // 将迭代器移动到下一个元素
   --it; // 将迭代器移动到前一个元素（适用于双向迭代器）
   ```

6. **随机访问**（仅适用于随机访问迭代器）：
   ```cpp
   it += 2; // 将迭代器向前移动两个位置
   it = vec.begin() + 3; // 将迭代器指向第四个元素
   int val = it[1]; // 访问迭代器当前位置之后的第一个元素
   ```

### 迭代器的使用示例

以下是一个使用迭代器遍历和修改`std::vector`中元素的示例：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 遍历并输出元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // 修改元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        *it = *it * 2; // 将每个元素的值乘以2
    }

    // 再次遍历并输出修改后的元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 迭代器失效

在某些操作下，迭代器可能会失效，这意味着它们指向的元素可能已经被删除或移动。常见的导致迭代器失效的操作包括：

1. **容器的修改**：例如在`vector`中插入或删除元素，可能导致所有指向该容器的迭代器失效。
2. **容器的重新分配**：当`vector`扩容时，所有指向该`vector`的迭代器都会失效。

为了避免迭代器失效的问题，必须小心处理迭代器在容器修改操作中的使用。

### 总结

迭代器是C++中用于访问和操作容器中元素的强大工具，通过迭代器可以遍历、访问、修改容器中的元素，同时保持对容器实现细节的抽象。了解和正确使用迭代器对于高效地操作STL容器至关重要。





## 特殊化迭代器

你提到的常量迭代器（const_iterator）等也是迭代器的一种，它们是上面介绍的五种迭代器类型中的特化版本，用于特定的用途和约束。这里我将补充和详细介绍常见的迭代器类型，包括常量迭代器和反向迭代器。

### 常量迭代器（const_iterator）

常量迭代器是不能用于修改所指向的元素的迭代器。使用常量迭代器可以确保代码的安全性，防止对容器中的元素进行不必要的修改。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用常量迭代器遍历元素
    for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`cbegin()` 和 `cend()` 返回的是常量迭代器，使用这些迭代器只能读取元素，而不能修改它们。

### 反向迭代器（reverse_iterator）

反向迭代器用于从后向前遍历容器。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用反向迭代器遍历元素
    for (std::vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`rbegin()` 和 `rend()` 返回的是反向迭代器，用于从末尾到开头遍历容器。

### 常量反向迭代器（const_reverse_iterator）

常量反向迭代器是反向迭代器的常量版本，用于从后向前遍历容器，同时保证元素不可修改。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用常量反向迭代器遍历元素
    for (std::vector<int>::const_reverse_iterator it = vec.crbegin(); it != vec.crend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`crbegin()` 和 `crend()` 返回的是常量反向迭代器，用于从末尾到开头遍历容器，但不能修改元素。

### 迭代器总结

迭代器是C++中用于遍历和操作容器的强大工具，它们包括但不限于以下几种常见类型：

- **普通迭代器（iterator）**：用于读写容器中的元素。
- **常量迭代器（const_iterator）**：用于只读容器中的元素，不能修改。
- **反向迭代器（reverse_iterator）**：用于从后向前遍历容器。
- **常量反向迭代器（const_reverse_iterator）**：用于从后向前只读遍历容器，不能修改。

这些迭代器提供了灵活性和安全性，使得对容器的遍历和操作更加方便和安全。了解和正确使用这些迭代器类型对于高效地操作STL容器至关重要。

### 迭代器的应用示例

以下是一个综合应用迭代器的示例，展示如何使用普通迭代器、常量迭代器和反向迭代器：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用普通迭代器遍历和修改元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2; // 将每个元素乘以2
    }

    // 使用常量迭代器遍历元素
    for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " "; // 输出每个元素
    }
    std::cout << std::endl;

    // 使用反向迭代器遍历元素
    for (std::vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " "; // 输出每个元素
    }
    std::cout << std::endl;

    return 0;
}
```



## 函数对象





![image-20240625090631102](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625090631102.png)

![image-20240625090705460](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625090705460.png)

通过函数指针调用函数，是没办法内联的，效率很低，因为函数调用有开销

所以我们使用函数对象

![image-20240625090834343](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625090834343.png)

1. 通过函数对象调用operator()，可以省略函数的调用开销，比通过函数指针调用函数（不能够inline内联调用）效率高
2. 因为函数对象是用类生成的，所以可以添加相关的成员变量，用来记录函数对象![image-20240625091216922](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625091216922.png)

### 函数对象（Function Object）

**函数对象**是一个可以像函数一样调用的对象。通常通过重载 `operator()` 运算符来实现。它与普通的函数相比有以下不同点：

1. **状态保存：**
   - 函数对象可以有自己的状态（成员变量），而普通函数没有这种能力。例如，函数对象可以在调用之间保存某些信息。
2. **灵活性：**
   - 函数对象可以是模板类，因此可以用不同类型的参数实例化。而普通函数要实现相同的功能可能需要函数模板或一组重载的函数。
3. **内联优化：**
   - 函数对象的调用可能会被内联优化，减少函数调用的开销。而普通函数的调用开销相对较高。
4. **类型信息：**
   - 函数对象可以携带类型信息，例如在STL算法中可以通过模板参数推导出比较器的类型。

### 函数对象示例

**普通函数：**

```
cpp复制代码#include <iostream>
bool greater(int a, int b) {
    return a > b;
}

int main() {
    std::cout << greater(10, 20) << std::endl; // 输出 0
    return 0;
}
```

**函数对象：**

```
cpp复制代码#include <iostream>

class Greater {
public:
    bool operator()(int a, int b) {
        return a > b;
    }
};

int main() {
    Greater greater;
    std::cout << greater(10, 20) << std::endl; // 输出 0
    return 0;
}
```

### 总结

函数对象通过重载 `operator()` 提供了类似于函数的调用方式，但它们比普通函数更灵活，可以保存状态，并且在模板编程中非常有用。它们广泛应用于STL算法中，比如 `std::sort` 等。





## 泛型算法和绑定器

### 泛型算法

泛型算法是指可以应用于多种数据类型和数据结构的算法。它们通常使用模板技术来实现，并且可以在标准模板库（STL）中找到。泛型算法使得代码更加灵活和可重用，避免了为每种数据类型编写相同算法的需要。

#### 常见的泛型算法

1. **排序算法**：
   - `std::sort`: 对范围内的元素进行排序。
   - `std::stable_sort`: 对范围内的元素进行稳定排序。
   
   ```cpp
   #include <algorithm>
   #include <vector>
   #include <iostream>
   
   int main() {
       std::vector<int> vec = {4, 2, 3, 1, 5};
       std::sort(vec.begin(), vec.end());
       for (int i : vec) {
           std::cout << i << " ";
       }
       return 0;
   }
   ```

2. **查找算法**：
   - `std::find`: 在范围内查找等于某值的元素。
   - `std::binary_search`: 在有序范围内进行二分查找。

   ```cpp
   #include <algorithm>
   #include <vector>
   #include <iostream>
   
   int main() {
       std::vector<int> vec = {1, 2, 3, 4, 5};
       auto it = std::find(vec.begin(), vec.end(), 3);
       if (it != vec.end()) {
           std::cout << "Found: " << *it << std::endl;
       } else {
           std::cout << "Not found" << std::endl;
       }
       return 0;
   }
   ```

3. **修改算法**：
   - `std::copy`: 将一个范围内的元素复制到另一个范围。
   - `std::transform`: 对范围内的每个元素应用函数并将结果存储到另一个范围。

   ```cpp
   #include <algorithm>
   #include <vector>
   #include <iostream>
   
   int main() {
       std::vector<int> vec = {1, 2, 3, 4, 5};
       std::vector<int> result(vec.size());
       std::transform(vec.begin(), vec.end(), result.begin(), [](int x) { return x * 2; });
       for (int i : result) {
           std::cout << i << " ";
       }
       return 0;
   }
   ```

### 绑定器（Binders）

绑定器是用于将函数参数绑定到特定值的工具，通常与函数对象一起使用。绑定器允许创建一个新的函数对象，该对象可以保存某些参数的值，从而简化函数调用。

C++11引入了`std::bind`，它可以替代传统的绑定器，如`std::bind1st`和`std::bind2nd`。

#### 使用 `std::bind`

`std::bind` 可以将一个函数的参数绑定到特定的值，从而创建一个新的函数对象。

```cpp
#include <iostream>
#include <functional>

void print_sum(int a, int b) {
    std::cout << (a + b) << std::endl;
}

int main() {
    auto bound_func = std::bind(print_sum, 2, std::placeholders::_1);
    bound_func(3);  // 相当于调用 print_sum(2, 3)
    return 0;
}
```

在上面的代码中，`std::bind` 将 `print_sum` 的第一个参数绑定为 `2`，创建了一个新的函数对象 `bound_func`。当调用 `bound_func(3)` 时，实际上是调用了 `print_sum(2, 3)`。

#### 使用绑定器简化算法调用

绑定器可以用于泛型算法，使得算法调用更加灵活。例如：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <functional>

bool greater_than(int a, int b) {
    return a > b;
}

int main() {
    std::vector<int> vec = {1, 4, 2, 8, 5, 7};

    // 使用 std::bind 将 greater_than 的第一个参数绑定为 5
    auto greater_than_5 = std::bind(greater_than, std::placeholders::_1, 5);

    // 统计 vec 中大于 5 的元素数量
    int count = std::count_if(vec.begin(), vec.end(), greater_than_5);
    std::cout << "Number of elements greater than 5: " << count << std::endl;

    return 0;
}
```

在这个例子中，我们使用 `std::bind` 将 `greater_than` 的第一个参数绑定为 `5`，创建了一个新的函数对象 `greater_than_5`。然后，我们使用这个函数对象作为谓词传递给 `std::count_if` 算法，统计大于 `5` 的元素数量。

### 总结

- **泛型算法**：使用模板技术实现的通用算法，适用于多种数据类型和数据结构。
- **绑定器**：工具，用于将函数参数绑定到特定值，从而创建新的函数对象，简化函数调用和算法使用。
- **`std::bind`**：现代C++中的绑定器，用于创建绑定参数的函数对象，取代传统的绑定器如`std::bind1st`和`std::bind2nd`。

通过结合泛型算法和绑定器，可以编写出更灵活、可重用的代码，充分利用C++标准库提供的强大功能。



# 详解绑定器

### 绑定器（Binders）

绑定器在C++中是一种工具，可以将函数的一部分参数预先绑定到特定的值，从而创建一个新的函数对象。这样可以简化函数调用和提高代码的灵活性。

### 传统绑定器

在C++98中，绑定器主要通过`std::bind1st`和`std::bind2nd`实现，它们分别用于将函数的第一个参数或第二个参数绑定到特定的值。不过，这种方式较为有限，不支持绑定多个参数，也不支持复杂的绑定需求。

#### 示例：使用`std::bind1st`和`std::bind2nd`

```cpp
#include <iostream>
#include <algorithm>
#include <functional>
#include <vector>

bool greater_than(int a, int b) {
    return a > b;
}

int main() {
    std::vector<int> vec = {1, 4, 2, 8, 5, 7};

    // 使用 std::bind2nd 将 greater_than 的第二个参数绑定为 5
    auto greater_than_5 = std::bind2nd(std::ptr_fun(greater_than), 5);

    // 统计 vec 中大于 5 的元素数量
    int count = std::count_if(vec.begin(), vec.end(), greater_than_5);
    std::cout << "Number of elements greater than 5: " << count << std::endl;

    return 0;
}
```

### 现代绑定器：`std::bind`

C++11引入了`std::bind`，大大增强了绑定器的功能和灵活性。`std::bind`可以绑定任意数量的参数，并且可以与其他C++11特性如lambda表达式和`std::function`结合使用。

#### 示例：使用`std::bind`

```cpp
#include <iostream>
#include <functional>

void print_sum(int a, int b) {
    std::cout << (a + b) << std::endl;
}

int main() {
    // 将 print_sum 的第一个参数绑定为 2
    auto bound_func = std::bind(print_sum, 2, std::placeholders::_1);

    // 调用 bound_func(3) 实际上是调用 print_sum(2, 3)
    bound_func(3);

    return 0;
}
```

在上面的示例中，`std::bind`将`print_sum`的第一个参数绑定为`2`，创建了一个新的函数对象`bound_func`。当调用`bound_func(3)`时，实际上是调用了`print_sum(2, 3)`。

### 占位符

`std::bind`使用`std::placeholders`中的占位符来指示未绑定的参数。占位符`_1`、`_2`、`_3`等分别表示函数的第一个、第二个、第三个参数。

#### 示例：绑定多个参数

```cpp
#include <iostream>
#include <functional>

void print(int a, int b, int c) {
    std::cout << a << " " << b << " " << c << std::endl;
}

int main() {
    // 将 print 的第一个参数绑定为 1，第三个参数绑定为 3
    auto bound_func = std::bind(print, 1, std::placeholders::_1, 3);

    // 调用 bound_func(2) 实际上是调用 print(1, 2, 3)
    bound_func(2);

    return 0;
}
```

### 使用绑定器与算法结合

绑定器经常与泛型算法结合使用，以便在调用算法时简化参数传递。例如：

#### 示例：使用`std::bind`和`std::count_if`

```cpp
#include <iostream>
#include <algorithm>
#include <functional>
#include <vector>

bool greater_than(int a, int b) {
    return a > b;
}

int main() {
    std::vector<int> vec = {1, 4, 2, 8, 5, 7};

    // 使用 std::bind 将 greater_than 的第二个参数绑定为 5
    auto greater_than_5 = std::bind(greater_than, std::placeholders::_1, 5);

    // 统计 vec 中大于 5 的元素数量
    int count = std::count_if(vec.begin(), vec.end(), greater_than_5);
    std::cout << "Number of elements greater than 5: " << count << std::endl;

    return 0;
}
```

在这个示例中，我们使用`std::bind`将`greater_than`的第二个参数绑定为`5`，创建了一个新的函数对象`greater_than_5`。然后，我们使用这个函数对象作为谓词传递给`std::count_if`算法，统计大于`5`的元素数量。

### 绑定器的灵活性

与传统绑定器相比，`std::bind`更为灵活，能够处理更复杂的情况。例如，可以绑定成员函数、自由函数、函数对象，以及结合`std::function`和lambda表达式使用。

#### 示例：绑定成员函数

```cpp
#include <iostream>
#include <functional>

class MyClass {
public:
    void print(int a, int b) {
        std::cout << a << " " << b << std::endl;
    }
};

int main() {
    MyClass obj;
    // 绑定成员函数 print，绑定第一个参数为 1
    auto bound_func = std::bind(&MyClass::print, &obj, 1, std::placeholders::_1);

    // 调用 bound_func(2) 实际上是调用 obj.print(1, 2)
    bound_func(2);

    return 0;
}
```

在这个示例中，`std::bind`用于绑定成员函数`MyClass::print`，并绑定`print`的第一个参数为`1`，创建了一个新的函数对象`bound_func`。当调用`bound_func(2)`时，实际上是调用了`obj.print(1, 2)`。

### 总结

- **传统绑定器**（`std::bind1st`和`std::bind2nd`）：只能绑定第一个或第二个参数，功能较为有限。
- **现代绑定器**（`std::bind`）：可以绑定任意数量的参数，并且支持更复杂的绑定需求。
- **占位符**（`std::placeholders`）：用于指示未绑定的参数。
- **绑定器的应用**：结合泛型算法使用，提高代码的灵活性和简洁性。

通过理解和使用绑定器，可以使代码更加模块化和易于维护，充分利用C++的强大功能。



## 对象在调用过程中，背后调用了什么方法？

在 C++ 中，对象在使用过程中会调用一些特殊的方法，具体包括：

1. **构造函数**：
   - 在对象创建时调用，用于初始化对象。

2. **析构函数**：
   - 在对象生命周期结束时调用，用于清理资源。

3. **拷贝构造函数**：
   - 在使用已有对象初始化新对象时调用，比如传值参数或返回值。

4. **拷贝赋值运算符**：
   - 在将一个对象赋值给另一个已有对象时调用。

5. **移动构造函数**（C++11 引入）：
   - 在移动对象时调用（例如使用 `std::move`）。

6. **移动赋值运算符**（C++11 引入）：
   - 在将一个对象移动赋值给另一个已有对象时调用。

7. **转换函数**：
   - 当对象需要隐式转换为其他类型时调用。

8. **析构函数**：
   - 在对象生命周期结束时调用，用于释放资源。

### 示例代码

```cpp
class MyClass {
public:
    MyClass() { /* 构造函数 */ }
    ~MyClass() { /* 析构函数 */ }
    MyClass(const MyClass& other) { /* 拷贝构造函数 */ }
    MyClass& operator=(const MyClass& other) { /* 拷贝赋值运算符 */ return *this; }
    MyClass(MyClass&& other) { /* 移动构造函数 */ }
    MyClass& operator=(MyClass&& other) { /* 移动赋值运算符 */ return *this; }
    operator int() const { /* 转换函数 */ return 0; }
};

void example() {
    MyClass obj1;                  // 构造函数
    MyClass obj2 = obj1;           // 拷贝构造函数
    MyClass obj3;                  
    obj3 = obj1;                   // 拷贝赋值运算符
    MyClass obj4 = std::move(obj1);// 移动构造函数
    obj4 = std::move(obj2);        // 移动赋值运算符
    int value = obj4;              // 转换函数
} // 析构函数（自动调用）
```

### 总结

- **创建**：构造函数。
- **销毁**：析构函数。
- **复制**：拷贝构造函数、拷贝赋值运算符。
- **移动**：移动构造函数、移动赋值运算符。
- **转换**：转换函数。

这些方法帮助管理对象的生命周期、内存和资源。



## 对象优化的规则

在 C++ 中，对象优化的规则包括以下几点：

### 1. 使用初始化列表

- **原因**：提高效率，避免多次赋值。
- **示例**：
  ```cpp
  class MyClass {
  public:
      MyClass(int x) : value(x) {}
  private:
      int value;
  };
  ```

### 2. 避免不必要的拷贝

- **使用`const`引用传递参数**：
  ```cpp
  void func(const MyClass& obj);
  ```
- **使用移动语义**（C++11及以上）：
  ```cpp
  MyClass(MyClass&& other);
  ```

### 3. 使用智能指针

- **避免手动管理内存**：
  ```cpp
  std::unique_ptr<MyClass> ptr(new MyClass());
  ```

### 4. 避免使用裸指针

- **改用智能指针或引用**：
  ```cpp
  std::shared_ptr<MyClass> sharedPtr = std::make_shared<MyClass>();
  ```

### 5. 在合适的地方使用`std::move`

- **优化移动操作，避免不必要的拷贝**：
  ```cpp
  MyClass obj = std::move(otherObj);
  ```

### 6. 避免重复的内存分配

- **使用容器的`reserve`方法**：
  ```cpp
  std::vector<int> vec;
  vec.reserve(100);
  ```

### 7. 使用`emplace`系列方法

- **在容器中直接构造对象，避免拷贝**：
  ```cpp
  std::vector<MyClass> vec;
  vec.emplace_back(10);
  ```

### 8. 合理使用`inline`函数

- **减少函数调用开销**：
  ```cpp
  inline int getValue() const { return value; }
  ```

### 9. 避免在循环中创建对象

- **将对象的创建移出循环**：
  ```cpp
  for (int i = 0; i < n; ++i) {
      MyClass obj;  // 在循环外部创建对象
  }
  ```

### 10. 使用`std::array`替代`std::vector`（如果大小已知且固定）

- **提高效率和性能**：
  ```cpp
  std::array<int, 10> arr;
  ```

### 总结

- 使用初始化列表提高效率。
- 使用`const`引用和移动语义避免不必要的拷贝。
- 使用智能指针管理内存。
- 在容器中使用`emplace`和`reserve`方法。
- 使用`std::move`和`inline`函数进行性能优化。
- 在合适的情况下选择适当的数据结构。
- 尽可能函数调用使用引用传递，不要值传递
- 函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象![image-20240630110745645](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630110745645.png)![image-20240630110446292](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630110446292.png)
- 上面这个的图进行对比的话，上图的t2是初始化的操作，下图是赋值的操作，相对来说是多一点函数调用的
- 接收返回值是对象的函数调用的时候，优先安初始化的方式接受，不要按赋值的方式接收



CMystring的代码问题

![image-20240630112310359](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630112310359.png)

![image-20240630112333096](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630112333096.png)

![image-20240630112339552](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630112339552.png)

解决方法：使用右值引用参数拷贝构造函数和赋值函数

ps：左值：有内存有名字，，右值，没名字临时量

![image-20240630112647542](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630112647542.png)

也可以使用常量做引用，就是直接const int &d = 20；

![image-20240630112919712](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630112919712.png)

优化拷贝构造函数



![image-20240630113424202](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630113424202.png)

str引用就是一个临时对象而已

![image-20240630113740132](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630113740132.png)

![image-20240630113752328](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630113752328.png)

CMystring在vector上面的引用

![image-20240630114239068](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630114239068.png)

为了实现内存管理，直接删除多出来泄漏的内存，所以我们可以进行赋值，然后删除这块空间

但是效率不高

![image-20240630114356124](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630114356124.png)

结合右引用的话就不是这么写了



![image-20240630114748048](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630114748048.png)



这样子写的话就是直接构造cmystring一次，然后右值拷贝构造一次，然后析构就行了，可以节省一次析构函数的使用时间





左值引用+右值=左值



例子2



![image-20240630115246198](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630115246198.png)





## move移动语义和forward类型完美转发

![image-20240630115709787](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630115709787.png)

引入了移动语义和完美转发的概念，以提高程序的性能和灵活性。

### 移动语义 (`std::move`)

#### 什么是移动语义？

- 移动语义允许资源的所有权从一个对象移动到另一个对象，而不是复制资源。这对于避免昂贵的深拷贝操作特别有用。

#### 如何使用？

- 使用 `std::move` 将左值强制转换为右值引用，从而启用移动语义。

#### 示例代码

```cpp
#include <iostream>
#include <vector>

class MyClass {
public:
    MyClass(int size) : data(new int[size]), size(size) {
        std::cout << "Constructed\n";
    }
    ~MyClass() {
        delete[] data;
        std::cout << "Destroyed\n";
    }
    // 移动构造函数
    MyClass(MyClass&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
        std::cout << "Moved\n";
    }
    // 禁用拷贝构造函数
    MyClass(const MyClass& other) = delete;

private:
    int* data;
    int size;
};

int main() {
    MyClass a(100);
    MyClass b(std::move(a));  // 使用移动语义
    return 0;
}
```

### 完美转发 (`std::forward`)

#### 什么是完美转发？

- 完美转发用于将参数精确地传递给另一个函数，保持参数的左值或右值属性。

#### 如何使用？

- `std::forward` 与模板类型参数一起使用，以正确地将参数转发给另一个函数。

#### 示例代码

```cpp
#include <iostream>
#include <utility>

void overloaded(int& x) {
    std::cout << "Lvalue\n";
}

void overloaded(int&& x) {
    std::cout << "Rvalue\n";
}

template <typename T>
void forwarding(T&& arg) {
    overloaded(std::forward<T>(arg));
}

int main() {
    int a = 10;
    forwarding(a);          // 调用 Lvalue 版本
    forwarding(10);         // 调用 Rvalue 版本
    forwarding(std::move(a)); // 调用 Rvalue 版本
    return 0;
}
```

### 总结

- **`std::move`**：用于将左值转换为右值引用，以启用移动语义。它不会实际移动对象，只是将其转换为可以被移动的状态。
- **`std::forward`**：用于保持参数的原始值属性（左值或右值）并将其完美地传递给另一个函数。常与模板函数一起使用，确保参数在转发过程中保持其引用属性。

这些特性共同提高了 C++ 程序的性能，减少了不必要的复制，增强了函数模板的灵活性。





![image-20240630131517345](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630131517345.png)

使用模板进行

![image-20240630152410545](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630152410545.png)

这里通过forward进行识别完成转化



根据非完全特例化实现的

move（左值）：移动语义，得到右值类型 （int&&) a

下面那个如果是右值就进行匹配，move了，因为传进来是左值，然后墙砖城右值

![image-20240630152845514](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630152845514.png)

forward:类型完美转发，能够识别左值和右值类型

![image-20240630153447031](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240630153447031.png)





# 智能指针

### 智能指针介绍

学习C++的人，一直在接触裸指针，一边感受着它的强大，一边感受着它的坑爹。当然，坑不坑爹在于开发者，指针本身近乎完美，但奈何用的人比较猥琐，给自己埋下无数的坑，还哭喊着指针不好用，那么今天要介绍的智能指针可以释放大家在使用裸指针时的一些压力，当然智能指针无法替代裸指针的全部功能。

裸指针到底有什么不好，写过一些C++代码的人应该都能知道，比如下面的原因：

1. 忘记释放资源，导致资源泄露（常发生内存泄漏问题）
2. 同一资源释放多次，导致释放野指针，程序崩溃
3. 明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到，懵
4. 代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到，懵

总之，智能指针的智能二字，主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。

C++11库里面，提供了带引用计数的智能指针和不带引用计数的智能指针，这篇文章主要介绍它们的原理和应用场景，包括**auto_ptr，scoped_ptr，unique_ptr，shared_ptr，weak_ptr**。

### 自己实现智能指针

为了更好的理解C++库中智能指针的原理，我们首先需要自己实现一个简单的智能指针，窥探一下智能指针的基本原理，就是利用**栈上的对象出作用域会自动析构**这么一个特点，把资源释放的代码全部放在这个析构函数中执行，来做到资源的自动释放，就达到了所谓的智能指针。对比下面的两块代码：

使用裸指针

```c++
int main()
{
	int *p = new int;
	/*其它的代码...*/
	/*
	如果这里忘记写delete，或者上面的代码段中程序return掉了，
	没有执行到这里，都会导致这里没有释放内存，内存泄漏
	*/
	delete p;

	return 0;

}
```

使用智能指针

```c++
template<typename T>
class CSmartPtr
{
public:
	CSmartPtr(T *ptr = nullptr) :mptr(ptr) {}
	~CSmartPtr() { delete mptr; }
private:
	T *mptr;
};

int main()
{
	CSmartPtr<int> ptr(new int);
	/*其它的代码...*/

	/*由于ptr是栈上的智能指针对象，不管是函数正常执行完，还是运行过程中出现
	异常，栈上的对象都会自动调用析构函数，在析构函数中进行了delete
	操作，保证释放资源*/
	return 0;

}
```


上面这段代码就是一个非常简单的智能指针，主要用到了这两点：

1. 智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源
2. 利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源

所以，智能指针一般都是定义在栈上的，曾经有一个面试问题，问“能不能在堆上定义智能指针？”，如这段代码CSmartPtr *p = new CSmartPtr(new int);大家应该能看出来，这里定义的p虽然是智能指针类型，但它实质上还是一个裸指针，因此p还是需要进行手动delete，又回到了最开始裸指针我们面临的问题。

当然，智能指针要做到和裸指针相似，还得提供裸指针常见的*和->两种运算符的重载函数，使用起来才真正的和裸指针一样，代码扩充如下：

```c++
template<typename T>
class CSmartPtr
{
public:
	CSmartPtr(T *ptr = nullptr) :mptr(ptr) {}
	~CSmartPtr() { delete mptr; }

	T& operator*() { return *mptr; }
	const T& operator*()const { return *mptr; }
	
	T* operator->() { return mptr; }
	const T* operator->()const { return mptr; }

private:
	T *mptr;
};
int main()
{
	CSmartPtr<int> ptr(new int);
	*ptr = 20;
	cout << *ptr << endl;
	return 0;
}
```


上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题，看下面的代码：

```c++
int main()
{
	CSmartPtr<int> ptr1(new int);
	CSmartPtr<int> ptr2(ptr1);
	return 0;
}
```


这个main函数运行，代码直接崩溃，问题出在默认的拷贝构造函数做的是浅拷贝，两个智能指针都持有一个new int资源，ptr2先析构释放了资源，到ptr1析构的时候，就成了delete野指针了，造成程序崩溃。所以这里引出来智能指针需要解决的两件事情：

怎么解决智能指针的浅拷贝问题
多个智能指针指向同一个资源的时候，怎么保证资源只释放一次，而不是每个智能指针都释放一次，造成代码运行不可预期的严重后果
我们一起看看C++库中提供的智能指针是怎么解决上面提到的问题的。



![image-20240701090607278](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240701090607278.png)



### 不带引用计数的智能指针

C++库中提供的不带引用计数的智能指针主要包括：auto_ptr，scoped_ptr，unique_ptr，下面一一进行介绍。

auto_ptr
先浏览一下auto_ptr的主要源码，如下：

```c++
template<class _Ty>
	class auto_ptr
	{	// wrap an object pointer to ensure destruction
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty * _Ptr = nullptr) noexcept
		: _Myptr(_Ptr)
		{	// construct from object pointer
		}
	
	/*这里是auto_ptr的拷贝构造函数，
	_Right.release()函数中，把_Right的_Myptr
	赋为nullptr，也就是换成当前auto_ptr持有资源地址
	*/
	auto_ptr(auto_ptr& _Right) noexcept
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right auto_ptr
		}
		
	_Ty * release() noexcept
		{	// return wrapped pointer and give up ownership
		_Ty * _Tmp = _Myptr;
		_Myptr = nullptr;
		return (_Tmp);
		}

private:
	_Ty * _Myptr;	// the wrapped object pointer
};
```


从auto_ptr的源码可以看到，只有最后一个auto_ptr智能指针持有资源，原来的auto_ptr都被赋nullptr了，考虑如下代码：

```c++
int main()
{
	auto_ptr<int> p1(new int);
	/*
	经过拷贝构造，p2指向了new int资源，
	p1现在为nullptr了，如果使用p1，相当于
	访问空指针了，很危险
	*/
	auto_ptr<int> p2 = p1;
	*p1 = 10;
	return 0;
}

```

上面的程序，如果用户不了解auto_ptr的实现，代码就会出现严重的问题。记得曾经一个面试题问过“auto_ptr能不能使用在容器当中？”，看下面的代码描述：

```c++
int main()
{
	vector<auto_ptr<int>> vec;
	vec.push_back(auto_ptr<int>(new int(10)));
	vec.push_back(auto_ptr<int>(new int(20)));
	vec.push_back(auto_ptr<int>(new int(30)));
	// 这里可以打印出10
	cout << *vec[0] << endl;
	vector<auto_ptr<int>> vec2 = vec;
	/* 这里由于上面做了vector容器的拷贝，相当于容器中
	的每一个元素都进行了拷贝构造，原来vec中的智能指针
	全部为nullptr了，再次访问就成访问空指针了，程序崩溃
	*/
	cout << *vec[0] << endl;
	return 0;
}
```


所以不要在容器中使用auto_ptr，C++建议最好不要使用auto_ptr，除非应用场景非常简单。

【总结】：auto_ptr智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都置为nullptr，只让最后一个auto_ptr持有资源。

```c++
//scoped_ptr
//先浏览一下scoped_ptr的源码，如下：
template<class T> class scoped_ptr // noncopyable
{
private:
    T * px;
	

	/*
	私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针
	对象就不支持这两种操作，从根本上杜绝浅拷贝的发生
	*/
	scoped_ptr(scoped_ptr const &);
	scoped_ptr & operator=(scoped_ptr const &);
	 
	typedef scoped_ptr<T> this_type;
		
	/*
	私有化逻辑比较运算符重载函数，不支持scoped_ptr的智能指针
	对象的比较操作
	*/
	void operator==( scoped_ptr const& ) const;
	void operator!=( scoped_ptr const& ) const;

public:
    typedef T element_type;
    explicit scoped_ptr( T * p = 0 ): px( p ) // never throws
    {
#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
        boost::sp_scalar_constructor_hook( px );
#endif
    }

#ifndef BOOST_NO_AUTO_PTR
	/*支持从auto_ptr构造一个scoped_ptr智能指针对象，
	但是auto_ptr因为调用release()函数，导致其内部指
	针为nullptr*/
    explicit scoped_ptr( std::auto_ptr<T> p ) BOOST_NOEXCEPT : px( p.release() )
    {
#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
        boost::sp_scalar_constructor_hook( px );
#endif
    }

#endif
	/*析构函数，释放智能指针持有的资源*/
    ~scoped_ptr() // never throws
    {
#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
        boost::sp_scalar_destructor_hook( px );
#endif
        boost::checked_delete( px );
    }
};
```


从scoped_ptr的源码可以看到，该智能指针由于私有化了拷贝构造函数和operator=赋值函数，因此从根本上杜绝了智能指针浅拷贝的发生，所以scoped_ptr也是不能用在容器当中的，如果容器互相进行拷贝或者赋值，就会引起scoped_ptr对象的拷贝构造和赋值，这是不允许的，代码会提示编译错误。

auto_ptr和scoped_ptr这一点上的区别，有些资料上用所有权的概念来描述，道理是相同的，auto_ptr可以任意转移资源的所有权，而scoped_ptr不会转移所有权（因为拷贝构造和赋值被禁止了）。

unique_ptr
如果要深入了解unique_ptr，需要先了解C++的右值引用原理，请参考我的另外一篇博客，链接地址：https://blog.csdn.net/QIANGWEIYUAN/article/details/88653747
先看看unique_ptr的部分源码如下：

```c++
template<class _Ty,
	class _Dx>	// = default_delete<_Ty>
	class unique_ptr
		: public _Unique_ptr_base<_Ty, _Dx>
	{	// non-copyable pointer to an object
public:
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	/*提供了右值引用的拷贝构造函数*/
	unique_ptr(unique_ptr&& _Right) noexcept
		: _Mybase(_Right.release(),
			_STD forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}
	
	/*提供了右值引用的operator=赋值重载函数*/
	unique_ptr& operator=(unique_ptr&& _Right) noexcept
		{	// assign by moving _Right
		if (this != _STD addressof(_Right))
			{	// different, do the move
			reset(_Right.release());
			this->get_deleter() = _STD forward<_Dx>(_Right.get_deleter());
			}
		return (*this);
		}
	
	/*
	交换两个unique_ptr智能指针对象的底层指针
	和删除器
	*/
	void swap(unique_ptr& _Right) noexcept
		{	// swap elements
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}
	
	/*通过自定义删除器释放资源*/
	~unique_ptr() noexcept
		{	// destroy the object
		if (get() != pointer())
			{
			this->get_deleter()(get());
			}
		}
	
	/*unique_ptr提供->运算符的重载函数*/
	_NODISCARD pointer operator->() const noexcept
		{	// return pointer to class object
		return (this->_Myptr());
		}
	
	/*返回智能指针对象底层管理的指针*/
	_NODISCARD pointer get() const noexcept
		{	// return pointer to object
		return (this->_Myptr());
		}
	
	/*提供bool类型的重载，使unique_ptr对象可以
	直接使用在逻辑语句当中，比如if,for,while等*/
	explicit operator bool() const noexcept
		{	// test for non-null pointer
		return (get() != pointer());
		}
	
	/*功能和auto_ptr的release函数功能相同，最终也是只有一个unique_ptr指针指向资源*/
	pointer release() noexcept
		{	// yield ownership of pointer
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}
	
	/*把unique_ptr原来的旧资源释放，重置新的资源_Ptr*/
	void reset(pointer _Ptr = pointer()) noexcept
		{	// establish new pointer
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			{
			this->get_deleter()(_Old);
			}
		}
	/*
	删除了unique_ptr的拷贝构造和operator=赋值函数，
	因此不能做unique_ptr智能指针对象的拷贝构造和
	赋值，防止浅拷贝的发生
	*/
	unique_ptr(const unique_ptr&) = delete;
	unique_ptr& operator=(const unique_ptr&) = delete;
	};



```

从上面看到，unique_ptr有一点和scoped_ptr做的一样，就是去掉了拷贝构造函数和operator=赋值重载函数，禁止用户对unique_ptr进行显示的拷贝构造和赋值，防止智能指针浅拷贝问题的发生。

但是unique_ptr提供了带右值引用参数的拷贝构造和赋值，也就是说，unique_ptr智能指针可以通过右值引用进行拷贝构造和赋值操作，或者在产生unique_ptr临时对象的地方，如把unique_ptr作为函数的返回值时，示例代码如下：

```c++
// 示例1
unique_ptr<int> ptr(new int);
unique_ptr<int> ptr2 = std::move(ptr); // 使用了右值引用的拷贝构造
ptr2 = std::move(ptr); // 使用了右值引用的operator=赋值重载函数

// 示例2
unique_ptr<int> test_uniqueptr()
{
	unique_ptr<int> ptr1(new int);
	return ptr1;
}
int main()
{
	/*
	此处调用test_uniqueptr函数，在return ptr1代码
	处，调用右值引用的拷贝构造函数，由ptr1拷贝构造ptr
	*/
	unique_ptr<int> ptr = test_uniqueptr();
	return 0;
}
```

unique_ptr还提供了reset重置资源，swap交换资源等函数，也经常会使用到。可以看到，unique_ptr从名字就可以看出来，最终也是只能有一个该智能指针引用资源，因此建议在使用不带引用计数的智能指针时，可以优先选择unique_ptr智能指针。

### 带引用计数的智能指针shared_ptr、weak_ptr

这里主要介绍 shared_ptr 和 weak_ptr 两个智能指针，什么是带引用计数的智能指针？当允许多个智能指针指向同一个资源的时候，每一个智能指针都会给资源的引用计数加1，当一个智能指针析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了，由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。

![image-20240701101856915](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240701101856915.png)

要对资源的引用个数进行计数，那么大家知道，对于整数的++或者- -操作，它并不是线程安全的操作，因此shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此**shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针**。

曾经有一道面试的问题这样问“ shared_ptr 智能指针的引用计数在哪里存放？”，当然，这个问题需要看shared_ptr的源码了，如下：

```c++
private:
	/*
	下面这两个是shared_ptr的成员变量，_Ptr是指向内存资源的指针，_Rep是指向new出来的计数器对象的指针，该计数器对象包含了资源的一个引用计数器count
	*/
	element_type * _Ptr{nullptr};
	_Ref_count_base * _Rep{nullptr};
```


因此，shared_ptr智能指针的资源引用计数器在内存的heap堆上。shared_ptr一般被称作强智能指针、**可以**改变资源的引用计数，weak_ptr被称作弱智能指针、**不可以**改变资源的引用计数，它们有下边两个非常重要的应用场景需要注意。定义对象的时候使用强智能指针，引用对象的时候使用弱智能指针

### `shared_ptr`的详细介绍

`shared_ptr` 是 C++ 标准库中提供的一种智能指针，用于管理动态分配的对象的生命周期。与普通指针不同，它能确保对象在不再需要时被自动释放，从而避免内存泄漏。`shared_ptr` 采用引用计数机制，即每个对象都维护一个引用计数，记录有多少个 `shared_ptr` 实例指向该对象。当引用计数为零时，表示没有 `shared_ptr` 实例指向该对象，此时该对象会被自动删除。

#### 基本用法

##### 1. 创建和使用 `shared_ptr`

```cpp
#include <iostream>
#include <memory>  // 包含 shared_ptr 的头文件

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);  // 创建一个 shared_ptr，指向一个值为 10 的整数
    std::cout << "ptr1 points to: " << *ptr1 << std::endl;  // 使用 * 解引用

    {
        std::shared_ptr<int> ptr2 = ptr1;  // ptr2 是 ptr1 的拷贝，共享同一个对象
        std::cout << "ptr2 points to: " << *ptr2 << std::endl;
        std::cout << "Use count: " << ptr1.use_count() << std::endl;  // 打印引用计数
    }  // ptr2 作用域结束，引用计数减1

    std::cout << "Use count after ptr2 goes out of scope: " << ptr1.use_count() << std::endl;

    return 0;  // ptr1 作用域结束，引用计数变为 0，对象被自动删除
}
```

#### 关键点解释

1. **创建 `shared_ptr`**:
   ```cpp
   std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
   ```
   这行代码创建了一个 `shared_ptr`，它指向一个值为 10 的整数。`std::make_shared` 是一种推荐的创建 `shared_ptr` 的方法，因为它更高效并且减少了内存分配的次数。

2. **引用计数**:
   ```cpp
   std::cout << "Use count: " << ptr1.use_count() << std::endl;
   ```
   `use_count` 方法返回指向同一个对象的 `shared_ptr` 实例的数量。在示例中，当 `ptr2` 被创建时，`use_count` 的值为 2，当 `ptr2` 离开作用域时，`use_count` 的值降为 1。

3. **自动删除**:
   当 `shared_ptr` 的引用计数降为 0 时，即所有指向该对象的 `shared_ptr` 都销毁时，`shared_ptr` 会自动删除其指向的对象，释放内存。

#### 使用场景

- **动态分配对象的管理**: 在动态分配对象的情况下使用 `shared_ptr` 可以避免手动管理对象的生命周期，从而减少内存泄漏的风险。
- **资源共享**: 多个对象或函数可以共享同一个动态分配的资源，并且不必担心谁应该负责释放资源。

#### 注意事项

- **循环引用**: 使用 `shared_ptr` 时要注意避免循环引用，即两个或多个 `shared_ptr` 实例相互引用对方，从而导致引用计数永远不会降为零。这种情况下可以使用 `std::weak_ptr` 来打破循环引用。

```cpp
#include <iostream>
#include <memory>

struct Node {
    std::shared_ptr<Node> next;
    ~Node() {
        std::cout << "Node destroyed" << std::endl;
    }
};

int main() {
    {
        std::shared_ptr<Node> node1 = std::make_shared<Node>();
        std::shared_ptr<Node> node2 = std::make_shared<Node>();
        node1->next = node2;
        node2->next = node1;  // 形成循环引用
    }  // Node 没有被销毁，因为引用计数循环，导致内存泄漏

    return 0;
}
```

要打破上述的循环引用，可以使用 `std::weak_ptr`:

```cpp
#include <iostream>
#include <memory>

struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 使用 weak_ptr 打破循环引用
    ~Node() {
        std::cout << "Node destroyed" << std::endl;
    }
};

int main() {
    {
        std::shared_ptr<Node> node1 = std::make_shared<Node>();
        std::shared_ptr<Node> node2 = std::make_shared<Node>();
        node1->next = node2;
        node2->prev = node1;  // 使用 weak_ptr 打破循环引用
    }  // Node 被正确销毁

    return 0;
}
```

通过上述示例，你可以看到 `shared_ptr` 如何在管理动态分配的对象和资源共享中发挥作用，以及如何避免使用过程中可能出现的循环引用问题。



### 智能指针的交叉引用（循环引用）问题

请看下面的这个代码示例：

```c++
#include <iostream>
#include <memory>
using namespace std;

class B; // 前置声明类B
class A
{
public:
	A() { cout << "A()" << endl; }
	~A() { cout << "~A()" << endl; }
	shared_ptr<B> _ptrb; // 指向B对象的智能指针
};
class B
{
public:
	B() { cout << "B()" << endl; }
	~B() { cout << "~B()" << endl; }
	shared_ptr<A> _ptra; // 指向A对象的智能指针
};
int main()
{
	shared_ptr<A> ptra(new A());// ptra指向A对象，A的引用计数为1
	shared_ptr<B> ptrb(new B());// ptrb指向B对象，B的引用计数为1
	ptra->_ptrb = ptrb;// A对象的成员变量_ptrb也指向B对象，B的引用计数为2
	ptrb->_ptra = ptra;// B对象的成员变量_ptra也指向A对象，A的引用计数为2

	cout << ptra.use_count() << endl; // 打印A的引用计数结果:2
	cout << ptrb.use_count() << endl; // 打印B的引用计数结果:2
	
	/*
	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和
	B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是
	A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，
	导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”
	*/
	return 0;

}


```

```c++
//代码打印结果：
A()
B()
2
2
```

可以看到，A和B对象并没有进行析构，通过上面的代码示例，能够看出来“交叉引用”的问题所在，就是对象无法析构，资源无法释放，那怎么解决这个问题呢？请注意强弱智能指针的一个重要应用规则：定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。

弱智能指针weak_ptr区别于shared_ptr之处在于：

weak_ptr不会改变资源的引用计数，只是一个**观察者**的角色，通过观察shared_ptr来判定资源是否存在(weak_ptr=>share_ptr=>资源（内存）)
weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数
weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源
那么上面的代码怎么修改，也就是如何解决带引用计数的智能指针的交叉引用问题，代码如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

class B; // 前置声明类B
class A
{
public:
	A() { cout << "A()" << endl; }
	~A() { cout << "~A()" << endl; }
	weak_ptr<B> _ptrb; // 指向B对象的弱智能指针。引用对象时，用弱智能指针
};
class B
{
public:
	B() { cout << "B()" << endl; }
	~B() { cout << "~B()" << endl; }
	weak_ptr<A> _ptra; // 指向A对象的弱智能指针。引用对象时，用弱智能指针
};
int main()
{
    // 定义对象时，用强智能指针
	shared_ptr<A> ptra(new A());// ptra指向A对象，A的引用计数为1
	shared_ptr<B> ptrb(new B());// ptrb指向B对象，B的引用计数为1
	// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变
	ptra->_ptrb = ptrb;
	// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变
	ptrb->_ptra = ptra;

	cout << ptra.use_count() << endl; // 打印结果:1
	cout << ptrb.use_count() << endl; // 打印结果:1
	
	/*
	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和
	B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象
	被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”
	*/
	return 0;

}


```

```c++
代码打印如下：
A()
B()
1
1
~B()
~A()
```

可以看到，A和B对象正常析构，问题解决！

### 多线程访问共享对象问题

有一个用C++写的开源网络库，muduo库，作者陈硕，大家可以在网上下载到muduo的源代码，该源码中对于智能指针的应用非常优秀，其中借助shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题，解释如下：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。

先看如下代码：

```c++
#include <iostream>
#include <thread>
using namespace std;

class Test
{
public:
	// 构造Test对象，_ptr指向一块int堆内存，初始值是20
	Test() :_ptr(new int(20)) 
	{
		cout << "Test()" << endl;
	}
	// 析构Test对象，释放_ptr指向的堆内存
	~Test()
	{
		delete _ptr;
		_ptr = nullptr;
		cout << "~Test()" << endl;
	}
	// 该show会在另外一个线程中被执行
	void show()
	{
		cout << *_ptr << endl;
	}
private:
	int *volatile _ptr;
};
void threadProc(Test *p)
{
	// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了
	std::this_thread::sleep_for(std::chrono::seconds(2));
	/* 
	此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。
	此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象
	存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！
	*/
	p->show();
}
int main()
{
	// 在堆上定义共享对象
	Test *p = new Test();
	// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p
	std::thread t1(threadProc, p);
	// 在main线程中析构Test共享对象
	delete p;
	// 等待子线程运行结束
	t1.join();
	return 0;
}



//运行上面的代码，发现在main主线程已经delete析构Test对象以后，子线程threadProc再去访问Test对象的show方法，无法打印出*_ptr的值20。可以用shared_ptr和weak_ptr来解决多线程访问共享对象的线程安全问题，上面代码修改如下：

#include <iostream>
#include <thread>
#include <memory>
using namespace std;

class Test
{
public:
	// 构造Test对象，_ptr指向一块int堆内存，初始值是20
	Test() :_ptr(new int(20)) 
	{
		cout << "Test()" << endl;
	}
	// 析构Test对象，释放_ptr指向的堆内存
	~Test()
	{
		delete _ptr;
		_ptr = nullptr;
		cout << "~Test()" << endl;
	}
	// 该show会在另外一个线程中被执行
	void show()
	{
		cout << *_ptr << endl;
	}
private:
	int *volatile _ptr;
};
void threadProc(weak_ptr<Test> pw) // 通过弱智能指针观察强智能指针
{
	// 睡眠两秒
	std::this_thread::sleep_for(std::chrono::seconds(2));
	/* 
	如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升
	为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存
	的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象
	已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。
	*/
	shared_ptr<Test> ps = pw.lock();
	if (ps != nullptr)
	{
		ps->show();
	}
}
int main()
{
	// 在堆上定义共享对象
	shared_ptr<Test> p(new Test);
	// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
	std::thread t1(threadProc, weak_ptr<Test>(p));
	// 在main线程中析构Test共享对象
	// 等待子线程运行结束
	t1.join();
	return 0;
}
```


运行上面的代码，show方法可以打印出20，因为main线程调用了t1.join()方法等待子线程结束，此时pw通过lock提升为ps成功，见上面代码示例。

如果设置t1为分离线程，让main主线程结束，p智能指针析构，进而把Test对象析构，此时show方法已经不会被调用，因为在threadProc方法中，pw提升到ps时，lock方法判定Test对象已经析构，提升失败！main函数代码可以如下修改测试：

```c++
int main()
{
	// 在堆上定义共享对象
	shared_ptr<Test> p(new Test);
	// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
	std::thread t1(threadProc, weak_ptr<Test>(p));
	// 在main线程中析构Test共享对象
	// 设置子线程分离
	t1.detach();
	return 0;
}
```

该main函数运行后，最终的threadProc中，show方法不会被执行到。以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用。

### 自定义删除器

我们经常用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会delete释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如打开的文件，此时对于文件指针的关闭，就不能用delete了，这时我们需要自定义智能指针释放资源的方式，先看看unique_ptr智能指针的析构函数代码，如下：

```c++
~unique_ptr() noexcept
{	// destroy the object
if (get() != pointer())
	{
	this->get_deleter()(get()); // 这里获取底层的删除器，进行函数对象的调用
	}
}

```

从unique_ptr的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象而已，示例代码如下：

```c++
class FileDeleter
{
public:
	// 删除器负责删除资源的函数
	void operator()(FILE *pf)
	{
		fclose(pf);
	}
};
int main()
{
    // 由于用智能指针管理文件资源，因此传入自定义的删除器类型FileDeleter
	unique_ptr<FILE, FileDeleter> filePtr(fopen("data.txt", "w"));
	return 0;
}
```


当然这种方式需要定义额外的函数对象类型，不推荐，可以用C++11提供的函数对象function和lambda表达式更好的处理自定义删除器，代码如下：

```c++
int main()
{
	// 自定义智能指针删除器，关闭文件资源
	unique_ptr<FILE, function<void(FILE*)>> 
		filePtr(fopen("data.txt", "w"), [](FILE *pf)->void{fclose(pf);});

	// 自定义智能指针删除器，释放数组资源
	unique_ptr<int, function<void(int*)>>
		arrayPtr(new int[100], [](int *ptr)->void {delete[]ptr; });
	
	return 0;



```


如果想进一步了解智能指针，可以查看智能指针的源码实现，或者看muduo网络库的源码。


### `删除器`详解

智能指针的删除器（Deleter）是一个自定义的函数对象，它在智能指针的生命周期结束时负责销毁和释放所管理的资源。智能指针在默认情况下使用 `delete` 运算符来释放内存，但有时你可能需要自定义释放资源的方式，这时候就需要使用删除器。

#### 使用自定义删除器的场景

1. **自定义资源释放**: 例如，资源需要通过特定的函数来释放，而不仅仅是调用 `delete` 运算符。
2. **管理非动态内存**: 例如，资源可能由其他库管理，你只需要在特定时机释放。
3. **记录日志**: 释放资源时记录日志或执行其他操作。

#### 基本用法

我们以 `std::shared_ptr` 为例，展示如何使用自定义删除器。

#### 1. 函数删除器

可以使用普通函数作为删除器。

```cpp
#include <iostream>
#include <memory>

void customDeleter(int* p) {
    std::cout << "Custom deleting pointer: " << p << std::endl;
    delete p;
}

int main() {
    std::shared_ptr<int> sp(new int(42), customDeleter);
    return 0;
}
```

在这个例子中，当 `sp` 超出作用域时，`customDeleter` 会被调用来释放资源。

#### 2. 仿函数删除器

可以使用自定义的仿函数类作为删除器。

```cpp
#include <iostream>
#include <memory>

class CustomDeleter {
public:
    void operator()(int* p) const {
        std::cout << "Custom deleting pointer using functor: " << p << std::endl;
        delete p;
    }
};

int main() {
    std::shared_ptr<int> sp(new int(42), CustomDeleter());
    return 0;
}
```

在这个例子中，`CustomDeleter` 是一个仿函数类，当 `sp` 超出作用域时，`CustomDeleter::operator()` 会被调用来释放资源。

#### 3. Lambda 删除器

可以使用 lambda 表达式作为删除器。

```cpp
#include <iostream>
#include <memory>

int main() {
    auto deleter = [](int* p) {
        std::cout << "Custom deleting pointer using lambda: " << p << std::endl;
        delete p;
    };

    std::shared_ptr<int> sp(new int(42), deleter);
    return 0;
}
```

在这个例子中，lambda 表达式定义了一个删除器，当 `sp` 超出作用域时，lambda 表达式会被调用来释放资源。

#### 使用自定义删除器的 `unique_ptr`

`std::unique_ptr` 也支持自定义删除器。

```cpp
#include <iostream>
#include <memory>

void customDeleter(int* p) {
    std::cout << "Custom deleting pointer: " << p << std::endl;
    delete p;
}

int main() {
    std::unique_ptr<int, void(*)(int*)> up(new int(42), customDeleter);
    return 0;
}
```

在这个例子中，我们创建了一个 `std::unique_ptr`，并指定了自定义删除器 `customDeleter`。

#### 结合模板使用自定义删除器

模板类可以更灵活地处理不同类型的资源，下面是一个简单的例子。

```cpp
#include <iostream>
#include <memory>

template <typename T>
class CustomDeleter {
public:
    void operator()(T* p) const {
        std::cout << "Custom deleting pointer: " << p << std::endl;
        delete p;
    }
};

int main() {
    std::shared_ptr<int> sp(new int(42), CustomDeleter<int>());
    return 0;
}
```

#### 总结

智能指针的自定义删除器提供了灵活的资源管理方式，适用于需要自定义资源释放逻辑的场景。通过使用函数、仿函数或者 lambda 表达式，你可以轻松地定义自适应的资源释放策略，从而确保在智能指针生命周期结束时，资源能够被正确地释放。













# 模板专题

## 模板结合指针

下面详细介绍如何结合模板和指针进行使用，并解释 `T *ptr` 这种写法。

### 1. 基本模板结合指针

使用模板结合指针，意味着你可以定义一个模板类或模板函数，它们可以操作任意类型的指针。这种写法使得代码更具通用性和重用性。

#### 1.1 模板类结合指针

假设你需要一个简单的智能指针类，你可以使用模板实现：

```cpp
#include <iostream>

template <typename T>
class SimpleSmartPointer {
private:
    T* ptr; // 原始指针
public:
    // 构造函数
    explicit SimpleSmartPointer(T* p = nullptr) : ptr(p) {}
    
    // 析构函数
    ~SimpleSmartPointer() {
        delete ptr;
    }
    
    // 重载*操作符
    T& operator*() {
        return *ptr;
    }
    
    // 重载->操作符
    T* operator->() {
        return ptr;
    }
};

class MyClass {
public:
    void display() {
        std::cout << "Display MyClass\n";
    }
};

int main() {
    SimpleSmartPointer<MyClass> ptr(new MyClass());
    ptr->display(); // 使用->操作符访问成员函数
    return 0;
}
```

在这个例子中，`SimpleSmartPointer` 类模板使用了类型参数 `T`，并且 `ptr` 是指向 `T` 类型的指针。通过这种方式，你可以创建指向任意类型的智能指针。

#### 1.2 模板函数结合指针

模板函数同样可以结合指针使用，实现对任意类型指针的通用操作。例如，一个交换两个指针的函数：

```cpp
#include <iostream>

template <typename T>
void swapPointers(T*& ptr1, T*& ptr2) {
    T* temp = ptr1;
    ptr1 = ptr2;
    ptr2 = temp;
}

int main() {
    int a = 5;
    int b = 10;
    int* ptr1 = &a;
    int* ptr2 = &b;
    
    std::cout << "Before swap: ptr1 points to " << *ptr1 << ", ptr2 points to " << *ptr2 << "\n";
    swapPointers(ptr1, ptr2);
    std::cout << "After swap: ptr1 points to " << *ptr1 << ", ptr2 points to " << *ptr2 << "\n";
    
    return 0;
}
```

在这个例子中，`swapPointers` 函数模板接受两个 `T*` 类型的引用，并交换它们的值。由于是模板函数，它可以处理任意类型的指针。

### 2. 结合模板和智能指针

现代 C++ 提供了标准库中的智能指针，如 `std::unique_ptr` 和 `std::shared_ptr`，你可以将它们与模板结合使用，实现更复杂的资源管理。

#### 2.1 使用 `std::unique_ptr` 和模板

```cpp
#include <iostream>
#include <memory>

template <typename T>
class Container {
private:
    std::unique_ptr<T> ptr;
public:
    Container(T* p) : ptr(p) {}
    
    void display() const {
        ptr->display();
    }
};

class MyClass {
public:
    void display() const {
        std::cout << "Display MyClass\n";
    }
};

int main() {
    Container<MyClass> container(new MyClass());
    container.display();
    return 0;
}
```

在这个例子中，`Container` 类模板使用了 `std::unique_ptr` 来管理指向 `T` 类型对象的指针。这样，当 `Container` 对象销毁时，`std::unique_ptr` 会自动释放内存。

### 3. 结合模板和函数对象

函数对象（functor）是一个重载了 `operator()` 的类对象，通常用于泛型编程。你可以将模板与函数对象结合，处理指向不同类型的指针。

```cpp
#include <iostream>

template <typename T>
class Printer {
public:
    void operator()(T* ptr) const {
        ptr->display();
    }
};

class MyClass {
public:
    void display() const {
        std::cout << "Display MyClass\n";
    }
};

int main() {
    MyClass obj;
    Printer<MyClass> printer;
    printer(&obj); // 使用函数对象调用display方法
    return 0;
}
```

在这个例子中，`Printer` 类模板定义了一个函数调用运算符，它接受一个指向 `T` 类型的指针并调用它的 `display` 方法。

### 4. 模板结合指针的优势

- **通用性**：模板结合指针可以处理任意类型的数据，代码复用性高。
- **类型安全**：模板结合指针可以进行编译时类型检查，确保类型安全。
- **简化内存管理**：结合智能指针，可以自动管理内存，避免内存泄漏和悬挂指针。

通过以上例子，你应该可以更好地理解如何结合模板和指针使用。`T* ptr` 这种写法表示模板参数 `T` 类型的指针，可以使你的模板类或模板函数处理任意类型的指针。
