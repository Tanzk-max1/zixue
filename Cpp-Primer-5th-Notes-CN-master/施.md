![image-20240525191239287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191239287.png)

不是所有的inline函数都会被编译器执行

在debug版本里面inline是不会被触发，只会咋release版本才会出现

内联函数和普通函数的区别，减少消耗，如果生成内联就不会生成函数符号

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191819982.png" alt="image-20240525191819982" style="zoom:80%;" />

可以进行查询





const

![image-20240525193453250](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525193453250.png)

可以通过指针进行修改，但是不推荐，因为不安全

![image-20240525211905648](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525211905648.png)

![image-20240525215017148](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525215017148.png)

单个元素的释放时不加中括号的，数组内存的释放才是加中括号的

![image-20240525220539564](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525220539564.png)

delete和free
free无论时释放一个元素内存，还是释放数组内存都是一个标准的函数调用，传入这个内存的起始地址就好了

左值引用和初识右值引用那个



引用必须初始化

指针可以不用初始化，最好初始化





函数重载部分

![image-20240604101959870](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604101959870.png)

产生规则不同



重载需要 注意什么

首先得在一个作用域

不在一个作用域就不存在重载

什么是函数重载？

![image-20240604154750624](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604154750624.png)

编译时期决定重载哪个版本

什么是多态？

静态（编译时期的）多态：函数重载

动态（运行时候的）多态：

c++在编译代码的时候产生函数符号的时候，是由这个函数名+参数类型组成的，c语言是不能重载的，产生函数符号的时候是由函数名来决定的



c++ 调用c ：无法直接调用

![image-20240605175858792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605175858792.png)

这样子就可以调用，把c函数的声明括在extern“c”里面



c 调用c ++无法调用的话，那就也是extern

![image-20240605180403463](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180403463.png)

__FILE__

__LINE__

只要是c++编译器，都内置了这个宏__cplusplus

![image-20240605180725445](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180725445.png)

![image-20240605181008848](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605181008848.png)

这种方式更加通用

在c和c++的编译器里面都是通用的

const修饰的变量不能够再作为左值，初始化完成后，值不能被修改。

**c里面可以不用初始化，c++必需初始化**

c里面const的不叫常量，叫做常变量

通过指针地址可以修改，const只是在表层不可以作为左值修改

c++的const

必须初始化的，叫常量

如果是通过传递的，那就叫常变量，因为初始值不是一个立即数，是一个变量

![image-20240605202005153](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605202005153.png)

得到的值是30 30 30



常量和普通变量的区别

1. 编译方式不同
2. 不能作为左值了

const修饰的量常出现的错误是：

1. 常量不能作为一个左值《= 直接修改常量的值
2. 不能把常量的地址泄露给一个普通的指针或者普通的引用变量《=可以间接修改



const和一级指针的结合：有两种情况

![image-20240605221540812](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605221540812.png)

通过指针解引用（*）指向内存的值，也就是说  p指向 a的地址， *p可以被复制，只是p被定为常量而已

const和指针转换的类型转换公式

int*   <=   const int*---->不允许的

const int*  <= int *  可以的



**const如果右边没有指针*的话，const是不参与类型的**

![image-20240605231656426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605231656426.png)

以上的都是正确的



const和多级指针结合的时候必须两边都有const，否则就是错误

const 和二级指针的结合

![image-20240605232838210](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605232838210.png)



![image-20240605233107574](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605233107574.png)

反正就是** 转 ** ，不能两边不匹配

如果是const后面有 * ，那么就直接变成 const*   《  *

这样子是可以的



![image-20240605234134074](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605234134074.png)

如果是这样会发生错误

const int ** <= int **,小变大了

改成const int *p = &a；就可以了



又或者const int* const* q = &p;那就是*q不可以赋值



在给定的代码中，我们有以下声明和初始化：

```cpp
int a = 10;
int *p = &a;
const int **q = &p;
```

让我们逐步解释这些声明和初始化的含义。

1. `int a = 10;`：声明并初始化一个整型变量 `a`，其值为 `10`。

2. `int *p = &a;`：声明并初始化一个整型指针 `p`，将 `p` 的值设置为 `a` 的地址。这意味着 `p` 指向了 `a`。

3. `const int **q = &p;`：声明并初始化一个指向指针的指针 `q`，该指针指向 `const int` 类型的数据。将 `q` 的值设置为指向 `p` 的地址。

现在我们来解释指针和 `const` 的传递。

- 一级指针 `p`：它是一个指向 `int` 类型数据的指针。通过 `p`，我们可以修改 `a` 的值。也就是说，`p` 是一个可变指针。

- 二级指针 `q`：它是一个指向指针的指针，指向 `const int` 类型的数据。这意味着 `q` 指向的指针 `p` 是一个指向 `const int` 类型数据的指针。通过 `q`，我们可以修改 `p` 的值，即改变 `p` 指向的地址。但是，由于 `q` 指向的指针 `p` 是指向 `const int` 类型的数据，所以我们不能通过 `q` 来修改 `a` 的值。

换句话说，指针的 `const` 传递是从右往左进行的。在这个例子中，`const` 限制了 `q` 指针指向的数据类型，即 `*p` 的类型，使其不能通过 `q` 修改数据。但是，我们仍然可以通过 `p` 来修改 `a` 的值，因为 `p` 不是 `const` 指针。

总结起来，一级指针 `p` 是可变指针，可以修改 `a` 的值，而二级指针 `q` 是指向 `const int` 类型的指针，可以修改 `p` 的值，但不能修改 `a` 的值。





![image-20240606221957506](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240606221957506.png)

类似这种，因为a是int，然后进行&a取地址，相当与int *，所以第二个语句没有毛病

然后总体的话是int* 和int*





引用和指针的区别

1. 左值引用和右值引用
2. 引用的示例

引用是一种更安全的指针

引用变量是把所引用的内存的地址先存下来

实参和形参是按照值传递

![image-20240608221002279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221002279.png)

有类型是引用，没类型是取地址

引用变量的时候会有一个解引用操作

![image-20240608221722288](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221722288.png)

第一个输出等于第三个输出

右值引用

![image-20240608222002322](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222002322.png)

![image-20240608222506499](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222506499.png)

这两种方式是一样的，都是右值引用，不同的是，下面哪个是被const定死了，上面那个是可以被修改的 

一个右值引用变量，本身是一个左值，在应用的时候必须产生临时量

右值引用

1. int && c =20;专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;
2. 右值引用变量本身是一个左值，只能用左值引用来引用他
3. 不能用一个右值引用变量，来引用一个左值

如果遇到很复杂的*&q = p；

那我们就进行还原，**q = &p；

如果p上面是常量指针，那就是错误的





详解new 和 delete

new 和malloc 

delete 和free

malloc  和 free 是c 的库函数

new和delete 是运算符

new 不仅可以做内存开辟，还可以做内存初始化操作

malloc开辟内存失败，是通过返回值和nullptr作比较；而new开辟内存失败，是通过抛出bad_alloc 类型的一场来判断的

```c++
int *q1 = new int[20]();
delete[]q1;
//这种写法是为了释放数组内存
//如果是释放一个元素的你直接delete就好了
int *p1 = new int[20]();
delete p1;
```

free是直接释放起始地址就好了，相对方便很多

new有多少种？

```c++
  //new有多少种？
  int *p1 = new int(20);//抛出异常
  cout << p1 <<endl;
  cout << *p1 <<endl;
  int *p2 = new (nothrow) int;//不抛出异常
  cout << p2 <<endl;
  cout << *p2 <<endl;
  const int *p3 = new const int(40);//在堆上生成常量
  cout << p3 <<endl;
  cout << *p3 <<endl;
  //定位new
  int data = 0;
  int *p4 = new (&data) int(50);//意思就是指定的内存块，定为int类型的值，值为50
  cout << data <<endl;
  
  return 0;

//输出结果
0xed4300
20
0xed4340
-1163005939
0xed4380
40
50
```

![image-20240609100951053](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609100951053.png)

OOP语言的四大特征是什么？

抽象，封装/隐藏，继承，多态

对象的内存是在栈上的

![image-20240609111710657](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609111710657.png)

对象的内存大小，只和成员变量有关

![image-20240610122225073](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122225073.png)

Windows查看内存情况👆



![image-20240610122440334](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122440334.png)

![image-20240610122918587](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122918587.png)

成员变量其实默认编译器会给我们加一个指针，只是我么可以不用手写，直接默认加上

类的成员方法一经编译，所有的成员方法参数都会加上一个this指针，接受调用该方法的一个地址

![image-20240610123054970](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610123054970.png)

函数的析构和构造相当于一个出栈的问题

先构造的后析构，析构函数不带参数，每个析构函数只能有一个，构造函数时可以带参数的，因此可以提供多个构造函数的重载

析构之后对象就不存在了

如果析构之后就会发生对内存的非法访问



堆上的对象什么时候进行析构，在new和delete这个的时候进行析构

delete相当于先析构掉对象，然后再释放内存

![image-20240612003839524](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612003839524.png)

在执行 `delete ps;` 时，会按照以下步骤进行操作：

1. 首先，会调用 `SeqStack` 类的析构函数 `~SeqStack()`，执行对象的清理操作，释放对象内部可能存在的资源。把指针外部的堆内存先释放掉
2. 然后，会释放 `ps` 所指向的动态分配的内存，这是通过 `new` 运算符分配的内存。然后再把对象的内存释放掉

注意两点：

1. 析构函数的调用是由 `delete` 操作自动触发的，不需要显式调用析构函数。
2. `delete` 操作会同时处理对象的析构和内存的释放，不需要显式调用 `free` 函数。

new相当于先内存开辟操作，然后对象构造操作

![image-20240612100044204](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612100044204.png)



#### 深拷贝与浅拷贝

三种类型的对象

在C++中，对象的内存可以分配在不同的区域，包括数据段（静态存储区）、堆和栈。这些区域在分配和释放对象内存以及对象的生命周期方面有所不同。

1. 数据段（静态存储区）：

   - 对象在编译时就分配了固定的内存空间，通常用于存储全局变量和静态成员变量。

   - 对象在程序运行期间一直存在，直到程序结束才会被释放。

   - 对象的构造和析构函数会在程序的启动和结束时自动调用。

     ```c++
     #include <iostream>
     
     // 在数据段中定义一个全局对象
     class GlobalObject {
     public:
         GlobalObject() {
             std::cout << "GlobalObject constructed!" << std::endl;
         }
     
         ~GlobalObject() {
             std::cout << "GlobalObject destroyed!" << std::endl;
         }
     };
     
     GlobalObject global; // 全局对象
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在主函数中定义一个静态对象
         static GlobalObject staticObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`GlobalObject` 类的对象 `global` 是在数据段中定义的全局对象。程序运行时，全局对象会在程序启动时构造，在程序结束时销毁。

2. 堆（动态存储区）：

   - 对象通过使用 `new` 运算符在堆上进行动态分配。

   - 对象的内存分配和释放需要显式地使用 `new` 和 `delete` 或 `new[]` 和 `delete[]` 进行操作。

   - 对象的生命周期由程序员手动管理，需要在不再需要时手动释放内存。

   - 对象在堆上分配的内存，可以在对象的任何作用域中访问。

     ```c++
     #include <iostream>
     
     class HeapObject {
     public:
         HeapObject() {
             std::cout << "HeapObject constructed!" << std::endl;
         }
     
         ~HeapObject() {
             std::cout << "HeapObject destroyed!" << std::endl;
         }
     };
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在堆上动态分配一个对象
         HeapObject* heapObj = new HeapObject();
     
         // 使用对象
     
         // 释放堆上分配的对象
         delete heapObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`HeapObject` 类的对象 `heapObj` 是通过 `new` 运算符在堆上进行动态分配的。程序员需要手动使用 `delete` 运算符释放对象所占用的内存。

3. 栈：

   - 对象通过直接声明或作为局部变量在栈上分配。
   - 对象的内存分配和释放是由编译器自动管理的，遵循栈的后进先出（LIFO）原则。
   - 对象的生命周期与其所在的作用域相对应，当作用域结束时，对象的内存会自动释放。
   - 对象在栈上分配的内存，只能在其声明的作用域内访问。

```c++
#include <iostream>

class StackObject {
public:
    StackObject() {
        std::cout << "StackObject constructed!" << std::endl;
    }

    ~StackObject() {
        std::cout << "StackObject destroyed!" << std::endl;
    }
};

void foo() {
    std::cout << "Inside foo function!" << std::endl;

    // 在函数中定义一个局部对象
    StackObject stackObj;

    std::cout << "Exiting foo function!" << std::endl;
}

int main() {
    std::cout << "Main function started!" << std::endl;

    foo();

    std::cout << "Main function ended!" << std::endl;

    return 0;
}
```

在这个例子中，`StackObject` 类的对象 `stackObj` 是在函数的栈帧中定义的局部对象。当进入函数 `foo` 时，局部对象被构造，当离开函数 `foo` 时，局部对象被析构。栈上的对象的生命周期与其所在作用域相关，无需手动释放内存。





如果拷贝的过程中，内存拷贝，指向的同一块内存指针被释放了，就会产生错误，因为按序析构，被指向的对象已经被释放， 所以报错

```c++
#include <iostream>
using namespace std;
class SeqStack
{
public:
//  void init(int size = 10)
//  {
//    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
//    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
//    _size = size; // 记录栈的总大小
//  }
  SeqStack(int size = 10)
  {
    cout << this << " SeqStack()" << endl;
    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
    _size = size; // 记录栈的总大小
  }
  ~SeqStack()
  {
    cout << this << " ~SeqStack()" << endl;
    delete[] _pstack; // 释放动态分配的数组内存
    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
  }

//  void release(){
//    delete[] _pstack; // 释放动态分配的数组内存
//    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
//  }

  void push(int val)
  {
    if (full()) // 检查栈是否已满，如果已满则进行扩容
      resize();
    _pstack[++_top] = val; // 将新元素 val 入栈，同时栈顶指针加一
  }

  void pop()
  {
    if (empty()) // 检查栈是否为空，如果为空则不执行出栈操作
      return;
    --_top; // 栈顶指针减一，表示将栈顶元素出栈
  }

  int top()
  {
    return _pstack[_top]; // 返回栈顶元素的值，但不修改栈顶指针
  }

  bool empty() { return _top == -1; } // 检查栈是否为空，栈空时栈顶指针为 -1

  bool full() { return _top == _size - 1; } // 检查栈是否已满，栈满时栈顶指针为总大小减一

private:
  int* _pstack; // 动态开辟数组，用于存储顺序栈的元素
  int _top;    // 指向栈顶元素的位置
  int _size;   // 数组扩容的总大小

  void resize()
  {
    int* ptmp = new int[_size * 2]; // 创建一个新的两倍大小的数组
    for (int i = 0; i < _size; ++i) {
      ptmp[i] = _pstack[i]; // 将旧数组中的元素复制到新数组
    }
    delete[] _pstack; // 释放旧数组的内存
    _pstack = ptmp; // 更新指针，指向新数组
    _size *= 2; // 更新栈的总大小为新数组的大小
  }
};
int main()
{
  SeqStack S;//没提供任何构造函数的时候，会位移生成默认的构造和析构函数，是空函数
  SeqStack s1(10);
  SeqStack s2 = s1;//拷贝构造函数，内存的拷贝
  SeqStack s3(s1);//拷贝构造函数
  return 0;//依次析构函数
}
```

![image-20240612102024130](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612102024130.png)

此处为浅拷贝，发生了错误，多个对象指向了同一个资源，同一个资源不可能释放两次，对象默认的拷贝构造，是做内存的数据拷贝

关键是对象如果占用外部资源，那么浅拷贝就出现问题了

```c++
SeqStack(const SeqStack &src)
  {
    cout << this << " &src" <<endl;
    _pstack = new int[src._size];
    for (int i = 0; i < src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这个拷贝构造函数实现了深拷贝，就是不单单复制内存指向，还要修改指针方向
```

修改一下，变成深拷贝，修改指针方向

![image-20240612103541138](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612103541138.png)

当使用 `&src` 这样的引用作为参数时，它适用于传递对象进行拷贝操作。这意味着，如果您传递给拷贝构造函数的参数是一个对象（例如 `MyClass` 类型），它将匹配并执行相应的拷贝操作。

例如，在拷贝构造函数 `MyClass(const MyClass& src)` 中，如果您调用 `MyClass obj1; MyClass obj2 = obj1;`，拷贝构造函数将使用 `obj1` 作为参数 `src`，并执行适当的深拷贝操作。

然而，如果您尝试使用一个不同的类型（例如 `int`）作为参数调用该拷贝构造函数，它将不会匹配该函数的参数类型，因为 `const MyClass&` 不匹配 `int` 类型。在这种情况下，编译器将寻找其他匹配的构造函数或转换函数。

因此，拷贝构造函数的参数类型和函数签名决定了它适用的情况。对于拷贝构造函数 `MyClass(const MyClass& src)`，它适用于接收 `MyClass` 类型的对象，并执行相应的拷贝操作。

而对于其他构造函数，如 `SeqStack(int size = 10)`，它使用 `int` 类型作为参数，适用于创建 `SeqStack` 对象，并初始化对象的大小。

综上所述，通过函数参数的类型和函数签名，可以确定函数适用的情况，从而实现不同类型的对象的创建和拷贝操作。

##### 深浅拷贝的对比

浅拷贝（shallow copy）只是简单地复制指针的值，使得两个对象的指针指向相同的内存块。这样，在两个对象之间进行修改时，它们会共享同一块内存，可能会导致意外的副作用。如果一个对象释放了共享内存，另一个对象仍然引用该内存，就会出现悬空指针的问题。

相比之下，深拷贝（deep copy）会为新对象分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。这样，两个对象就拥有各自独立的内存块，彼此之间的修改不会相互影响。

深拷贝通常涉及以下步骤：

1. 分配新的内存空间，用于存储新对象的资源。
2. 将原始对象的数据复制到新对象的内存空间中。
3. 如果有指针成员变量指向动态分配的内存，需要为新对象的指针成员变量分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。

深拷贝确保了新对象与原始对象具有独立的资源，修改一个对象不会影响另一个对象。

并非所有的对象都需要深拷贝。有些情况下，浅拷贝可能是合适的，例如当对象不包含动态分配的内存，或者两个对象确实需要共享相同的资源时（例如共享缓冲区的多个对象）。

面向对象的拷贝里面基本都是使用for循环，除非我确认我现在的资源数据，**没有占用外部资源**



```c++
void operator = (const SeqStack &src)
  {
    cout << " operator" << endl;
    if (this == &src)
      return;//防止自赋值
    delete[]_pstack;
    _pstack = new int[src._size];
    for (int i = 0; i <= src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这是为了给s2=s1这种操作做一个赋值函数，防止自赋值
//实现逻辑是防止自赋值，然后释放当前对象占用的外部资源，然后实现深拷贝的操作
```

如果前拷贝发生问题，需要做构造自定义的拷贝构造函数和赋值重载函数（s2=s1这种操作)

#### 类和对象代码实践

##### 普通构造函数（字符串or指针）

![image-20240612114147287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114147287.png)如果判断指针的话，对字符串操作的话，最好要判断是否为空

拷贝构造函数

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114343362.png" alt="image-20240612114343362" style="zoom:80%;" />

为什么+1呢，因为要给\0留个位置



析构函数

![image-20240612114507179](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114507179.png)

写完之后要给这个指针制成一个nullptr。

为什么？因为要防止野指针的存在



赋值重载函数

![](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114806184.png)

三步走（防止自赋值->delete->拷贝赋值

![image-20240612114846727](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114846727.png)

![image-20240612114933585](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114933585.png)

这样子写法就会出现，如果重载函数是void，就返回一个void，然后str3就无法接受数据了，或者说接受的是void

string& 是为了支持连续的operator操作

##### 尝试写循环队列

![image-20240612120802943](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612120802943.png)

![1718165564279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\1718165564279.png)

![image-20240612181716652](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612181716652.png)

![image-20240612182318377](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612182318377.png)

构造函数初始化列表

1.  效率：通过构造函数初始值列表，可以避免先调用默认构造函数创建对象，再在构造函数体内对成员变量进行赋值的额外开销。直接在构造函数初始值列表中初始化成员变量，可以减少不必要的对象初始化和赋值操作，提高效率。
2.  成员变量常量性：构造函数初始值列表可以用于初始化成员变量，即使这些成员变量被声明为 `const` 或引用类型。在构造函数体内部，无法对 `const` 成员变量进行赋值操作，所以使用构造函数初始值列表是唯一的选择。
3.  初始化顺序：构造函数初始值列表指定了成员变量初始化的顺序，可以确保成员变量按照指定的顺序进行初始化，而不是按照它们在类中声明的顺序。这对于成员变量之间存在依赖关系的情况很有用。

```c++
#include <cstring>
#include <string>
class Date {
private:
  int _year;
  int _month;
  int _day;
public:
  Date(int year, int month, int day) : _year(year), _month(month), _day(day) {}

  void printDate() {
    std::cout << "Date: " << _year << "-" << _month << "-" << _day << std::endl;
  }
};

class Goods {
private:
  char* _name;
  int _amount;
  double _price;
  Date _data;
public:
  Goods(char* name, int amount, double price, int year, int month, int day)
      : _data(year, month, day), _amount(amount), _price(price) {
    // 对 _name 进行内存分配，并将 name 的内容复制到 _name
    _name = new char[strlen(name) + 1];
    strcpy(_name, name);
  }

  void printDetails() {
    std::cout << "Name: " << _name << std::endl;
    std::cout << "Amount: " << _amount << std::endl;
    std::cout << "Price: " << _price << std::endl;
    _data.printDate();
      //可以将其理解为在 Goods 类的构造函数中，通过构造函数初始化列表对 _data 进行初始化。这个初始化过程是将参数 y、m 和 d 传递给 Date 类的构造函数，在 Date 类内部进行处理，然后返回一个 Date 类的对象，最终将这个对象赋值给 Goods 类的成员变量 _data。
  }

  ~Goods() {
    delete[] _name; // 释放 _name 的内存
  }
};

int main() {
  Goods item("Example Item", 10, 2.99, 2024, 6, 12);
  item.printDetails();

  return 0;
}
```

![image-20240612193533434](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612193533434.png)

相当于直接定义+初始化一把搞定---初始化列表

2的那种方式是麻烦一点的简单

成员变量的初始化与他们的定义的顺序有关，跟构造函数初始化列表中出现的先后顺序无关



##### 掌握类的各种成员方法以及区别

static静态成员变量一定要在类外定义和初始化

![image-20240613212922404](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240613212922404.png)

👆，因为比如一个count，那你每个类对象都会调用一个count，这样子事不行的，所以需要吧他放出来做静态成员变量，但是，尽可能不要用太多全局变量

else 静态成员变量是在栈上的，不属于对象的，属于类级别的，他相当于就是个全局变量，只是作用在类里面而已

![image-20240614204038397](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204038397.png)

区别是普通方法存在this指针，静态方法是没有this指针的

静态方法是不需要对象的，不产生this指针，就不需要对象的地址，可以在作用域里面调用它

static静态成员方法

![image-20240614204812277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204812277.png)

普通成员方法

![image-20240614204829141](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204829141.png)

常成员方法

![image-20240614205207642](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205207642.png)

const类型的形参👆

常对象的方法必须使用常对象的指针

只要是只读操作的成员方法，一律定义成常成员方法

const常成员方法-》const CGOODS *this

1. 属于类的作用域
2. 调用依赖一个对象，普通对象或者常成员对象都可以
3. 可以调用访问对象的私有成员，但是只能读，不能写

![image-20240614205743776](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205743776.png)

三种成员方法总结

![image-20240614205823292](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205823292.png)

如果定义一个普通类的成员变量，我们需要添加一个类的作用域

指向一个普通成员的时候一定要带上对象

![image-20240614210732783](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614210732783.png)

指向成员方法的指针

一定要依赖对象

![image-20240614212710062](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614212710062.png)

如何定义函数指针指向类的static成员方法

```c++
#include <iostream>

class MyClass {
public:
    static void staticMethod(int value) {
        std::cout << "Static method called with value: " << value << std::endl;
    }
};

int main() {
    // 定义函数指针类型
    typedef void (*StaticMethodPtr)(int);

    // 声明并初始化函数指针，指向类的静态成员方法
    StaticMethodPtr ptr = &MyClass::staticMethod;

    // 使用函数指针调用静态成员方法
    ptr(42);

    return 0;
}
```





#### 模板

##### 理解模板

c++模板的意义是：可以对类型也可以进行参数化了

int sum(int a,int b){return a+b;}

函数模板《=是不进行编译的,因为类型不知道

模板的实例化《= 函数调用点进行实例化

模板函数《《=才是编译器所编译的



模板类型参数 typename/class

模板非类型参数



模板的实参推演==》可以根据用户传入的实参类型进行推断

模板的特例化（专用化）

模板函数，模板的特例化，非模板函数的重载关系







![image-20240616140824969](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616140824969.png)

模板函数实例化只用实例一次

如果是这里的compare函数是（10.5，20）；

![image-20240616141123517](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616141123517.png)

这样子会导致错误，类型错误

所以需要compare<int>(30,40.5);这样子，强制转换了一下

所以在这里说，函数模板是不参加编译的

在调用点进行实例化，注重功能实现

对于某些类型来说，编译器根据用户给的数据进行的推断是有错误的-》这个时候需要进行特例化

比如针对compare模板函数，提供const char*类型特例化版本

![image-20240616143827353](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143827353.png)

还有非模板函数

![image-20240616143958255](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143958255.png)

这三个的共存时候，比如compare（"aaa","bbb");

会优先调用非模板函数

如果是

![image-20240616144141339](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616144141339.png)

则优先调用特例化模板，看他有没有指明模板的使用，优先把compare处理成函数名字，没有的话，才去找compare模板

模板声明

![image-20240616152024668](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152024668.png)

因为模板是不编译的，所以别再一个文件定义了，别的文件就直接使用，你得进行声明

所以一般是放在头文件中，然后再源文件中使用include包含

![image-20240616152512220](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152512220.png)





##### 函数模板

模板的非类型参数，都是常量，只能使用而不能修改

这里面只能用整形的int，char，short，long

![image-20240616153659948](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616153659948.png)

指定类型，常量，

函数的非类型模板参数必须是整数类型（整数或者地址/引用都可以）都是常量

 ![image-20240616154037174](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616154037174.png)

##### 

##### 类模板

```c++
template<typename T>
class SeqStack // 模板名称+类型参数列表=类名称
{
public:
    //构造和析构函数名不用加<T> ,其他的出现模板的地方都加上类型参数列表
  SeqStack(int size=10);
  ~SeqStack()；
  SeqStack(const SeqStack<T> &stack);
  
private:
  T *_pstack;
  int _top;
  int _size;

};
int main()
{
  return 0;
}
```

如果写成员方法，只读操作的话，那就const加上限制，这样子普通对象能调用，常对象也能调用

赋值三部曲

1. 防止自赋值![image-20240616204121844](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204121844.png)

2. 释放原来的空间![image-20240616204145882](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204145882.png)
3. 根据大小开辟空间![image-20240616204206595](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204206595.png)

以上是赋值运算符的重载

```c++
T *ptmp = new T[_size * 2];
//像这样子的写法，就是一个模板类的使用，T作为一个占位符，将在具体实例化时由实际类型进行使用，如果是int那就是编译器自动确认为int
```

class类名的时候会实例化一个类

##### 简单介绍下类模板的选择性实例化

在 C++ 中，类模板的选择性实例化（Explicit Specialization）和部分实例化（Partial Specialization）是非常有用的特性，允许你为某些特定类型或类型组合提供特化的实现，而无需影响到其他类型的实现。以下是对这两种技术的详细讲解：

###### 1. 类模板的完全特化（Explicit Specialization）

完全特化是为特定类型提供完全不同的实现。在这种情况下，你可以为模板参数的特定类型定义一个特殊版本的类。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化版本，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;
    MyClass<int> obj2;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

###### 2. 类模板的部分特化（Partial Specialization）

部分特化允许你为模板参数的某些特定组合提供特化实现，而不需要完全特化整个模板。部分特化比完全特化更灵活，因为它只需特化部分参数。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T, typename U>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 部分特化，针对第二个参数为 int 的情况
template <typename T>
class MyClass<T, int> {
public:
    void display() {
        std::cout << "Partial specialization: second parameter is int" << std::endl;
    }
};

// 部分特化，针对第一个参数为 int 的情况
template <typename U>
class MyClass<int, U> {
public:
    void display() {
        std::cout << "Partial specialization: first parameter is int" << std::endl;
    }
};

int main() {
    MyClass<double, double> obj1;
    MyClass<double, int> obj2;
    MyClass<int, double> obj3;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Partial specialization: second parameter is int
    obj3.display();  // 输出: Partial specialization: first parameter is int

    return 0;
}
```

###### 选择性实例化的应用

选择性实例化在以下情况下特别有用：

1. **优化特定类型**：为特定类型提供优化实现。例如，针对常用的 `int` 类型，可以提供更高效的算法或数据结构。
2. **处理特殊行为**：某些类型可能需要特殊处理。例如，处理指针类型时可能需要特化模板以避免常见的错误或提供特殊的行为。
3. **类型特性**：某些类型可能具有不同的特性，需要不同的实现来处理。例如，浮点数和整数的处理方式可能有所不同。

##### 总结

类模板的选择性实例化通过完全特化和部分特化提供了灵活性，允许你为特定类型或类型组合提供特化实现。理解和掌握这两个特性，可以使你的模板代码更加通用和高效，同时在需要时提供特定的优化和行为。



### 简单讲解模板类，类模板，实例化

在C++中，类模板、模板类、和类模板的实例化是模板编程的重要概念。这些概念之间的关系如下：

##### 类模板（Class Template）

类模板是一种蓝图或模板，用于定义一个可以处理多种不同数据类型的类。它允许你编写通用的类定义，并在需要时使用具体的类型进行实例化。

##### 定义类模板

```cpp
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};
```

- `template <typename T>`：这是模板参数列表，告诉编译器这是一个模板类，`T`是一个占位符，表示某种类型。
- `class MyClass`：定义了一个类模板`MyClass`，这个类可以处理任何类型`T`。

##### 模板类（Template Class）

当类模板使用具体类型进行实例化时，生成的类称为模板类。模板类是类模板的具体化版本，每个模板参数对应一个具体类型。

##### 实例化模板类

```cpp
MyClass<int> intObj;     // 实例化一个模板类，T 被替换为 int
MyClass<double> dblObj;  // 实例化一个模板类，T 被替换为 double
```

- `MyClass<int>`：表示一个模板类，`T`被具体化为`int`类型。
- `MyClass<double>`：表示一个模板类，`T`被具体化为`double`类型。

##### 类模板的实例化（Instantiation of Class Template）

类模板的实例化是将类模板用具体的类型参数替换模板参数，从而生成模板类的过程。这个过程可以是显式的（用户在代码中明确指定类型）或隐式的（编译器自动推导类型）。

#### 显式实例化

```cpp
MyClass<int> intObj;     // 显式实例化
MyClass<double> dblObj;  // 显式实例化
```

##### 隐式实例化

当类模板用于函数模板中时，编译器可以根据传递的参数类型自动推导模板参数，从而隐式实例化类模板。

```cpp
template <typename T>
void function() {
    MyClass<T> obj;  // 隐式实例化，编译器根据函数模板的参数推导 T 的类型
}
```

##### 关系总结

1. **类模板**：是一种通用的类定义，使用模板参数（如`typename T`）来表示将来的类型。它是一个蓝图，定义了类的结构和行为，但没有具体化任何类型。

2. **模板类**：是类模板经过实例化后的具体版本，模板参数被替换为具体类型。例如，当类模板`MyClass`使用`int`类型实例化时，就得到了一个模板类`MyClass<int>`。

3. **类模板的实例化**：是将类模板中的模板参数替换为具体类型的过程。可以通过显式指定类型来实例化（如`MyClass<int> intObj`），也可以在使用模板类时由编译器自动推导。

##### 示例

完整的示例展示了类模板的定义、实例化和生成模板类的过程：

```cpp
#include <iostream>

// 定义类模板
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化类模板，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;  // 使用 double 实例化类模板，生成模板类 MyClass<double>
    MyClass<int> obj2;     // 使用 int 实例化类模板，生成模板类 MyClass<int>，并使用特化版本

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

在这个示例中：
- `MyClass`是一个类模板。
- `MyClass<double>`和`MyClass<int>`是模板类。
- `MyClass<double> obj1`和`MyClass<int> obj2`是类模板的实例化过程。

通过理解这三个概念及其关系，你可以更好地利用模板编程的强大功能来编写通用、灵活和高效的代码。





##### 容器空间配置器，在vector里面的

将内存开辟和析构分开

析构容器里面的元素，然后释放指针指向的容器里面的堆内存

在容器里面删除一个元素应该是 析构掉这个元素的对象，而不是释放这个元素的堆内存

###### 主要是做四件事

1. 内存开辟
2. 内存释放
3. 对象构造
4. 对象析构





#### 运算符重载

##### 学习复数类CComplex

* 不能返回一个局部对象或者局部变量的指针，或者引用等

```c++
//c++的运算符重载

class CComplex
{
public:
  CComplex(int r = 0,int i = 0)
      :mreal(r),mimage(i){}
  //CComplex operator+(const CComplex &src)
  //{
//    CComplex comp;
//    comp.mreal = this->mreal + src.mreal;
//    comp.mimage = this->mimage + src.mimage;
//    return comp;//不能返回一个局部对象或者局部变量的指针，或者引用等
  //    return CComplex(this->mreal + src.mreal,
   //             this->mimage + src.mimage);
  //}
  //因为已经由全局的了，可以屏蔽掉局部的函数
  CComplex operator++(int)
  {
    CComplex comp = *this;
    mreal += 1;
    mimage += 1;
    return comp;
    //为什么这个不可以返回引用呢，因为这是一个局部对象，所以不能这样子
  }
  CComplex& operator++()//返回辅助对象的一个引用，可以不产生临时对象
  {
    mreal += 1;
    mimage += 1;
    return *this;
  }
  void operator+=(const CComplex &src)
  {
    mreal += src.mreal;
    mimage += src.mimage;

  }
  void show(){cout << "real: " << mreal << " image: " << mimage << endl;}
private:
  int mreal;
  int mimage;
  friend CComplex operator+(const CComplex &lhs,const CComplex &rhs);
  friend ostream& operator<< (ostream &out ,const CComplex &src);
  friend istream& operator >> (istream &in ,CComplex &src);
};
CComplex operator+(const CComplex &lhs,const CComplex &rhs)
{
  cout << "nice" << endl;
  return CComplex(lhs.mreal + rhs.mreal,lhs.mimage+rhs.mimage);
}//全局的方法

ostream& operator<< (ostream &out ,const CComplex &src)
{
  out << "mreal: " << src.mreal << "mimage: " << src.mimage <<endl;
  return out;
}
istream& operator >> (istream &in ,CComplex &src)
{
  in >> src.mreal >> src.mimage;
  return in;

}//输入运算符的重载
int main(){
  CComplex complex(10,10);
  CComplex complex1(20,20);
  //加法运算符的重载函数
  CComplex complex2 = complex + complex1;
  complex2.show();
  CComplex complex3 = complex + 20;//相当于comp.operator + (20) int ->CCom CComplex(int);
  complex3.show();

//  CComplex complex4 =  20+complex ;
                                   // 这个就不行了，30在这里面没有生成形参对象，所以不存在生成临时对象
  //编译器在做对象运算的时候，会调用对线的运算重载函数（优先调用成员方法）；如果没有成员方法，那就在全局做哟ing与找合适的运算符重载函数
    CComplex complex4 =  20+complex ;
    complex4.show();
    complex4 = complex++;//++ 和-- 是单目运算符
    complex.show();
    complex4.show();
    complex4 = ++complex;
    complex.show();
    complex4.show();
    cout << "hh " << endl;

    complex2 +=complex;
    complex.show();
    complex2.show();
    cin >> complex >> complex1;
    cout << complex << complex1 << endl;

}
template<typename T>
void show(T a)
{
  cout << a << endl;

}
```



##### 单目运算符---->  ++ 和 --

在C++中，`++`运算符可以通过运算符重载进行自定义，以便适用于用户定义的类型。`++`运算符有两种形式：前置形式（prefix）和后置形式（postfix）。它们可以通过成员函数或友元函数来重载。下面我们分别介绍这两种形式的重载方法。

###### 前置形式（Prefix）

前置形式的运算符重载用于实现`++obj`的行为。其重载函数通常返回对自身的引用。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    ++counter;
    counter.display();  // 输出: Counter value: 1

    return 0;
}
```

在这个示例中，我们重载了前置形式的`++`运算符，使其对`value`执行自增操作，然后返回当前对象的引用。

###### 后置形式（Postfix）

后置形式的运算符重载用于实现`obj++`的行为。其重载函数需要一个整数类型的哑参数来与前置形式区分开。后置形式的运算符重载通常返回对象的副本。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    // 重载后置 ++ 运算符
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    counter++;
    counter.display();  // 输出: Counter value: 1

    ++counter;
    counter.display();  // 输出: Counter value: 2

    return 0;
}
```

在这个示例中，我们重载了后置形式的`++`运算符。该运算符先保存当前对象的副本，执行自增操作，然后返回保存的副本。

###### 总结

- 前置形式的`++`运算符重载不带参数，返回当前对象的引用。
- 后置形式的`++`运算符重载带有一个整数哑参数，返回自增前对象的副本。

通过重载这两种形式的`++`运算符，我们可以为自定义类型实现与内置类型类似的自增操作。





![image-20240618002923453](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240618002923453.png)



数组底层其实都是char类型，所以需要用char类型返回

![image-20240621004352323](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004352323.png)

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135342315.png" alt="image-20240620135342315" style="zoom:80%;" />

比如这里，因为我要返回括号里面的数字，所以重载了 [] ，然后返回，返回对象，可以修改

如果是加const在开头则不允许修改

![image-20240620135601765](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135601765.png)





const char* c_str

![image-20240620230405890](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620230405890.png)

![image-20240620233018119](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233018119.png)

这种foreach的做法还是通过迭代器完成的

![image-20240620233136189](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233136189.png)

哈希和红黑树不适合用[]这个，这是支持随机存取的，其他的不支持





#### 迭代器失效问题

![image-20240621001905994](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621001905994.png)

非法操作👆

原因是这样，在你完成一次删除之后，会导致在这个范围内的迭代器失效了

![image-20240621002347928](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002347928.png)

![image-20240621002502908](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002502908.png)

在删除和增加之后的迭代器会失效的，所以需要进行break

扩容也会发生失效，原来的迭代器就全部失效

进行这些操作之后，it就失效了

新的iteratr返回当前位置，后边的元素会往前挪，**那就是在容器的过程中，如果需要增加或者删除，就是连续多次的操作，一定需要进行更新**

![image-20240621004130942](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004130942.png)

这里需要添加两次，从而完成添加



以下是迭代器的初始条件

![image-20240621004609197](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004609197.png)



2. 不同迭代器是不能进行比较的

![image-20240621004510557](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004510557.png)

![image-20240621004905995](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004905995.png)

👆迭代器失效增加代码

![image-20240621101634450](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621101634450.png)

通过这段代码，我们新生成容器某一个位置的迭代器





帮助理解，删除末尾元素的pop_back，我们可以理解成删除末尾元素，然后让迭代器失效

![image-20240621102156449](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102156449.png)

![image-20240621102226757](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102226757.png)

verify做检查迭代器

如果发现这个迭代器失效了，就把这个容器指针置为空指针





检查迭代器有效性

![image-20240621102711792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102711792.png)



## 迭代器失效问题总结

在容器中进行删除和插入操作时，迭代器失效（iterator invalidation）是一个常见的问题。迭代器失效意味着在删除或插入操作之后，先前有效的迭代器可能会变得无效，不能再被安全地使用。如果在删除和插入操作之后不进行适当处理而继续使用这些迭代器，可能会导致程序崩溃或未定义行为。

### 迭代器失效的原因

#### 删除操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 当从 `std::vector` 或 `std::deque` 中删除元素时，**删除位置之后的所有迭代器**都会失效，因为元素需要被移动以填补空隙。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中删除元素时，只有指向被删除元素的迭代器会失效，其他迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中，删除操作只会使指向被删除元素的迭代器失效。

#### 插入操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 在 `std::vector` 或 `std::deque` 中插入元素时，如果插入导致容器重新分配内存，则所有迭代器都会失效。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中插入元素时，所有迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中插入元素不会使任何现有的迭代器失效。

### 处理迭代器失效的方法

1. **删除操作后的处理**:
   - 使用删除操作返回的新迭代器继续循环。
   - 在 `std::list` 这样的链表中，使用删除元素前的迭代器来继续操作。

2. **插入操作后的处理**:
   - 在序列容器中插入元素后，重新获取容器的迭代器。

### 示例代码

#### 删除操作

假设我们有一个 `std::vector<int>`，需要删除所有的偶数元素：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end();) {
        if (*it % 2 == 0) {
            it = vec.erase(it);  // erase 返回一个指向被删除元素之后的迭代器
        } else {
            ++it;
        }
    }

    // 输出剩余元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
//先检查这个，使其迭代器失效然后析构当前的对象，然后再构造一个新对象出来，然后把元素进行拷贝，完成拷贝构造，然后迭代器++
```

![image-20240621104413117](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621104413117.png)

#### 插入操作

假设我们有一个 `std::vector<int>`，需要在偶数前面插入 -1：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it % 2 == 0) {
            it = vec.insert(it, -1);  // insert 返回一个指向插入元素的迭代器
            ++it;  // 跳过新插入的元素
        }
    }

    // 输出修改后的元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
```

### 总结

- **删除操作**: 在删除元素后，必须使用 `erase` 返回的新迭代器继续循环。
- **插入操作**: 在插入元素后，必须更新迭代器以继续循环。

在容器进行插入和删除操作时，正确处理迭代器非常重要，以避免迭代器失效导致的程序错误。

## 深入理解new和delete原理

![image-20240621114916231](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621114916231.png)

```c++
Test *p2 = new Test[5];
delete []p2;

```

这看上去消耗了5*4=20个字节，实际上还要多一个，因为还得存储多一个，用来存储对象的个数5个

![image-20240621154742278](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621154742278.png)

然后存储完成之后，指针返回的地址是哪个呢，是0*104这个

，因为不需要让用户知道你的开辟内存地址，只需要知道你第一个对象的地址就好了

![image-20240621155521021](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155521021.png)

总结：free和delete的区别

![image-20240621155741578](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155741578.png)





对象池部分

![image-20240621172300956](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621172300956.png)

节点归还就直接吧节点归还的地方用作首届点





## 继承的本质

**继承的本质：**

1. 代码的复用![image-20240622093809546](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622093809546.png)在这个派生类下面的成员也可以是使用的，可以定义多一个ma，不会发生冲突，只要在这个作用域里面使用就行

2. 组和类之间的关系：a：组合 a part of ... 一部分关系 
   继承 b: a kind of 。。。 一种关系

3. | 继承方式                                                     | 基类的访问限定                                               | 派生类的访问限定                       | (main)外部的访问限定 |
   | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- | -------------------- |
   | public                                                       | public<br />protected<br />private(只有自己或者友元才能访问) | public<br />protected<br />不可见的    | Y<br />N<br />N      |
   | protected<br />（基类成员的访问限定，在派生类里面不可能超过继承方式的） | public<br />protected<br />private                           | protected<br />protected<br />不可见的 | N<br />N<br />N      |
   | private                                                      | public<br />protected<br />private                           | private<br />private<br />不可见的     | N<br />N<br />N      |

   **Public继承**：

   - 公有成员（public members）在派生类中保持为公有。
   - 保护成员（protected members）在派生类中保持为保护。
   - 私有成员（private members）在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Protected继承**：

   - 公有成员在派生类中变为保护。
   - 保护成员在派生类中保持为保护。
   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Private继承**：

   - 公有成员在派生类中变为私有。

   - 保护成员在派生类中变为私有。

   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

     **总结**：

     1. 外部只能访问对象public对象成员，另外两个类型的成员无法直接访问
     2. 在继承结构中，派生类可以继承过来的Private的成员，但是派生类却无法直接访问
     3. Protected 和 Private的区别？在基类中定义的对象，想被派生类访问，但是不想被外部访问，那么在基类中，把相关成员定义成Protected保护的，如果派生类和外部都不打算访问，那么在基类中，就把相关成员定义成Private私有的

**默认的继承方式是什么：**

要看派生类是class定义的，还是struct定义的？

class定义派生类，默认继承方式是Private

struct定义派生类，默认继承方式是Public

##### 问题合集

1. 派生类从继承可以继承来所有成员（变量和方法），除过构造函数和析构函数
   **派生类如何初始化从基类继承来的成员变量呢？**

   解答：通过调用基类相应的构造函数来初始化
   派生类的构造函数和析构函数，负责初始化和清理派生类部分
   派生类从基类继承来的成员的初始化和清理由谁来负责呢？是由基类的构造和析构函数来负责
   派生类对象构造和析构的过程是：

   ![image-20240622103246769](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622103246769.png)

   1. 派生类调用基类的构造函数，初始化从基类继承来的对象
   2. 调用派生类自己的构造函数，初始化派生类自己特有的成员
   3. 调用派生类的析构函数，释放派生类成员可能调用的外部资源（堆内存，文件）
   4. 调用基类的析构函数，释放派生类内存，从基类继承来的成员可能占用的外部资源（堆内存，文件）

## 重载，隐藏，覆盖

1. 重载关系：一组函数要重载，必须处于同一个作用域当中，而且函数名字相同，参数列表不同

2. 隐藏（作用域的隐藏）关系：在继承结构当中，派生类的同名成员，把基类的同名成员给隐藏调用了

   ===============================================================================

   ![image-20240622111630005](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622111630005.png)

![image-20240622113023118](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622113023118.png)

继承结构中的类型转换

1. 基类指针可以指向派生类对象，但只能访问基类部分的成员。 
2. 派生类指针指向基类对象会导致内存非法访问，因为指针类型与对象实际类型不匹配。 
3. 类型转换默认支持从派生类到基类的转换，但反向转换是不安全的。



**覆盖 **

基类和派生类的方法，返回值，函数名以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理程序函数，他们之间成为覆盖关系



## 虚函数，静态绑定和动态绑定

静态调用

![image-20240622115313795](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115313795.png)

![image-20240622115449046](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115449046.png)

总结一：

一个类里面定义了虚函数，那么编译阶段，编译器给这个类类型产生了一个位移的Vftable虚函数标，虚函数标重主要存储的内容是RTTI指针和虚函数的地址

![image-20240622115907217](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115907217.png)

![image-20240622134440166](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622134440166.png)

总结四：如果派生类中的方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，而且派生类的方法是virtual虚函数，那么派生类的这个方法，自动处理成虚函数

覆盖指的是虚函数表里面的覆盖

![image-20240622141121060](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141121060.png)

动态绑定--》指的是函数的调用

![image-20240622141428550](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141428550.png)

不带参数的先绑定

![image-20240622142316447](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622142316447.png)

![image-20240622143116277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622143116277.png)

判断这些函数指向的时候的思路



### 静态绑定和动态绑定

**静态绑定**（Static Binding）和**动态绑定**（Dynamic Binding）是两种方法，用来在程序运行时确定函数调用的具体实现。

1. **静态绑定**：
   - 也称为早绑定（Early Binding）。
   - 在编译时确定函数调用。
   - 非虚函数和普通函数通常使用静态绑定。

2. **动态绑定**：
   - 也称为晚绑定（Late Binding）。
   - 在运行时确定函数调用。
   - 通过虚函数实现。

### 虚函数

**虚函数**是C++中的一种特殊成员函数，可以在基类中声明，并在派生类中重写（override）。虚函数使得在运行时通过基类指针或引用调用派生类的实现成为可能，这就是动态绑定的实现方式。

### 示例

让我们通过一个具体的例子来说明这些概念：

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    // 基类中的虚函数
    virtual void speak() {
        cout << "Animal speaks" << endl;
    }
    
    // 基类中的非虚函数
    void run() {
        cout << "Animal runs" << endl;
    }
};

class Dog : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Dog barks" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Dog runs" << endl;
    }
};

class Cat : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Cat meows" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Cat runs" << endl;
    }
};

int main() {
    Animal* animalPtr;
    Dog myDog;
    Cat myCat;

    // 静态绑定：调用非虚函数
    myDog.run(); // 输出 "Dog runs"
    myCat.run(); // 输出 "Cat runs"

    // 动态绑定：调用虚函数
    animalPtr = &myDog;
    animalPtr->speak(); // 输出 "Dog barks"

    animalPtr = &myCat;
    animalPtr->speak(); // 输出 "Cat meows"

    return 0;
}
```

### 解释

1. **Animal 类**：
   - `Animal` 是基类，包含一个虚函数 `speak()` 和一个非虚函数 `run()`。
   - `virtual` 关键字告诉编译器这个函数可以在派生类中重写。

2. **Dog 类和 Cat 类**：
   - `Dog` 和 `Cat` 是从 `Animal` 派生的类。
   - 它们都重写了 `speak()` 和 `run()` 函数，提供自己的实现。

3. **静态绑定**：
   - 当调用 `myDog.run()` 或 `myCat.run()` 时，编译器在编译时已经确定了具体调用 `Dog::run()` 或 `Cat::run()`。
   - 因此，这些调用是静态绑定的。

4. **动态绑定**：
   - 当通过基类指针 `animalPtr` 调用虚函数 `speak()` 时，编译器在运行时根据指针指向的具体对象类型（`Dog` 或 `Cat`）确定调用哪个 `speak()` 实现。
   - 这种在运行时确定函数调用的机制就是动态绑定。

### 动态绑定的实现

动态绑定通过虚函数表（vtable）和虚指针（vptr）实现。每个包含虚函数的类在编译时都会生成一个虚函数表，表中存储了该类的虚函数的地址。每个对象包含一个指向其类的虚函数表的指针。当通过基类指针调用虚函数时，程序会通过虚指针找到虚函数表，再从表中找到具体的函数地址并调用它。

### 总结

- **静态绑定**：在编译时确定函数调用，通常用于非虚函数。
- **动态绑定**：在运行时确定函数调用，通常用于虚函数，通过虚函数表实现。
- **虚函数**：使动态绑定成为可能，允许在基类中声明函数，并在派生类中重写。

理解这些概念可以帮助你更好地掌握面向对象编程和多态性的实现，从而编写出更灵活和可扩展的代码。





**问题一:哪些函数不能实现成虚函数?**
虚函数依赖:

1. 虚函数能产生地址，存储在vftable当中虚函数地址)

2. 对象必须存在(vfptr ->vftable ->虚函数地址）

   构造函数

   1. virtual+构造函数 NO!

      构造函数中(调用的任何函数，都是静态绑定的)调用虚函数，也不会发生静态绑定

      派生类对象构造过程   

      1. 先调用的是基类的构造函数

      2.  才调用派生类的构造函数

         **static静态成员方法  No!   virtual + static**

基类的析构函数是virtual虚函数，那么派生类的析构函数自动成为虚函数，

**问题二 ：虚析构函数，析构函数调用的时候对象是存在的！**

什么时候把基类的析构函数必须实现成虚函数?

基类的指针(引用)指向堆上new出来的派生类对象的时候， delete pb(基类的指针）

它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用

![image-20240622212335687](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622212335687.png)

## 什么时候动态绑定，什么时候静态绑定？

在C++中，是否使用动态绑定取决于是否通过基类指针或引用调用虚函数。让我们深入探讨何时使用静态绑定，何时使用动态绑定，以及虚函数在什么情况下不会触发动态绑定。

### 静态绑定 vs. 动态绑定

**静态绑定（Static Binding）**：
- 在编译时确定函数调用。
- 适用于普通函数和非虚函数。
- 适用于通过对象直接调用函数的情况。

**动态绑定（Dynamic Binding）**：
- 在运行时通过虚函数表确定函数调用。
- 适用于虚函数。
- 适用于通过基类指针或引用调用虚函数的情况。

### 何时使用动态绑定

动态绑定发生在以下情况下：
1. **通过基类指针或引用调用虚函数**：
   - 当使用基类指针或引用调用虚函数时，编译器无法在编译时确定具体调用的是哪一个派生类的实现，因此在运行时通过虚函数表进行解析。

```cpp
class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 动态绑定
}
```

2. **多态性**：
   - 当我们希望在运行时根据对象的实际类型执行不同的操作时，使用动态绑定。

### 何时使用静态绑定

静态绑定发生在以下情况下：
1. **非虚函数调用**：
   - 对于非虚函数，编译器在编译时已经知道该调用哪个函数实现，因此直接绑定。

```cpp
class Base {
public:
    void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 静态绑定
}
```

2. **通过对象直接调用虚函数**：
   - 当通过具体对象（而不是基类指针或引用）调用虚函数时，编译器在编译时也可以确定具体的调用。

```cpp
Derived d;
d.show(); // 静态绑定，因为对象类型已知
```

### 虚函数不触发动态绑定的情况

有几种情况下，尽管函数声明为虚函数，但不会触发动态绑定：

1. **通过对象直接调用虚函数**：
   - 如果你使用具体对象调用虚函数，编译器已经知道该对象的类型，因此不需要在运行时解析。

```cpp
Base b;
b.show(); // 静态绑定，调用 Base::show
Derived d;
d.show(); // 静态绑定，调用 Derived::show
```

2. **在构造函数或析构函数中调用虚函数**：
   - 在构造函数或析构函数中调用虚函数时，会使用当前类的版本，而不是派生类的版本。这是因为在构造函数和析构函数执行期间，派生类的部分可能尚未初始化或已经销毁。

```cpp
class Base {
public:
    Base() {
        show(); // 调用 Base::show
    }
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    Derived() : Base() {}
    void show() override {
        cout << "Derived::show" << endl;
    }
};

Derived d; // 构造函数期间调用 Base::show
```

### 例子总结

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }

    void display() {
        cout << "Base::display" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }

    void display() {
        cout << "Derived::display" << endl;
    }
};

int main() {
    Base b;
    Derived d;
    Base* basePtr = &d;

    b.show();          // 静态绑定，调用 Base::show
    d.show();          // 静态绑定，调用 Derived::show
    basePtr->show();   // 动态绑定，调用 Derived::show

    b.display();       // 静态绑定，调用 Base::display
    d.display();       // 静态绑定，调用 Derived::display
    basePtr->display(); // 静态绑定，调用 Base::display (因为 display 不是虚函数)

    return 0;
}
```

### 结论

- **静态绑定**：在编译时确定函数调用。适用于非虚函数或通过对象直接调用虚函数的情况。
- **动态绑定**：在运行时确定函数调用。适用于通过基类指针或引用调用虚函数的情况。
- 虚函数在特定情况下（如通过对象直接调用或在构造函数和析构函数中调用）不会触发动态绑定。

![image-20240622220619120](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220619120.png)

![image-20240622220417219](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220417219.png)

### **解释在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本。**

理解 "在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本" 需要深入了解 C++ 的对象构造和虚函数的工作机制。以下是详细解释：

#### 背景知识

**虚函数表（vtable）**：
- 每个包含虚函数的类都有一个虚函数表（vtable），表中存储了该类的虚函数指针。
- 每个对象都有一个隐藏的指针（vptr），指向它所属类的虚函数表。

**动态绑定**：
- 当通过基类指针或引用调用虚函数时，实际调用的函数在运行时通过虚函数表决定。这称为动态绑定。

#### 构造函数和析构函数中的行为

#### 构造函数

1. **构造对象的顺序**：
   - 当一个派生类对象被构造时，首先会调用基类的构造函数，然后再调用派生类的构造函数。
   
2. **虚指针（vptr）的设置**：
   - 在调用基类构造函数时，对象的虚指针（vptr）指向基类的虚函数表。
   - 只有在派生类的构造函数开始执行时，对象的虚指针（vptr）才会被更新为指向派生类的虚函数表。

#### 析构函数

1. **析构对象的顺序**：
   - 当一个派生类对象被销毁时，首先会调用派生类的析构函数，然后再调用基类的析构函数。
   
2. **虚指针（vptr）的更新**：
   - 在派生类析构函数执行期间，对象的虚指针（vptr）指向派生类的虚函数表。
   - 只有在基类的析构函数开始执行时，对象的虚指针（vptr）才会被更新为指向基类的虚函数表。

#### 具体例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Base constructor\n";
        show(); // 调用 Base::show
    }
    virtual ~Base() {
        show(); // 调用 Base::show
        cout << "Base destructor\n";
    }
    virtual void show() {
        cout << "Base::show\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived constructor\n";
    }
    ~Derived() {
        cout << "Derived destructor\n";
    }
    void show() override {
        cout << "Derived::show\n";
    }
};

int main() {
    Derived d;
    return 0;
}
```

#### 分析

1. **构造过程**：
   - `Derived d;` 执行时，首先调用 `Base` 的构造函数。
   - 在 `Base` 的构造函数中，`show()` 被调用。
   - 此时，`Derived` 部分还未构造完成，对象的虚指针（vptr）仍然指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

2. **析构过程**：
   - `d` 离开作用域时，首先调用 `Derived` 的析构函数。
   - 在 `Derived` 的析构函数执行期间，对象的虚指针（vptr）指向 `Derived` 的虚函数表。
   - 因此，如果在 `Derived` 的析构函数中调用虚函数，将调用 `Derived` 的版本。
   - 接着调用 `Base` 的析构函数。
   - 在 `Base` 的析构函数中，`show()` 被调用。
   - 此时，`Derived` 部分已被销毁，对象的虚指针（vptr）已被更新为指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

#### 输出

```
Base constructor
Base::show
Derived constructor
Derived destructor
Base::show
Base destructor
```

#### 总结

- **构造函数中调用虚函数**：由于对象的虚指针（vptr）还未指向派生类的虚函数表，虚函数调用会绑定到当前类（基类）的版本。
- **析构函数中调用虚函数**：由于对象的虚指针（vptr）已被更新为指向当前类（基类）的虚函数表，虚函数调用会绑定到当前类（基类）的版本。

这样设计的目的是为了确保在对象构造和析构过程中，调用的函数是已知的、有效的，并且不会导致访问未初始化或已销毁的对象部分。

## 理解多态

如何解释多态?

静态(编译时期)的多态: 函数重载、模板(函数模板和类模板)

```c++
boo1compare(int,int){}
boo1compare(double,double){}

compare(10，20);call compare_int_int 在编译阶段就确定好调用的函数版本
compare(10.5，20.5);call compare_double_double 在编译阶段就确定好调用的函类
    
template<typename T>
bool compare(Ta Tb){}

compare<int>(10，20);=>int  实例化一个Compare<int>
compare(10.5，20.5);=>double 实例化一个compare<double>
```

动态（运行时候）多态：
Base Derive
在继承结构中，基类指针(引用)指向派生类对象，通过该指针(引用)调用同名覆盖方法(虚函基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态

pbase->show():

**多态底层是通过动态绑定来实现的** ，pbase-》访问谁的vfptr=》继续访问谁的vftable
								=》当然调用的是对应的派生类对象的方法了

![image-20240622231807139](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622231807139.png)

## 抽象类

类-》抽象一个实体的类型



![image-20240622232849101](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622232849101.png)

抽象类不能再实例化对象，但是可以定义指针和引用对象

好的，来解释一下抽象类，让初学者也能轻松理解。

### 什么是抽象类

抽象类是一种特殊的类，它不能被实例化，也就是说，你不能创建抽象类的对象。抽象类通常用作基类，目的是为派生类提供一个统一的接口或定义一些必须在派生类中实现的函数。

### 为什么需要抽象类

抽象类的主要目的是通过定义一组函数来规范派生类的行为。这在大型项目中尤为重要，因为它确保了所有派生类都具有某些共同的功能，即使这些功能的具体实现可能有所不同。

### 抽象类的定义

在C++中，抽象类有一个或多个纯虚函数。纯虚函数是指在基类中没有实现的函数，只定义了函数的接口，具体的实现留给派生类去完成。

### 纯虚函数的定义

纯虚函数的语法如下：

```cpp
virtual void functionName() = 0;
```

### 抽象类示例

下面是一个简单的例子来说明抽象类的定义和使用：

```cpp
#include <iostream>
using namespace std;

// 定义一个抽象类 Shape
class Shape {
public:
    // 纯虚函数，不需要在 Shape 类中实现
    virtual void draw() = 0;
    virtual double area() = 0;
};

// 定义一个派生类 Circle
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    // 实现抽象类中的纯虚函数
    void draw() override {
        cout << "Drawing a Circle" << endl;
    }

    double area() override {
        return 3.14 * radius * radius;
    }
};

// 定义另一个派生类 Rectangle
class Rectangle : public Shape {
private:
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    // 实现抽象类中的纯虚函数
    void draw() override {
        cout << "Drawing a Rectangle" << endl;
    }

    double area() override {
        return width * height;
    }
};

int main() {
    // 不能创建抽象类的实例
    // Shape s; // 这行会报错，因为 Shape 是抽象类

    // 创建派生类的实例
    Circle c(5);
    Rectangle r(4, 6);

    // 使用基类指针调用派生类的函数
    Shape* shapes[2];
    shapes[0] = &c;
    shapes[1] = &r;

    for (int i = 0; i < 2; ++i) {
        shapes[i]->draw();
        cout << "Area: " << shapes[i]->area() << endl;
    }

    return 0;
}
```

### 解释

1. **Shape类**：
    - `Shape`是一个抽象类，因为它有两个纯虚函数 `draw()` 和 `area()`。
    - 这些纯虚函数定义了一个接口，所有从 `Shape` 派生的类都必须实现这些函数。

2. **Circle类**和**Rectangle类**：
    - `Circle` 和 `Rectangle` 是从 `Shape` 派生出来的类，它们实现了 `Shape` 类中的纯虚函数 `draw()` 和 `area()`。
    - 这两个类提供了各自的实现：`Circle` 计算圆的面积，而 `Rectangle` 计算矩形的面积。

3. **main函数**：
    - 尝试直接创建 `Shape` 类的实例会导致编译错误，因为 `Shape` 是抽象类。
    - 你可以创建 `Circle` 和 `Rectangle` 的实例，然后使用基类 `Shape` 的指针来调用它们的函数。这展示了多态性：同一个基类指针可以调用不同派生类的实现。

### 总结

- **抽象类**：不能实例化，通常用作基类。
- **纯虚函数**：没有实现的函数，只定义接口，派生类必须实现。
- **多态性**：通过基类指针或引用调用派生类的实现。

抽象类和纯虚函数在设计模式中非常有用，它们帮助我们定义一组通用接口，同时允许不同的类提供各自的实现。

![image-20240624102542061](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624102542061.png)

如果没有虚继承的时候，有一个vfptr在里面，然后占用4字节

如果有虚继承在里面的话，那就多一个vbptr在里面，因为在一个vbtable里面了

那就变成8字节了（虚继承指的是virtual public A这个地方

![image-20240624102724327](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624102724327.png)

## 虚基类和虚继承

虚基类和虚继承是C++中为了解决多重继承中的**菱形继承问题**（又称**钻石继承问题**）而引入的概念。下面详细解释虚基类和虚继承，以及它们的作用和使用方法。

### 菱形继承问题

菱形继承问题发生在以下情况下：
- 一个类A被两个类B和C继承。
- 然后另一个类D同时继承B和C。

```
    A
   / \
  B   C
   \ /
    D
```

在这种结构中，D类通过B和C两次继承了A类，这会导致A类的成员在D类中出现两份，造成资源浪费和二义性问题。

### 虚继承

**虚继承**是一种特殊的继承方式，它确保在多重继承中基类只会有一个共享的实例，从而避免菱形继承问题。通过虚继承，派生类共享同一个基类实例。

### 虚基类

**虚基类**是通过虚继承实现的基类。派生类在继承基类时，使用`virtual`关键字来声明虚继承。

### 示例代码

下面是一个简单的示例，演示如何使用虚继承解决菱形继承问题。

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
    A() : value(0) {
        cout << "A constructed" << endl;
    }
    void show() {
        cout << "Value: " << value << endl;
    }
};

class B : virtual public A {
public:
    B() {
        cout << "B constructed" << endl;
    }
};

class C : virtual public A {
public:
    C() {
        cout << "C constructed" << endl;
    }
};

class D : public B, public C {
public:
    D() {
        cout << "D constructed" << endl;
    }
};

int main() {
    D d;
    d.value = 10;
    d.show(); // 访问虚基类A的成员

    return 0;
}
```

### 输出结果

```
A constructed
B constructed
A constructed
C constructed
D constructed
Value: 10
```

### 解释

1. **虚基类A**：
    - 在类B和C中，使用`virtual`关键字继承A，表示A是一个虚基类。
    - `class B : virtual public A` 和 `class C : virtual public A`。

2. **类D继承B和C**：
    - 由于B和C都是通过虚继承方式继承自A，所以D中只存在一个A的实例。
    - 在`main`函数中创建D的实例时，只调用了一次A的构造函数。

3. **访问虚基类成员**：
    - 可以直接通过D的对象访问A的成员，如`d.value`。

### 总结

- **虚继承**通过在继承时使用`virtual`关键字，确保派生类中只有一个基类实例，从而避免了菱形继承问题。
- **虚基类**是被虚继承的基类，通过虚继承机制共享其实例。
- 通过虚继承，可以解决多重继承中的资源浪费和二义性问题，使类的结构更加清晰和高效。

掌握虚继承和虚基类的概念和使用方法，有助于更好地设计和实现复杂的类层次结构，避免多重继承带来的潜在问题。





-------------------------------------------------------------------------------------------------------------------

区分一下多重继承和虚继承的区别

多重继承和虚继承是C++中用于设计类层次结构的两种不同方式。它们各有优缺点，适用于不同的场景。下面详细对比它们的区别及各自的优缺点。

#### 多重继承

**多重继承**允许一个类从多个基类继承。它使得类可以同时继承多个类的功能和接口。

##### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    void funcA() {
        cout << "Function A" << endl;
    }
};

class B {
public:
    void funcB() {
        cout << "Function B" << endl;
    }
};

class C : public A, public B {
};

int main() {
    C obj;
    obj.funcA();
    obj.funcB();
    return 0;
}
```

##### 优点

1. **灵活性**：可以同时继承多个类的接口和实现。
2. **代码重用**：能够复用多个基类的功能，减少代码重复。

##### 缺点

1. **复杂性**：类层次结构变得复杂，难以理解和维护。
2. **菱形继承问题**：在多重继承中，如果多个基类继承自同一个基类，会导致重复继承，带来二义性和资源浪费。

#### 虚继承

**虚继承**是一种特殊的多重继承方式，解决了菱形继承问题。它确保在多重继承中，基类只会有一个共享的实例。

##### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
    A() : value(0) {
        cout << "A constructed" << endl;
    }
    void show() {
        cout << "Value: " << value << endl;
    }
};

class B : virtual public A {
public:
    B() {
        cout << "B constructed" << endl;
    }
};

class C : virtual public A {
public:
    C() {
        cout << "C constructed" << endl;
    }
};

class D : public B, public C {
public:
    D() {
        cout << "D constructed" << endl;
    }
};

int main() {
    D d;
    d.value = 10;
    d.show();
    return 0;
}
```

##### 优点

1. **解决菱形继承问题**：确保基类在派生类中只有一个实例，避免重复继承带来的问题。
2. **明确的继承关系**：虚继承使得继承关系更加清晰，减少二义性。

##### 缺点

1. **性能开销**：虚继承需要维护虚基类表（vbptr），会带来额外的内存开销和性能损耗。
2. **复杂性增加**：虽然解决了菱形继承问题，但引入了虚基类表，增加了实现的复杂性。

#### 总结

##### 多重继承
- **优点**：
  - 高灵活性。
  - 代码重用。
- **缺点**：
  - 复杂性高。
  - 存在菱形继承问题。

##### 虚继承
- **优点**：
  - 解决菱形继承问题。
  - 继承关系更加明确。
- **缺点**：
  - 性能开销。
  - 实现复杂性增加。

##### 选择建议

- **使用多重继承**：当类层次结构简单，且不涉及菱形继承问题时，多重继承可以带来较高的灵活性和代码重用。
- **使用虚继承**：当涉及菱形继承问题时，应使用虚继承来确保基类实例唯一，避免二义性和资源浪费。

根据具体情况选择合适的继承方式，可以设计出更清晰、可维护和高效的类层次结构。



---------------------------------------------------------------------------------------------------------------

### 虚继承还有虚函数还有虚基类这些的地址问题



在C++中，虚继承、虚函数和虚基类涉及到一些底层的地址管理问题。理解这些机制如何管理地址有助于更好地理解C++的面向对象编程。以下是对这些概念的详细解释。

#### 虚继承和虚基类的地址问题

#### 虚继承

虚继承通过`virtual`关键字确保基类在多重继承中的实例只出现一次。这会影响对象的内存布局，需要通过虚基类指针（`vbptr`）来访问基类。

#### 内存布局

当使用虚继承时，编译器会在派生类对象中添加一个虚基类指针（`vbptr`）。`vbptr`指向虚基类表（`vbtable`），`vbtable`中记录了虚基类的偏移量。

#### 示例

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int a;
    A() : a(0) {}
};

class B : virtual public A {
public:
    int b;
    B() : b(0) {}
};

class C : virtual public A {
public:
    int c;
    C() : c(0) {}
};

class D : public B, public C {
public:
    int d;
    D() : d(0) {}
};

int main() {
    D obj;
    obj.a = 10;
    obj.b = 20;
    obj.c = 30;
    obj.d = 40;

    cout << "a: " << obj.a << endl;
    cout << "b: " << obj.b << endl;
    cout << "c: " << obj.c << endl;
    cout << "d: " << obj.d << endl;

    return 0;
}
```

#### 内存布局图示

```
+---------+------------------+
|  B::vbptr| --> [A offset]  |
+---------+------------------+
|    b    |                  |
+---------+------------------+
|  C::vbptr| --> [A offset]  |
+---------+------------------+
|    c    |                  |
+---------+------------------+
|    d    |                  |
+---------+------------------+
|    A    |                  |
+---------+------------------+
```

#### 地址访问

- `obj.a` 通过 `vbptr` 查找 `vbtable`，确定 `A` 的偏移量，然后访问 `A` 的成员 `a`。
- `obj.b`、`obj.c` 和 `obj.d` 直接按偏移量访问。

#### 虚函数的地址问题

#### 虚函数

虚函数使得在运行时能够通过基类指针或引用调用派生类的函数。虚函数表（`vtable`）和虚函数指针（`vptr`）实现了这一机制。

#### 内存布局

每个包含虚函数的类对象都有一个 `vptr`，指向 `vtable`。`vtable` 是一个函数指针数组，指向该类的虚函数。

#### 示例

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }
};

int main() {
    Derived obj;
    Base* pBase = &obj;
    pBase->show();  // 调用 Derived::show

    return 0;
}
```

#### 内存布局图示

```
+--------+---------------+
| vptr   | --> [vtable]  |
+--------+---------------+
| data   |               |
+--------+---------------+
```

#### 地址访问

- `pBase->show()` 通过 `vptr` 查找 `vtable`，找到 `Derived::show` 的地址并调用。

#### 总结

#### 虚基类和虚继承

- **虚基类指针（vbptr）**：用于定位虚基类在多重继承中的偏移量。
- **虚基类表（vbtable）**：记录了虚基类的偏移量。

#### 虚函数

- **虚函数指针（vptr）**：指向虚函数表。
- **虚函数表（vtable）**：存储虚函数的地址，实现动态绑定。

#### 内存布局影响

- **虚继承**：引入 `vbptr` 和 `vbtable`，确保虚基类只实例化一次。
- **虚函数**：引入 `vptr` 和 `vtable`，实现多态性和动态绑定。

通过虚继承和虚函数，C++ 提供了强大的面向对象特性，但也带来了额外的内存和性能开销。理解这些底层机制有助于更好地设计和优化 C++ 程序。



## 菱形继承的问题

![image-20240624130928614](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624130928614.png)

其实能够解决多重继承等等的问题，可以在一个基类的数据

就是在A这里使用虚函数，这样子可以虚继承，产生位偏移获取数据

## c++的四种转换类型

C++ 提供了多种类型转换方式，主要分为两大类：**C风格的类型转换**和**C++风格的类型转换**。C++风格的类型转换引入了一些新的运算符，以提供更严格和更安全的类型转换机制。以下是详细的介绍：

### C风格的类型转换

C风格的类型转换是从C语言继承过来的，语法如下：

```cpp
(type)expression
```

或

```cpp
type(expression)
```

这种转换方式简单直接，但缺乏类型检查，容易引发错误。

### C++风格的类型转换

C++引入了四种类型转换运算符，分别是：

1. **`static_cast`**
2. **`dynamic_cast`**
3. **`const_cast`**
4. **`reinterpret_cast`**

#### 1. `static_cast`

`static_cast` 用于**在编译时执行显式类型转换**，主要用于标准类型之间的转换、类层次结构中基类和派生类之间的转换（上行转换安全，下行转换需谨慎）。

提供编译器认为安全的类型转换，没有任何联系的类型之间的转换就会被否认

初始化的时候使用这个

```cpp
int main() {
    int a = 10;
    double b = static_cast<double>(a);  // int 转 double
    return 0;
}
```

#### 2. `dynamic_cast`

`dynamic_cast` 用于**在运行时执行类型转换**，主要用于类层次结构中基类和派生类之间的转换。它依赖于运行时类型识别（RTTI），可以确保下行转换的安全性。只能用于指针和引用。

主要用在继承结构中，支持RTTI类型识别的上下转换

制作api的时候尽可能使用这个

```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void derivedMethod() {}
};

int main() {
    Base* b = new Derived();
    Derived* d = dynamic_cast<Derived*>(b);  // 安全的下行转换
    if (d) {
        d->derivedMethod();
    }
    delete b;
    return 0;
}
```

#### 3. `const_cast`

`const_cast` 用于移除或添加对象的`const`或`volatile`属性。它是唯一能够移除`const`属性的类型转换运算符。

去掉常量属性的一个类型转换

去掉指针和引用的 时候进行使用

```cpp
void func(const int* p) {
    int* q = const_cast<int*>(p);
    *q = 20;
}

int main() {
    const int a = 10;
    func(&a);
    return 0;
}
```

#### 4. `reinterpret_cast`

`reinterpret_cast` 用于执行低级别的类型转换，例如指针类型之间的转换。它几乎不进行任何检查，仅仅是对比特模式的重新解释。

类C风格的强制转换

```cpp
int main() {
    int a = 10;
    void* p = &a;
    int* q = reinterpret_cast<int*>(p);  // void* 转 int*
    return 0;
}
```

### 总结

- **C风格的类型转换**：`(type)expression` 或 `type(expression)`，简单直接，但缺乏类型检查。
- **C++风格的类型转换**：
  - `static_cast`：用于编译时类型转换，适用于标准类型转换和安全的类层次结构转换。
  - `dynamic_cast`：用于运行时类型转换，适用于安全的类层次结构下行转换，依赖于RTTI。
  - `const_cast`：用于移除或添加`const`或`volatile`属性。
  - `reinterpret_cast`：用于低级别的类型转换，不进行任何检查。

这些类型转换方式各有其适用场景，选择合适的类型转换方式有助于编写安全、高效和可维护的代码。





# STL标准库

![image-20240624141032373](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624141032373.png)

![image-20240624141208888](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624141208888.png)

## vector容器

底层数据结构：动态开辟的数组，每次一原来的2倍进行扩容

`std::vector` 是 C++ 标准库中提供的一个动态数组容器，可以存储任意类型的元素。它提供了方便的接口来进行元素的添加、删除、访问和遍历操作。相比于普通数组，`std::vector` 的大小是动态可变的，可以根据需要自动扩展。

#### 基本使用

##### 包含头文件

使用 `std::vector` 需要包含头文件 `<vector>`：

```cpp
#include <vector>
```

##### 定义一个 vector

```cpp
#include <iostream>
#include <vector>

int main() {
    // 定义一个存储 int 类型元素的 vector
    std::vector<int> vec;

    return 0;
}
```

#### 常用操作

##### 添加元素

- `push_back()`: 在末尾添加元素。
- `emplace_back()`: 在末尾原地构造元素，比 `push_back()` 效率更高。

```cpp
int main() {
    std::vector<int> vec;

    vec.push_back(1);         // 在末尾添加 1
    vec.push_back(2);         // 在末尾添加 2
    vec.emplace_back(3);      // 在末尾原地构造 3

    for (int val : vec) {
        std::cout << val << " ";  // 输出: 1 2 3
    }

    return 0;
}
```

##### 访问元素

- `operator[]`: 通过下标访问元素，不进行边界检查。
- `at()`: 通过下标访问元素，进行边界检查。
- `front()`: 访问第一个元素。
- `back()`: 访问最后一个元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    std::cout << vec[0] << std::endl;  // 输出: 1
    std::cout << vec.at(1) << std::endl;  // 输出: 2
    std::cout << vec.front() << std::endl;  // 输出: 1
    std::cout << vec.back() << std::endl;  // 输出: 3

    return 0;
}
```

##### 修改元素

- 直接通过下标或迭代器修改元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    vec[0] = 10;  // 修改第一个元素为 10

    for (int val : vec) {
        std::cout << val << " ";  // 输出: 10 2 3
    }

    return 0;
}
```

##### 删除元素

- `pop_back()`: 删除最后一个元素。
- `erase()`: 删除指定位置的元素或一个范围内的元素。
- `clear()`: 删除所有元素。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3, 4};

    vec.pop_back();  // 删除最后一个元素

    vec.erase(vec.begin());  // 删除第一个元素

    vec.clear();  // 删除所有元素

    return 0;
}
```

PS：在进行连续的插入或者删除操作（insert/erase），一定要更新迭代器，否则第一次insert或者erase完成，迭代器失效了

![image-20240624142305782](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624142305782.png)

![image-20240624142355881](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624142355881.png)

解决失效问题就是做一次赋值

对值进行一个更新，就是类似于 it2 = vec.erase(its);这样子的操作

##### 大小和容量

- `size()`: 返回当前元素个数。
- `empty()`: 判断是否为空。
- `resize()`: 改变元素个数。
- `capacity()`: 返回当前容量。
- `reserve()`: 预留指定容量。只给容器底层开辟指定大小的内存空间，并不会添加新的元素

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    std::cout << "Size: " << vec.size() << std::endl;  // 输出: Size: 3
    std::cout << "Capacity: " << vec.capacity() << std::endl;  // 输出: Capacity: 3

    vec.reserve(10);  // 预留 10 个元素的空间

    std::cout << "Capacity after reserve: " << vec.capacity() << std::endl;  // 输出: Capacity after reserve: 10

    return 0;
}
```

##### 遍历

可以使用迭代器、范围 for 循环或者传统的 for 循环来遍历 `std::vector`。

```cpp
int main() {
    std::vector<int> vec = {1, 2, 3};

    // 使用范围 for 循环
    for (int val : vec) {
        std::cout << val << " ";  // 输出: 1 2 3
    }
    std::cout << std::endl;

    // 使用迭代器
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";  // 输出: 1 2 3
    }
    std::cout << std::endl;

    // 使用传统的 for 循环
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";  // 输出: 1 2 3
    }

    return 0;
}
```

#### 总结

`std::vector` 是一个非常强大的动态数组容器，支持灵活的增删改查操作。通过合理使用 `std::vector`，可以大大简化数组管理的工作，提高代码的可读性和维护性。



----

## deque容器和list容器

扩容方式



![image-20240624150350200](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150350200.png)

![image-20240624150400538](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150400538.png)

![image-20240624150420112](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150420112.png)

扩容空间，旧的放在中间，方便进行添加和删除

![image-20240624150700313](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150700313.png)

对比vec的话时间效率快很多，如果经常需要进行首部尾部 添加那就deque

数量越多时间越久

![image-20240624150909426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624150909426.png)

在C++标准库中，`deque`（双端队列）和`list`（双向链表）是两种常用的序列容器。它们各自有独特的特性和适用场景。

### `deque` 容器

`deque` 是一种双端队列，支持高效的头部和尾部插入和删除操作，同时也支持随机访问。它内部实现通常由多个连续的内存块组成，可以动态调整大小。

#### 特性

1. **双端插入和删除**：在头部和尾部进行插入和删除操作都非常高效，时间复杂度为O(1)。
2. **随机访问**：支持下标操作和随机访问，时间复杂度为O(1)。
3. **动态调整大小**：可以根据需要动态扩展或收缩。

#### 常用操作

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;

    // 在头部和尾部插入元素
    dq.push_back(1);
    dq.push_front(2);

    // 访问元素
    std::cout << dq[0] << std::endl; // 输出 2
    std::cout << dq[1] << std::endl; // 输出 1

    // 删除头部和尾部元素
    dq.pop_front();
    dq.pop_back();

    // 检查是否为空
    if (dq.empty()) {
        std::cout << "Deque is empty" << std::endl;
    }

    return 0;
}
```

### `list` 容器

`list` 是一种双向链表，支持高效的插入和删除操作，但不支持随机访问。适用于需要频繁在中间位置进行插入和删除操作的场景。

#### 特性

1. **双向链表**：每个节点包含指向前一个和后一个节点的指针。
2. **高效插入和删除**：在任意位置插入和删除操作时间复杂度为O(1)。
3. **不支持随机访问**：访问元素时需要遍历链表，时间复杂度为O(n)。

#### 常用操作

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst;

    // 在头部和尾部插入元素
    lst.push_back(1);
    lst.push_front(2);

    // 访问元素
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " "; // 输出 2 1
    }
    std::cout << std::endl;

    // 删除头部和尾部元素
    lst.pop_front();
    lst.pop_back();

    // 检查是否为空
    if (lst.empty()) {
        std::cout << "List is empty" << std::endl;
    }

    return 0;
}
```

### `deque` vs `list`

| 特性                    | `deque`                    | `list`                     |
| ----------------------- | -------------------------- | -------------------------- |
| 插入/删除（头部和尾部） | O(1)                       | O(1)                       |
| 插入/删除（中间）       | O(n)                       | O(1)                       |
| 随机访问                | O(1)                       | O(n)                       |
| 内存连续性              | 部分连续                   | 不连续                     |
| 适用场景                | 需要快速头尾插入和随机访问 | 需要快速任意位置插入和删除 |

#### 选择使用

- **`deque`**：适合需要在头部和尾部频繁插入和删除，同时需要高效随机访问的场景。
- **`list`**：适合需要在任意位置频繁插入和删除，但不需要随机访问的场景。

#### 示例代码

##### 使用 `deque` 实现双端队列操作

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;

    dq.push_back(1); // 末尾插入
    dq.push_front(2); // 头部插入

    dq.insert(dq.begin() + 1, 3); // 中间插入
    dq.erase(dq.begin() + 1); // 中间删除

    for (int val : dq) {
        std::cout << val << " "; // 输出 2 1
    }
    std::cout << std::endl;

    return 0;
}
```

##### 使用 `list` 实现链表操作

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst;

    lst.push_back(1); // 末尾插入
    lst.push_front(2); // 头部插入

    auto it = lst.begin();
    ++it;
    lst.insert(it, 3); // 中间插入
    lst.erase(--it); // 中间删除

    for (int val : lst) {
        std::cout << val << " "; // 输出 3 1
    }
    std::cout << std::endl;

    return 0;
}
```

#### 总结

- **`deque`** 是双端队列，适合需要快速头尾插入删除和随机访问的场景。
- **`list`** 是双向链表，适合需要频繁中间插入和删除，但不需要随机访问的场景。

通过合理选择容器，可以提高程序的效率和可读性。

![image-20240624151431951](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624151431951.png)

## Vector和deque和list 的区别

在 C++ 标准库中，`vector`、`deque` 和 `list` 是三种常用的序列容器。它们各自有不同的实现方式和适用场景。以下从多个角度详细说明它们的区别：





### 底层数据结构

- **`vector`**：动态数组，内存连续。
- **`deque`**：双端队列，由多个连续内存块组成。
- **`list`**：双向链表，内存不连续，每个节点包含数据和指向前后节点的指针。

### 插入和删除元素的复杂度

- **`vector`**：
  - 头部插入/删除：O(n)
  - 尾部插入/删除：O(1)（摊销）
  - 中间插入/删除：O(n)

- **`deque`**：
  - 头部插入/删除：O(1)
  
  - 尾部插入/删除：O(1)

  - 中间插入/删除：O(n)
  
    ![image-20240624154056014](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624154056014.png)
  
- **`list`**：
  - 头部插入/删除：O(1)
  - 尾部插入/删除：O(1)
  - 中间插入/删除：O(1)

### 内存使用效率

- **`vector`**：
  - 内存是连续分配的，空间利用率高。
  - 可能会因为扩容而导致多次重新分配和拷贝操作，造成一定的内存浪费。
  
- **`deque`**：
  - 内存是分段分配的，头部和尾部有额外的管理开销。
  - 内存利用率较高，但比 `vector` 略低。
  
- **`list`**：
  - 每个元素都需要额外存储两个指针，内存开销较大。
  - 内存利用率较低，容易造成内存碎片化。

### 访问元素的复杂度

- **`vector`**：
  - 随机访问：O(1)
  - 顺序访问：O(1)

- **`deque`**：
  - 随机访问：O(1)
  - 顺序访问：O(1)

- **`list`**：
  - 随机访问：O(n)
  - 顺序访问：O(1)

### 中间插入和删除效率

- **`vector`**：
  - 中间插入/删除操作需要移动大量元素，效率较低。
  - 时间复杂度为 O(n)。

- **`deque`**：
  - 中间插入/删除操作需要在内存块之间移动元素，效率较低。
  - 时间复杂度为 O(n)。

- **`list`**：
  - 中间插入/删除操作只需修改相邻节点的指针，效率高。
  - 时间复杂度为 O(1)。

### 迭代器的有效性

- **`vector`**：
  - 插入和删除操作可能会使迭代器失效，尤其是扩容时。
  
- **`deque`**：
  - 插入和删除操作也可能会使迭代器失效，但不如 `vector` 严重。
  
- **`list`**：
  - 插入和删除操作不会使迭代器失效（除非是被删除的元素的迭代器）。

### 应用场景

- **`vector`**：
  - 适用于需要频繁随机访问和顺序访问的场景。
  - 不适合频繁在中间插入和删除的场景。

- **`deque`**：
  - 适用于需要频繁在头部和尾部插入和删除的场景。
  - 在中间插入和删除的场景下表现不佳。

- **`list`**：
  - 适用于需要频繁在任意位置插入和删除的场景。
  - 不适合需要随机访问的场景。

### 示例代码

#### `vector` 示例

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.push_back(4); // O(1)

    vec.insert(vec.begin() + 1, 5); // O(n)

    for (const auto& val : vec) {
        std::cout << val << " "; // 输出: 1 5 2 3 4
    }
    std::cout << std::endl;

    vec.erase(vec.begin() + 1); // O(n)

    for (const auto& val : vec) {
        std::cout << val << " "; // 输出: 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

#### `deque` 示例

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq = {1, 2, 3};
    dq.push_back(4); // O(1)
    dq.push_front(0); // O(1)

    dq.insert(dq.begin() + 2, 5); // O(n)

    for (const auto& val : dq) {
        std::cout << val << " "; // 输出: 0 1 5 2 3 4
    }
    std::cout << std::endl;

    dq.erase(dq.begin() + 2); // O(n)

    for (const auto& val : dq) {
        std::cout << val << " "; // 输出: 0 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

#### `list` 示例

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3};
    lst.push_back(4); // O(1)
    lst.push_front(0); // O(1)

    auto it = lst.begin();
    std::advance(it, 2);
    lst.insert(it, 5); // O(1)

    for (const auto& val : lst) {
        std::cout << val << " "; // 输出: 0 1 5 2 3 4
    }
    std::cout << std::endl;

    it = lst.begin();
    std::advance(it, 2);
    lst.erase(it); // O(1)

    for (const auto& val : lst) {
        std::cout << val << " "; // 输出: 0 1 2 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### 总结

- **`vector`** 适用于需要频繁随机访问和顺序访问的场景，但在中间插入和删除时性能较差。
- **`deque`** 适用于需要频繁在头部和尾部插入和删除的场景，支持随机访问，但中间插入和删除的性能不如 `list`。
- **`list`** 适用于需要频繁在任意位置插入和删除的场景，不支持随机访问，但插入和删除操作不会使迭代器失效。

## 详细介绍容器适配器

容器适配器是 C++ 标准库的一部分，它们通过对现有的容器进行封装，提供了特定的功能和接口。标准库中有三种主要的容器适配器：`stack`、`queue` 和 `priority_queue`。这些适配器对底层容器进行包装，使其具有特定的数据访问模式。以下是对这三种容器适配器的详细介绍。

### `stack` 容器适配器

`stack` 是一种后进先出（LIFO，Last In First Out）的数据结构。它仅允许在栈顶进行插入和删除操作。

#### 底层容器
- 默认使用 `deque` 作为底层容器。
- 也可以使用 `vector` 或 `list` 作为底层容器。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 压入栈顶。
- `pop()`: 移除栈顶元素。
- `top()`: 返回栈顶元素的引用。
- `empty()`: 检查栈是否为空。
- `size()`: 返回栈中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;
    s.push(1);
    s.push(2);
    s.push(3);

    while (!s.empty()) {
        std::cout << s.top() << " "; // 输出: 3 2 1
        s.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### `queue` 容器适配器

`queue` 是一种先进先出（FIFO，First In First Out）的数据结构。它允许在队尾插入元素，在队头移除元素。

#### 底层容器
- 默认使用 `deque` 作为底层容器。
- 也可以使用 `list` 作为底层容器。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 插入队尾。
- `pop()`: 移除队头元素。
- `front()`: 返回队头元素的引用。
- `back()`: 返回队尾元素的引用。
- `empty()`: 检查队列是否为空。
- `size()`: 返回队列中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) {
        std::cout << q.front() << " "; // 输出: 1 2 3
        q.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### `priority_queue` 容器适配器

`priority_queue` 是一种基于堆实现的优先队列。默认情况下，它是一个大顶堆(大根堆)，堆顶元素是优先级最高的元素。

#### 底层容器
- 默认使用 `vector` 作为底层容器，并通过 `make_heap`、`push_heap` 和 `pop_heap` 算法来维护堆结构。

#### 主要操作
- `push(const T& val)`: 将元素 `val` 插入优先队列。
- `pop()`: 移除堆顶元素。
- `top()`: 返回堆顶元素的引用。
- `empty()`: 检查优先队列是否为空。
- `size()`: 返回优先队列中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    std::priority_queue<int> pq;
    pq.push(3);
    pq.push(1);
    pq.push(4);
    pq.push(1);
    pq.push(5);
    pq.push(9);
    
    while (!pq.empty()) {
        std::cout << pq.top() << " "; // 输出: 9 5 4 3 1 1
        pq.pop();
    }
    std::cout << std::endl;

    return 0;
}
```

### 适配器的特点和用途

#### `stack`
- **特点**：
  - 后进先出（LIFO）的操作顺序。
  - 只允许在栈顶进行插入和删除操作。
- **用途**：
  - 适用于需要逆序处理的场景，如深度优先搜索、递归模拟等。

#### `queue`
- **特点**：
  - 先进先出（FIFO）的操作顺序。
  - 允许在队尾插入元素，在队头移除元素。
- **用途**：
  - 适用于按顺序处理元素的场景，如广度优先搜索、任务调度等。

#### `priority_queue`
- **特点**：
  - 基于堆的数据结构。
  - 默认是大顶堆，可通过指定比较函数实现小顶堆。
  - 允许按优先级处理元素。
- **用途**：
  - 适用于需要按优先级处理元素的场景，如任务调度、最短路径算法等。

### 适配器的底层容器选择

- **`stack`**：
  - 默认使用 `deque`，也可以使用 `vector` 或 `list`。
  - 使用 `deque` 和 `list` 时，头部和尾部的操作性能较好。
  - 使用 `vector` 时，尾部操作性能较好，但扩容可能影响性能。
  
- **`queue`**：
  - 默认使用 `deque`，也可以使用 `list`。
  - 使用 `deque` 和 `list` 时，头部和尾部的操作性能较好。
  
- **`priority_queue`**：
  - 默认使用 `vector`，并通过堆算法维护堆结构。
  - 使用 `vector` 时，性能较好，因为堆操作的时间复杂度为 O(log n)。

### 总结

容器适配器通过封装底层容器，提供了特定的数据访问模式，使得编写代码更加方便和直观。了解每种适配器的特点和用途，可以更好地选择适合的容器来解决特定的问题。

**PS : ** ![image-20240624160456998](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624160456998.png)









------

![image-20240624160718086](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624160718086.png)

## 关联容器

C++ 标准库中的关联容器（Associative Containers）用于高效地存储和检索元素。它们根据键值对元素进行排序和管理，并提供对元素的快速查找、插入和删除操作。C++ 标准库中提供了四种主要的关联容器：`set`、`multiset`、`map` 和 `multimap`。

### `set` 容器

`set` 是一个存储唯一元素的容器，元素按特定顺序（默认按键值升序）排列。

#### 特点
- 元素唯一：每个元素只能出现一次。
- 元素自动排序：元素按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数（对于 `set`，结果是 0 或 1）。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;
    s.insert(3);
    s.insert(1);
    s.insert(4);
    s.insert(1); // 重复元素，不会插入

    for (int x : s) {
        std::cout << x << " "; // 输出: 1 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### `multiset` 容器

`multiset` 是一个允许存储重复元素的容器，元素按特定顺序排列。

#### 特点
- 元素可重复：同一个元素可以出现多次。
- 元素自动排序：元素按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> ms;
    ms.insert(3);
    ms.insert(1);
    ms.insert(4);
    ms.insert(1); // 允许重复元素

    for (int x : ms) {
        std::cout << x << " "; // 输出: 1 1 3 4
    }
    std::cout << std::endl;

    return 0;
}
```

### `map` 容器

`map` 是一个存储键值对（key-value pair）的关联容器，键值唯一且按特定顺序排列。

#### 特点
- 键唯一：每个键只能出现一次。
- 键自动排序：键按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `operator[](const Key& key)`: 访问或插入键值对。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> m;
    m[1] = "one";
    m[2] = "two";
    m[3] = "three";

    for (const auto& p : m) {
        std::cout << p.first << ": " << p.second << std::endl;
    }

    return 0;
}
```

### `multimap` 容器

`multimap` 是一个允许存储重复键的关联容器，键值对按键的特定顺序排列。

#### 特点
- 键可重复：同一个键可以出现多次。
- 键自动排序：键按特定顺序排列。
- 底层实现：红黑树（自平衡二叉搜索树）。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `count(const Key& key)`: 返回键 `key` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> mm;
    mm.insert({1, "one"});
    mm.insert({2, "two"});
    mm.insert({1, "uno"});

    for (const auto& p : mm) {
        std::cout << p.first << ": " << p.second << std::endl;
    }

    return 0;
}
```

### 关联容器的特点和性能

#### 底层数据结构
- 所有关联容器（`set`、`multiset`、`map`、`multimap`）都基于红黑树实现，这是一种自平衡二叉搜索树。

#### 时间复杂度
- **查找、插入、删除操作**：平均时间复杂度为 O(log n)。

#### 内存使用
- 关联容器需要额外的内存来维护树结构，因此在内存使用上可能比序列容器（如 `vector` 和 `deque`）更高。

#### 迭代器
- 关联容器的迭代器是双向迭代器，可以前向和后向遍历元素。
- 迭代器在插入和删除操作后仍然有效，但可能不再指向原来的元素。

### 关联容器的选择

- **`set`**：用于需要唯一元素集合的场景，支持高效的元素查找和删除操作。
- **`multiset`**：用于需要存储重复元素集合的场景，支持高效的元素查找和删除操作。
- **`map`**：用于需要键值对映射的场景，键唯一且按顺序排列。
- **`multimap`**：用于需要存储重复键的键值对映射的场景，键按顺序排列。

### 总结

关联容器在需要高效查找、插入和删除操作的场景中非常有用。它们通过红黑树结构提供了稳定的 O(log n) 时间复杂度，同时保持元素的有序性。选择合适的关联容器可以帮助简化代码逻辑，提高程序性能。





## 无序关联容器详解

无序关联容器是 C++11 引入的容器，它们提供了一种基于哈希表的数据结构，以常数时间复杂度 O(1) 进行查找、插入和删除操作。标准库中的无序关联容器包括 `unordered_set`、`unordered_multiset`、`unordered_map` 和 `unordered_multimap`。这些容器提供了一种高效的方式来处理大量数据，并且与有序关联容器不同，它们不会维护元素的有序性。

### `unordered_set` 容器

`unordered_set` 是一个存储唯一元素的容器，使用哈希表实现，元素无序。

#### 特点
- 元素唯一：每个元素只能出现一次。
- 元素无序：不保证元素的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数（对于 `unordered_set`，结果是 0 或 1）。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> uset;
    uset.insert(3);
    uset.insert(1);
    uset.insert(4);
    uset.insert(1); // 重复元素，不会插入

    for (int x : uset) {
        std::cout << x << " "; // 输出顺序不确定
    }
    std::cout << std::endl;

    return 0;
}
```

### `unordered_multiset` 容器

`unordered_multiset` 是一个允许存储重复元素的容器，使用哈希表实现，元素无序。

#### 特点
- 元素可重复：同一个元素可以出现多次。
- 元素无序：不保证元素的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const T& val)`: 插入元素 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的元素。
- `find(const T& val)`: 查找元素 `val`，返回指向该元素的迭代器。
- `count(const T& val)`: 返回元素 `val` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_multiset<int> umset;
    umset.insert(3);
    umset.insert(1);
    umset.insert(4);
    umset.insert(1); // 允许重复元素

    for (int x : umset) {
        std::cout << x << " "; // 输出顺序不确定
    }
    std::cout << std::endl;

    return 0;
}
```

### `unordered_map` 容器

`unordered_map` 是一个存储键值对（key-value pair）的容器，键值唯一且无序。

#### 特点
- 键唯一：每个键只能出现一次。
- 键值对无序：不保证键值对的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `operator[](const Key& key)`: 访问或插入键值对。具有查询功能，如果key不在，则会插入一对数据![image-20240624162305391](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240624162305391.png)
- `size()`: 返回容器中元素的数量。

##### 一些操作

###### 怎么使用 `p.first` 和 `p.second`？

- **获取键和值**：`p.first` 可以用来获取 `unordered_map` 中的键，`p.second` 则可以获取与该键相关联的值。
- **条件判断**：在上述示例中，通过检查 `p.second` 是否大于1，可以找出在原始数组中出现多次的键。
- **修改值**：如果需要修改 `unordered_map` 中的值，可以直接通过 `p.second` 进行修改，例如增加计数或执行其他操作。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> umap;
    umap[1] = "one";
    umap[2] = "two";
    umap[3] = "three";

    for (const auto& p : umap) {
        std::cout << p.first << ": " << p.second << std::endl; // 输出顺序不确定
    }

    return 0;
}
```

#### 示例代码2

```c++
#include <unordered_map>
int main(){
  const int ARR_LEN = 10000;
  int arr[ARR_LEN] = { 0 };
  for (int i = 0; i < ARR_LEN; ++i) {
    arr[i] = rand() % 20 +1 ;
  }
  unordered_map<int,int> map1;
  for (int k : arr) {
    auto it = map1.find(k);
    if (it == map1.end()){
      map1.insert({k,1});
    }
    else{
      it->second++;
    }
  }
  for (pair<int,int> p : map1)
  {
    if(p.second > 1)
    {
      cout << "key: " << p.first << " count : " << p.second << endl;
    }
  }
  cout << endl;
cout <<"--------------"<< endl;
  auto it = map1.begin();
  for (; it != map1.end() ; ++it) {
    if(it->second > 1)
    {
      cout << "key: " << it->first << " count : " << it->second << endl;
    }
  }
}
```



### `unordered_multimap` 容器

`unordered_multimap` 是一个允许存储重复键的关联容器，键值对无序。

#### 特点
- 键可重复：同一个键可以出现多次。
- 键值对无序：不保证键值对的顺序。
- 基于哈希表：提供常数时间复杂度的查找、插入和删除操作。

#### 主要操作
- `insert(const std::pair<Key, T>& val)`: 插入键值对 `val`。
- `erase(iterator pos)`: 删除迭代器 `pos` 指向的键值对。
- `find(const Key& key)`: 查找键 `key`，返回指向该键值对的迭代器。
- `count(const Key& key)`: 返回键 `key` 的个数。
- `size()`: 返回容器中元素的数量。

#### 示例代码

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_multimap<int, std::string> ummap;
    ummap.insert({1, "one"});
    ummap.insert({2, "two"});
    ummap.insert({1, "uno"});

    for (const auto& p : ummap) {
        std::cout << p.first << ": " << p.second << std::endl; // 输出顺序不确定
    }

    return 0;
}
```

### 无序关联容器的特点和性能

#### 底层数据结构
- 所有无序关联容器（`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`）都基于哈希表实现。

#### 时间复杂度
- **查找、插入、删除操作**：平均时间复杂度为 O(1)，最坏情况下为 O(n)，当发生哈希冲突时性能可能降低。

#### 内存使用
- 无序关联容器需要额外的内存来存储哈希表结构和处理哈希冲突，因此在内存使用上可能比有序关联容器更高。

#### 迭代器
- 无序关联容器的迭代器是双向迭代器。
- 迭代器在插入和删除操作后仍然有效，但可能不再指向原来的元素。

### 无序关联容器的选择

- **`unordered_set`**：用于需要唯一元素集合的场景，支持高效的元素查找和删除操作，但不要求有序。
- **`unordered_multiset`**：用于需要存储重复元素集合的场景，支持高效的元素查找和删除操作，但不要求有序。
- **`unordered_map`**：用于需要键值对映射的场景，键唯一且无序，支持高效的查找和删除操作。
- **`unordered_multimap`**：用于需要存储重复键的键值对映射的场景，键无序，支持高效的查找和删除操作。

### 总结

无序关联容器在需要高效查找、插入和删除操作的场景中非常有用，尤其是在不要求元素有序的情况下。它们通过哈希表结构提供了常数时间复杂度的操作，可以显著提高程序性能。选择合适的无序关联容器可以帮助简化代码逻辑，提高程序效率。



## 有序关联容器

![image-20240625004529144](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240625004529144.png)

有序关联容器（Ordered Associative Containers）是 C++ 标准模板库（STL）中的一类容器，用于在内存中存储键值对，并根据键的顺序自动排序和高效检索。主要的有序关联容器包括：

1. `std::map`
2. `std::multimap`
3. `std::set`
4. `std::multiset`

### 1. `std::map`

`std::map` 是一种键值对的有序关联容器，具有以下特点：

- **唯一键**：每个键在 `map` 中必须是唯一的。
- **自动排序**：键值对会根据键自动排序（默认使用 `<` 运算符）。
- **快速查找**：查找、插入、删除操作的时间复杂度为 O(log n)。

**示例代码**：

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> myMap;
    myMap[1] = "one";
    myMap[2] = "two";
    myMap[3] = "three";

    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 2. `std::multimap`

`std::multimap` 与 `std::map` 类似，但允许相同的键有多个值。即，一个键可以对应多个值。

**示例代码**：

```cpp
#include <iostream>
#include <map>

int main() {
    std::multimap<int, std::string> myMultimap;
    myMultimap.insert({1, "one"});
    myMultimap.insert({2, "two"});
    myMultimap.insert({2, "deux"});
    myMultimap.insert({3, "three"});

    for (const auto& pair : myMultimap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### 3. `std::set`

`std::set` 是一种只包含键的有序关联容器，具有以下特点：

- **唯一键**：每个键在 `set` 中必须是唯一的。
- **自动排序**：键会根据 `<` 运算符自动排序。
- **快速查找**：查找、插入、删除操作的时间复杂度为 O(log n)。

**示例代码**：

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet;
    mySet.insert(1);
    mySet.insert(2);
    mySet.insert(3);

    for (int elem : mySet) {
        std::cout << elem << std::endl;
    }

    return 0;
}
```



**PS：**为了更好地理解 `<` 运算符的重载作用，我们需要详细解释一下运算符重载的机制以及在 `std::set` 中具体发挥作用的地方。

#### 运算符重载的概念

运算符重载允许你定义或重新定义某些运算符的行为，以便它们可以与用户自定义的类一起使用。例如，通过重载 `<` 运算符，你可以定义两个 `Student` 对象如何进行比较。

#### 重载 `<` 运算符的代码

以下是 `Student` 类中重载 `<` 运算符的代码：

```cpp
bool operator<(const Student &stu) const {
    return _id < stu._id;
}
```

这个函数的作用是：当我们使用 `<` 运算符比较两个 `Student` 对象时，实际上是比较它们的 `_id` 值。

#### `std::set` 使用 `<` 运算符的地方

`std::set` 是一个有序集合，其内部使用红黑树（或其他平衡二叉树）来存储元素。为了保持元素有序，`std::set` 需要知道如何比较两个元素。这正是 `<` 运算符重载发挥作用的地方。

#### 具体示例

以下是一个使用 `std::set` 的完整示例，详细解释重载 `<` 运算符如何发挥作用：

```cpp
#include <iostream>
#include <set>
#include <string>

class Student {
public:
    Student(int id, std::string name) : _id(id), _name(name) {}

    // 重载 < 运算符
    bool operator<(const Student &stu) const {
        return _id < stu._id;
    }

    // 打印学生信息
    void print() const {
        std::cout << "ID: " << _id << ", Name: " << _name << std::endl;
    }

private:
    int _id;
    std::string _name;
};

int main() {
    // 创建 std::set 容器
    std::set<Student> studentSet;
    
    // 插入 Student 对象
    studentSet.insert(Student(3, "Alice"));
    studentSet.insert(Student(1, "Bob"));
    studentSet.insert(Student(2, "Charlie"));

    // 输出 Student 对象，按 id 排序
    for (const auto &student : studentSet) {
        student.print();
    }

    return 0;
}
```

#### 输出结果

```plaintext
ID: 1, Name: Bob
ID: 2, Name: Charlie
ID: 3, Name: Alice
```

#### 解释

1. **插入顺序**：我们按任意顺序插入 `Student` 对象到 `std::set` 中。
2. **排序顺序**：`std::set` 使用 `<` 运算符来比较 `Student` 对象，并自动对其进行排序。

在 `std::set` 中插入元素时，它会根据 `<` 运算符确定元素之间的相对顺序。例如，当插入 `Student(3, "Alice")` 时：

- `std::set` 首先比较 `3` 和已存在的元素（如果有的话）的 `_id` 值。
- 如果 `3` 小于某个已存在元素的 `_id`，则 `Alice` 将插入到该元素之前。
- 如果 `3` 大于某个已存在元素的 `_id`，则 `Alice` 将插入到该元素之后。

同理，当插入 `Student(1, "Bob")` 和 `Student(2, "Charlie")` 时，`std::set` 通过 `<` 运算符进行比较并确定它们在集合中的位置。

#### 运算符重载的具体作用

- **比较**：每当 `std::set` 需要比较两个 `Student` 对象时，它都会调用重载的 `<` 运算符。例如，在插入新元素、查找元素或删除元素时，`std::set` 都会使用 `<` 运算符来确定元素的顺序。
- **排序**：通过 `<` 运算符的比较结果，`std::set` 可以确保所有元素按 `_id` 值排序。

#### 总结

重载 `<` 运算符的关键作用在于定义了对象之间的比较规则，使 `std::set` 可以使用这个规则来维护元素的顺序。这种机制使得 `std::set` 在插入、删除和查找元素时能够高效地保持元素的有序性。

### 4. `std::multiset`

`std::multiset` 与 `std::set` 类似，但允许相同的键出现多次。

**示例代码**：

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> myMultiset;
    myMultiset.insert(1);
    myMultiset.insert(2);
    myMultiset.insert(2);
    myMultiset.insert(3);

    for (int elem : myMultiset) {
        std::cout << elem << std::endl;
    }

    return 0;
}
```

### 底层实现

有序关联容器通常使用红黑树（Red-Black Tree）来实现。这种自平衡二叉搜索树使得查找、插入、删除操作的时间复杂度保持在 O(log n)。

### 常用操作

- **插入**：`insert` 方法用于插入元素。对于 `std::map` 和 `std::set`，插入一个已经存在的键不会改变容器内容。
- **删除**：`erase` 方法用于删除指定键或迭代器位置的元素。
- **查找**：`find` 方法返回一个指向指定键的迭代器，如果未找到则返回 `end`。
- **迭代**：有序关联容器支持双向迭代器，可以使用范围 `for` 循环或标准算法进行遍历。

### 优缺点对比

#### 优点

- **自动排序**：元素按键值自动排序，适合需要按序访问元素的场景。
- **高效查找**：使用红黑树实现，查找、插入、删除操作时间复杂度为 O(log n)。
- **稳定性**：标准库实现，广泛使用，具有较好的兼容性和稳定性。

#### 缺点

- **较高的内存开销**：相比于无序关联容器（如 `unordered_map`），红黑树需要额外的内存来维护树的结构。
- **插入删除效率较低**：由于需要保持平衡和排序，插入和删除操作比无序关联容器稍慢。

### 总结

有序关联容器在需要自动排序和高效查找的场景中非常有用。理解它们的底层实现和操作特性，可以帮助我们在编程中选择最合适的容器来解决问题。



## 迭代器iterator

迭代器（Iterator）是C++标准模板库（STL）中的一个重要概念，用于遍历容器（如vector、deque、list、set、map等）中的元素。迭代器提供了一种抽象方式来访问容器中的元素，而不需要了解容器的底层实现细节。它们类似于指针，但具有更高层次的抽象性和更广泛的应用范围。

### 迭代器的种类

迭代器根据其功能和操作特性分为五种主要类型：

1. **输入迭代器（Input Iterator）**：
   - 只能读取元素，不允许修改。
   - 只能单向移动，支持 `++` 操作。
   - 用于一次性读取操作，如读取文件。

2. **输出迭代器（Output Iterator）**：
   - 只能写入元素，不允许读取。
   - 只能单向移动，支持 `++` 操作。
   - 用于一次性写入操作，如写入文件。

3. **前向迭代器（Forward Iterator）**：
   - 既可以读取也可以写入元素。
   - 只能单向移动，支持 `++` 操作。
   - 可多次遍历同一容器。

4. **双向迭代器（Bidirectional Iterator）**：
   - 既可以读取也可以写入元素。
   - 支持双向移动，支持 `++` 和 `--` 操作。
   - 用于list、set、map等容器。

5. **随机访问迭代器（Random Access Iterator）**：
   - 既可以读取也可以写入元素。
   - 支持双向移动，支持 `++`、`--`、`+`、`-` 操作，支持随机访问 `[]` 操作。
   - 用于vector、deque等容器。

### 迭代器的基本操作

以下是一些常见的迭代器操作：

1. **初始化和赋值**：
   ```cpp
   std::vector<int> vec = {1, 2, 3, 4, 5};
   std::vector<int>::iterator it = vec.begin(); // 初始化迭代器指向容器的开始
   ```

2. **访问元素**：
   ```cpp
   int value = *it; // 通过解引用访问元素
   ```

3. **迭代遍历**：
   ```cpp
   for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
       std::cout << *it << std::endl; // 输出每个元素的值
   }
   ```

4. **修改元素**：
   ```cpp
   *it = 10; // 修改迭代器指向的元素的值
   ```

5. **移动迭代器**：
   ```cpp
   ++it; // 将迭代器移动到下一个元素
   --it; // 将迭代器移动到前一个元素（适用于双向迭代器）
   ```

6. **随机访问**（仅适用于随机访问迭代器）：
   ```cpp
   it += 2; // 将迭代器向前移动两个位置
   it = vec.begin() + 3; // 将迭代器指向第四个元素
   int val = it[1]; // 访问迭代器当前位置之后的第一个元素
   ```

### 迭代器的使用示例

以下是一个使用迭代器遍历和修改`std::vector`中元素的示例：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 遍历并输出元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // 修改元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        *it = *it * 2; // 将每个元素的值乘以2
    }

    // 再次遍历并输出修改后的元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 迭代器失效

在某些操作下，迭代器可能会失效，这意味着它们指向的元素可能已经被删除或移动。常见的导致迭代器失效的操作包括：

1. **容器的修改**：例如在`vector`中插入或删除元素，可能导致所有指向该容器的迭代器失效。
2. **容器的重新分配**：当`vector`扩容时，所有指向该`vector`的迭代器都会失效。

为了避免迭代器失效的问题，必须小心处理迭代器在容器修改操作中的使用。

### 总结

迭代器是C++中用于访问和操作容器中元素的强大工具，通过迭代器可以遍历、访问、修改容器中的元素，同时保持对容器实现细节的抽象。了解和正确使用迭代器对于高效地操作STL容器至关重要。





## 特殊化迭代器

你提到的常量迭代器（const_iterator）等也是迭代器的一种，它们是上面介绍的五种迭代器类型中的特化版本，用于特定的用途和约束。这里我将补充和详细介绍常见的迭代器类型，包括常量迭代器和反向迭代器。

### 常量迭代器（const_iterator）

常量迭代器是不能用于修改所指向的元素的迭代器。使用常量迭代器可以确保代码的安全性，防止对容器中的元素进行不必要的修改。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用常量迭代器遍历元素
    for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`cbegin()` 和 `cend()` 返回的是常量迭代器，使用这些迭代器只能读取元素，而不能修改它们。

### 反向迭代器（reverse_iterator）

反向迭代器用于从后向前遍历容器。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用反向迭代器遍历元素
    for (std::vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`rbegin()` 和 `rend()` 返回的是反向迭代器，用于从末尾到开头遍历容器。

### 常量反向迭代器（const_reverse_iterator）

常量反向迭代器是反向迭代器的常量版本，用于从后向前遍历容器，同时保证元素不可修改。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用常量反向迭代器遍历元素
    for (std::vector<int>::const_reverse_iterator it = vec.crbegin(); it != vec.crend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上面的代码中，`crbegin()` 和 `crend()` 返回的是常量反向迭代器，用于从末尾到开头遍历容器，但不能修改元素。

### 迭代器总结

迭代器是C++中用于遍历和操作容器的强大工具，它们包括但不限于以下几种常见类型：

- **普通迭代器（iterator）**：用于读写容器中的元素。
- **常量迭代器（const_iterator）**：用于只读容器中的元素，不能修改。
- **反向迭代器（reverse_iterator）**：用于从后向前遍历容器。
- **常量反向迭代器（const_reverse_iterator）**：用于从后向前只读遍历容器，不能修改。

这些迭代器提供了灵活性和安全性，使得对容器的遍历和操作更加方便和安全。了解和正确使用这些迭代器类型对于高效地操作STL容器至关重要。

### 迭代器的应用示例

以下是一个综合应用迭代器的示例，展示如何使用普通迭代器、常量迭代器和反向迭代器：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用普通迭代器遍历和修改元素
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2; // 将每个元素乘以2
    }

    // 使用常量迭代器遍历元素
    for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " "; // 输出每个元素
    }
    std::cout << std::endl;

    // 使用反向迭代器遍历元素
    for (std::vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " "; // 输出每个元素
    }
    std::cout << std::endl;

    return 0;
}
```

