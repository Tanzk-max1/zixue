![image-20240525191239287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191239287.png)

不是所有的inline函数都会被编译器执行

在debug版本里面inline是不会被触发，只会咋release版本才会出现

内联函数和普通函数的区别，减少消耗，如果生成内联就不会生成函数符号

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191819982.png" alt="image-20240525191819982" style="zoom:80%;" />

可以进行查询





const

![image-20240525193453250](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525193453250.png)

可以通过指针进行修改，但是不推荐，因为不安全

![image-20240525211905648](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525211905648.png)

![image-20240525215017148](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525215017148.png)

单个元素的释放时不加中括号的，数组内存的释放才是加中括号的

![image-20240525220539564](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525220539564.png)

delete和free
free无论时释放一个元素内存，还是释放数组内存都是一个标准的函数调用，传入这个内存的起始地址就好了

左值引用和初识右值引用那个



引用必须初始化

指针可以不用初始化，最好初始化





函数重载部分

![image-20240604101959870](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604101959870.png)

产生规则不同



重载需要 注意什么

首先得在一个作用域

不在一个作用域就不存在重载

什么是函数重载？

![image-20240604154750624](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604154750624.png)

编译时期决定重载哪个版本

什么是多态？

静态（编译时期的）多态：函数重载

动态（运行时候的）多态：

c++在编译代码的时候产生函数符号的时候，是由这个函数名+参数类型组成的，c语言是不能重载的，产生函数符号的时候是由函数名来决定的



c++ 调用c ：无法直接调用

![image-20240605175858792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605175858792.png)

这样子就可以调用，把c函数的声明括在extern“c”里面



c 调用c ++无法调用的话，那就也是extern

![image-20240605180403463](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180403463.png)

__FILE__

__LINE__

只要是c++编译器，都内置了这个宏__cplusplus

![image-20240605180725445](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180725445.png)

![image-20240605181008848](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605181008848.png)

这种方式更加通用

在c和c++的编译器里面都是通用的

const修饰的变量不能够再作为左值，初始化完成后，值不能被修改。

**c里面可以不用初始化，c++必需初始化**

c里面const的不叫常量，叫做常变量

通过指针地址可以修改，const只是在表层不可以作为左值修改

c++的const

必须初始化的，叫常量

如果是通过传递的，那就叫常变量，因为初始值不是一个立即数，是一个变量

![image-20240605202005153](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605202005153.png)

得到的值是30 30 30



常量和普通变量的区别

1. 编译方式不同
2. 不能作为左值了

const修饰的量常出现的错误是：

1. 常量不能作为一个左值《= 直接修改常量的值
2. 不能把常量的地址泄露给一个普通的指针或者普通的引用变量《=可以间接修改



const和一级指针的结合：有两种情况

![image-20240605221540812](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605221540812.png)

通过指针解引用（*）指向内存的值，也就是说  p指向 a的地址， *p可以被复制，只是p被定为常量而已

const和指针转换的类型转换公式

int*   <=   const int*---->不允许的

const int*  <= int *  可以的



**const如果右边没有指针*的话，const是不参与类型的**

![image-20240605231656426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605231656426.png)

以上的都是正确的



const和多级指针结合的时候必须两边都有const，否则就是错误

const 和二级指针的结合

![image-20240605232838210](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605232838210.png)



![image-20240605233107574](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605233107574.png)

反正就是** 转 ** ，不能两边不匹配

如果是const后面有 * ，那么就直接变成 const*   《  *

这样子是可以的



![image-20240605234134074](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605234134074.png)

如果是这样会发生错误

const int ** <= int **,小变大了

改成const int *p = &a；就可以了



又或者const int* const* q = &p;那就是*q不可以赋值



在给定的代码中，我们有以下声明和初始化：

```cpp
int a = 10;
int *p = &a;
const int **q = &p;
```

让我们逐步解释这些声明和初始化的含义。

1. `int a = 10;`：声明并初始化一个整型变量 `a`，其值为 `10`。

2. `int *p = &a;`：声明并初始化一个整型指针 `p`，将 `p` 的值设置为 `a` 的地址。这意味着 `p` 指向了 `a`。

3. `const int **q = &p;`：声明并初始化一个指向指针的指针 `q`，该指针指向 `const int` 类型的数据。将 `q` 的值设置为指向 `p` 的地址。

现在我们来解释指针和 `const` 的传递。

- 一级指针 `p`：它是一个指向 `int` 类型数据的指针。通过 `p`，我们可以修改 `a` 的值。也就是说，`p` 是一个可变指针。

- 二级指针 `q`：它是一个指向指针的指针，指向 `const int` 类型的数据。这意味着 `q` 指向的指针 `p` 是一个指向 `const int` 类型数据的指针。通过 `q`，我们可以修改 `p` 的值，即改变 `p` 指向的地址。但是，由于 `q` 指向的指针 `p` 是指向 `const int` 类型的数据，所以我们不能通过 `q` 来修改 `a` 的值。

换句话说，指针的 `const` 传递是从右往左进行的。在这个例子中，`const` 限制了 `q` 指针指向的数据类型，即 `*p` 的类型，使其不能通过 `q` 修改数据。但是，我们仍然可以通过 `p` 来修改 `a` 的值，因为 `p` 不是 `const` 指针。

总结起来，一级指针 `p` 是可变指针，可以修改 `a` 的值，而二级指针 `q` 是指向 `const int` 类型的指针，可以修改 `p` 的值，但不能修改 `a` 的值。





![image-20240606221957506](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240606221957506.png)

类似这种，因为a是int，然后进行&a取地址，相当与int *，所以第二个语句没有毛病

然后总体的话是int* 和int*





引用和指针的区别

1. 左值引用和右值引用
2. 引用的示例

引用是一种更安全的指针

引用变量是把所引用的内存的地址先存下来

实参和形参是按照值传递

![image-20240608221002279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221002279.png)

有类型是引用，没类型是取地址

引用变量的时候会有一个解引用操作

![image-20240608221722288](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221722288.png)

第一个输出等于第三个输出

右值引用

![image-20240608222002322](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222002322.png)

![image-20240608222506499](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222506499.png)

这两种方式是一样的，都是右值引用，不同的是，下面哪个是被const定死了，上面那个是可以被修改的 

一个右值引用变量，本身是一个左值，在应用的时候必须产生临时量

右值引用

1. int && c =20;专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;
2. 右值引用变量本身是一个左值，只能用左值引用来引用他
3. 不能用一个右值引用变量，来引用一个左值

如果遇到很复杂的*&q = p；

那我们就进行还原，**q = &p；

如果p上面是常量指针，那就是错误的





详解new 和 delete

new 和malloc 

delete 和free

malloc  和 free 是c 的库函数

new和delete 是运算符

new 不仅可以做内存开辟，还可以做内存初始化操作

malloc开辟内存失败，是通过返回值和nullptr作比较；而new开辟内存失败，是通过抛出bad_alloc 类型的一场来判断的

```c++
int *q1 = new int[20]();
delete[]q1;
//这种写法是为了释放数组内存
//如果是释放一个元素的你直接delete就好了
int *p1 = new int[20]();
delete p1;
```

free是直接释放起始地址就好了，相对方便很多

new有多少种？

```c++
  //new有多少种？
  int *p1 = new int(20);//抛出异常
  cout << p1 <<endl;
  cout << *p1 <<endl;
  int *p2 = new (nothrow) int;//不抛出异常
  cout << p2 <<endl;
  cout << *p2 <<endl;
  const int *p3 = new const int(40);//在堆上生成常量
  cout << p3 <<endl;
  cout << *p3 <<endl;
  //定位new
  int data = 0;
  int *p4 = new (&data) int(50);//意思就是指定的内存块，定为int类型的值，值为50
  cout << data <<endl;
  
  return 0;

//输出结果
0xed4300
20
0xed4340
-1163005939
0xed4380
40
50
```

![image-20240609100951053](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609100951053.png)

OOP语言的四大特征是什么？

抽象，封装/隐藏，继承，多态

对象的内存是在栈上的

![image-20240609111710657](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240609111710657.png)

对象的内存大小，只和成员变量有关

![image-20240610122225073](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122225073.png)

Windows查看内存情况👆



![image-20240610122440334](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122440334.png)

![image-20240610122918587](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610122918587.png)

成员变量其实默认编译器会给我们加一个指针，只是我么可以不用手写，直接默认加上

类的成员方法一经编译，所有的成员方法参数都会加上一个this指针，接受调用该方法的一个地址

![image-20240610123054970](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240610123054970.png)

函数的析构和构造相当于一个出栈的问题

先构造的后析构，析构函数不带参数，每个析构函数只能有一个，构造函数时可以带参数的，因此可以提供多个构造函数的重载

析构之后对象就不存在了

如果析构之后就会发生对内存的非法访问



堆上的对象什么时候进行析构，在new和delete这个的时候进行析构

delete相当于先析构掉对象，然后再释放内存

![image-20240612003839524](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612003839524.png)

在执行 `delete ps;` 时，会按照以下步骤进行操作：

1. 首先，会调用 `SeqStack` 类的析构函数 `~SeqStack()`，执行对象的清理操作，释放对象内部可能存在的资源。把指针外部的堆内存先释放掉
2. 然后，会释放 `ps` 所指向的动态分配的内存，这是通过 `new` 运算符分配的内存。然后再把对象的内存释放掉

注意两点：

1. 析构函数的调用是由 `delete` 操作自动触发的，不需要显式调用析构函数。
2. `delete` 操作会同时处理对象的析构和内存的释放，不需要显式调用 `free` 函数。

new相当于先内存开辟操作，然后对象构造操作

![image-20240612100044204](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612100044204.png)



#### 深拷贝与浅拷贝

三种类型的对象

在C++中，对象的内存可以分配在不同的区域，包括数据段（静态存储区）、堆和栈。这些区域在分配和释放对象内存以及对象的生命周期方面有所不同。

1. 数据段（静态存储区）：

   - 对象在编译时就分配了固定的内存空间，通常用于存储全局变量和静态成员变量。

   - 对象在程序运行期间一直存在，直到程序结束才会被释放。

   - 对象的构造和析构函数会在程序的启动和结束时自动调用。

     ```c++
     #include <iostream>
     
     // 在数据段中定义一个全局对象
     class GlobalObject {
     public:
         GlobalObject() {
             std::cout << "GlobalObject constructed!" << std::endl;
         }
     
         ~GlobalObject() {
             std::cout << "GlobalObject destroyed!" << std::endl;
         }
     };
     
     GlobalObject global; // 全局对象
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在主函数中定义一个静态对象
         static GlobalObject staticObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`GlobalObject` 类的对象 `global` 是在数据段中定义的全局对象。程序运行时，全局对象会在程序启动时构造，在程序结束时销毁。

2. 堆（动态存储区）：

   - 对象通过使用 `new` 运算符在堆上进行动态分配。

   - 对象的内存分配和释放需要显式地使用 `new` 和 `delete` 或 `new[]` 和 `delete[]` 进行操作。

   - 对象的生命周期由程序员手动管理，需要在不再需要时手动释放内存。

   - 对象在堆上分配的内存，可以在对象的任何作用域中访问。

     ```c++
     #include <iostream>
     
     class HeapObject {
     public:
         HeapObject() {
             std::cout << "HeapObject constructed!" << std::endl;
         }
     
         ~HeapObject() {
             std::cout << "HeapObject destroyed!" << std::endl;
         }
     };
     
     int main() {
         std::cout << "Main function started!" << std::endl;
     
         // 在堆上动态分配一个对象
         HeapObject* heapObj = new HeapObject();
     
         // 使用对象
     
         // 释放堆上分配的对象
         delete heapObj;
     
         std::cout << "Main function ended!" << std::endl;
     
         return 0;
     }
     ```

     在这个例子中，`HeapObject` 类的对象 `heapObj` 是通过 `new` 运算符在堆上进行动态分配的。程序员需要手动使用 `delete` 运算符释放对象所占用的内存。

3. 栈：

   - 对象通过直接声明或作为局部变量在栈上分配。
   - 对象的内存分配和释放是由编译器自动管理的，遵循栈的后进先出（LIFO）原则。
   - 对象的生命周期与其所在的作用域相对应，当作用域结束时，对象的内存会自动释放。
   - 对象在栈上分配的内存，只能在其声明的作用域内访问。

```c++
#include <iostream>

class StackObject {
public:
    StackObject() {
        std::cout << "StackObject constructed!" << std::endl;
    }

    ~StackObject() {
        std::cout << "StackObject destroyed!" << std::endl;
    }
};

void foo() {
    std::cout << "Inside foo function!" << std::endl;

    // 在函数中定义一个局部对象
    StackObject stackObj;

    std::cout << "Exiting foo function!" << std::endl;
}

int main() {
    std::cout << "Main function started!" << std::endl;

    foo();

    std::cout << "Main function ended!" << std::endl;

    return 0;
}
```

在这个例子中，`StackObject` 类的对象 `stackObj` 是在函数的栈帧中定义的局部对象。当进入函数 `foo` 时，局部对象被构造，当离开函数 `foo` 时，局部对象被析构。栈上的对象的生命周期与其所在作用域相关，无需手动释放内存。





如果拷贝的过程中，内存拷贝，指向的同一块内存指针被释放了，就会产生错误，因为按序析构，被指向的对象已经被释放， 所以报错

```c++
#include <iostream>
using namespace std;
class SeqStack
{
public:
//  void init(int size = 10)
//  {
//    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
//    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
//    _size = size; // 记录栈的总大小
//  }
  SeqStack(int size = 10)
  {
    cout << this << " SeqStack()" << endl;
    _pstack = new int[size]; // 动态分配大小为 size 的整型数组作为栈的存储空间
    _top = -1; // 初始化栈顶指针为 -1，表示栈为空
    _size = size; // 记录栈的总大小
  }
  ~SeqStack()
  {
    cout << this << " ~SeqStack()" << endl;
    delete[] _pstack; // 释放动态分配的数组内存
    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
  }

//  void release(){
//    delete[] _pstack; // 释放动态分配的数组内存
//    _pstack = nullptr; // 将指针置空，避免悬空指针的问题
//  }

  void push(int val)
  {
    if (full()) // 检查栈是否已满，如果已满则进行扩容
      resize();
    _pstack[++_top] = val; // 将新元素 val 入栈，同时栈顶指针加一
  }

  void pop()
  {
    if (empty()) // 检查栈是否为空，如果为空则不执行出栈操作
      return;
    --_top; // 栈顶指针减一，表示将栈顶元素出栈
  }

  int top()
  {
    return _pstack[_top]; // 返回栈顶元素的值，但不修改栈顶指针
  }

  bool empty() { return _top == -1; } // 检查栈是否为空，栈空时栈顶指针为 -1

  bool full() { return _top == _size - 1; } // 检查栈是否已满，栈满时栈顶指针为总大小减一

private:
  int* _pstack; // 动态开辟数组，用于存储顺序栈的元素
  int _top;    // 指向栈顶元素的位置
  int _size;   // 数组扩容的总大小

  void resize()
  {
    int* ptmp = new int[_size * 2]; // 创建一个新的两倍大小的数组
    for (int i = 0; i < _size; ++i) {
      ptmp[i] = _pstack[i]; // 将旧数组中的元素复制到新数组
    }
    delete[] _pstack; // 释放旧数组的内存
    _pstack = ptmp; // 更新指针，指向新数组
    _size *= 2; // 更新栈的总大小为新数组的大小
  }
};
int main()
{
  SeqStack S;//没提供任何构造函数的时候，会位移生成默认的构造和析构函数，是空函数
  SeqStack s1(10);
  SeqStack s2 = s1;//拷贝构造函数，内存的拷贝
  SeqStack s3(s1);//拷贝构造函数
  return 0;//依次析构函数
}
```

![image-20240612102024130](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612102024130.png)

此处为浅拷贝，发生了错误，多个对象指向了同一个资源，同一个资源不可能释放两次，对象默认的拷贝构造，是做内存的数据拷贝

关键是对象如果占用外部资源，那么浅拷贝就出现问题了

```c++
SeqStack(const SeqStack &src)
  {
    cout << this << " &src" <<endl;
    _pstack = new int[src._size];
    for (int i = 0; i < src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这个拷贝构造函数实现了深拷贝，就是不单单复制内存指向，还要修改指针方向
```

修改一下，变成深拷贝，修改指针方向

![image-20240612103541138](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612103541138.png)

当使用 `&src` 这样的引用作为参数时，它适用于传递对象进行拷贝操作。这意味着，如果您传递给拷贝构造函数的参数是一个对象（例如 `MyClass` 类型），它将匹配并执行相应的拷贝操作。

例如，在拷贝构造函数 `MyClass(const MyClass& src)` 中，如果您调用 `MyClass obj1; MyClass obj2 = obj1;`，拷贝构造函数将使用 `obj1` 作为参数 `src`，并执行适当的深拷贝操作。

然而，如果您尝试使用一个不同的类型（例如 `int`）作为参数调用该拷贝构造函数，它将不会匹配该函数的参数类型，因为 `const MyClass&` 不匹配 `int` 类型。在这种情况下，编译器将寻找其他匹配的构造函数或转换函数。

因此，拷贝构造函数的参数类型和函数签名决定了它适用的情况。对于拷贝构造函数 `MyClass(const MyClass& src)`，它适用于接收 `MyClass` 类型的对象，并执行相应的拷贝操作。

而对于其他构造函数，如 `SeqStack(int size = 10)`，它使用 `int` 类型作为参数，适用于创建 `SeqStack` 对象，并初始化对象的大小。

综上所述，通过函数参数的类型和函数签名，可以确定函数适用的情况，从而实现不同类型的对象的创建和拷贝操作。

##### 深浅拷贝的对比

浅拷贝（shallow copy）只是简单地复制指针的值，使得两个对象的指针指向相同的内存块。这样，在两个对象之间进行修改时，它们会共享同一块内存，可能会导致意外的副作用。如果一个对象释放了共享内存，另一个对象仍然引用该内存，就会出现悬空指针的问题。

相比之下，深拷贝（deep copy）会为新对象分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。这样，两个对象就拥有各自独立的内存块，彼此之间的修改不会相互影响。

深拷贝通常涉及以下步骤：

1. 分配新的内存空间，用于存储新对象的资源。
2. 将原始对象的数据复制到新对象的内存空间中。
3. 如果有指针成员变量指向动态分配的内存，需要为新对象的指针成员变量分配独立的内存，并将原始对象指针指向的数据复制到新的内存中。

深拷贝确保了新对象与原始对象具有独立的资源，修改一个对象不会影响另一个对象。

并非所有的对象都需要深拷贝。有些情况下，浅拷贝可能是合适的，例如当对象不包含动态分配的内存，或者两个对象确实需要共享相同的资源时（例如共享缓冲区的多个对象）。

面向对象的拷贝里面基本都是使用for循环，除非我确认我现在的资源数据，**没有占用外部资源**



```c++
void operator = (const SeqStack &src)
  {
    cout << " operator" << endl;
    if (this == &src)
      return;//防止自赋值
    delete[]_pstack;
    _pstack = new int[src._size];
    for (int i = 0; i <= src._top; ++i) {
      _pstack[i] = src._pstack[i];
    }
    _top = src._top;
    _size = src._size;
  }

//这是为了给s2=s1这种操作做一个赋值函数，防止自赋值
//实现逻辑是防止自赋值，然后释放当前对象占用的外部资源，然后实现深拷贝的操作
```

如果前拷贝发生问题，需要做构造自定义的拷贝构造函数和赋值重载函数（s2=s1这种操作)

#### 类和对象代码实践

##### 普通构造函数（字符串or指针）

![image-20240612114147287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114147287.png)如果判断指针的话，对字符串操作的话，最好要判断是否为空

拷贝构造函数

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114343362.png" alt="image-20240612114343362" style="zoom:80%;" />

为什么+1呢，因为要给\0留个位置



析构函数

![image-20240612114507179](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114507179.png)

写完之后要给这个指针制成一个nullptr。

为什么？因为要防止野指针的存在



赋值重载函数

![](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114806184.png)

三步走（防止自赋值->delete->拷贝赋值

![image-20240612114846727](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114846727.png)

![image-20240612114933585](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612114933585.png)

这样子写法就会出现，如果重载函数是void，就返回一个void，然后str3就无法接受数据了，或者说接受的是void

string& 是为了支持连续的operator操作

##### 尝试写循环队列

![image-20240612120802943](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612120802943.png)

![1718165564279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\1718165564279.png)

![image-20240612181716652](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612181716652.png)

![image-20240612182318377](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612182318377.png)

构造函数初始化列表

1.  效率：通过构造函数初始值列表，可以避免先调用默认构造函数创建对象，再在构造函数体内对成员变量进行赋值的额外开销。直接在构造函数初始值列表中初始化成员变量，可以减少不必要的对象初始化和赋值操作，提高效率。
2.  成员变量常量性：构造函数初始值列表可以用于初始化成员变量，即使这些成员变量被声明为 `const` 或引用类型。在构造函数体内部，无法对 `const` 成员变量进行赋值操作，所以使用构造函数初始值列表是唯一的选择。
3.  初始化顺序：构造函数初始值列表指定了成员变量初始化的顺序，可以确保成员变量按照指定的顺序进行初始化，而不是按照它们在类中声明的顺序。这对于成员变量之间存在依赖关系的情况很有用。

```c++
#include <cstring>
#include <string>
class Date {
private:
  int _year;
  int _month;
  int _day;
public:
  Date(int year, int month, int day) : _year(year), _month(month), _day(day) {}

  void printDate() {
    std::cout << "Date: " << _year << "-" << _month << "-" << _day << std::endl;
  }
};

class Goods {
private:
  char* _name;
  int _amount;
  double _price;
  Date _data;
public:
  Goods(char* name, int amount, double price, int year, int month, int day)
      : _data(year, month, day), _amount(amount), _price(price) {
    // 对 _name 进行内存分配，并将 name 的内容复制到 _name
    _name = new char[strlen(name) + 1];
    strcpy(_name, name);
  }

  void printDetails() {
    std::cout << "Name: " << _name << std::endl;
    std::cout << "Amount: " << _amount << std::endl;
    std::cout << "Price: " << _price << std::endl;
    _data.printDate();
      //可以将其理解为在 Goods 类的构造函数中，通过构造函数初始化列表对 _data 进行初始化。这个初始化过程是将参数 y、m 和 d 传递给 Date 类的构造函数，在 Date 类内部进行处理，然后返回一个 Date 类的对象，最终将这个对象赋值给 Goods 类的成员变量 _data。
  }

  ~Goods() {
    delete[] _name; // 释放 _name 的内存
  }
};

int main() {
  Goods item("Example Item", 10, 2.99, 2024, 6, 12);
  item.printDetails();

  return 0;
}
```

![image-20240612193533434](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240612193533434.png)

相当于直接定义+初始化一把搞定---初始化列表

2的那种方式是麻烦一点的简单

成员变量的初始化与他们的定义的顺序有关，跟构造函数初始化列表中出现的先后顺序无关



##### 掌握类的各种成员方法以及区别

static静态成员变量一定要在类外定义和初始化

![image-20240613212922404](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240613212922404.png)

👆，因为比如一个count，那你每个类对象都会调用一个count，这样子事不行的，所以需要吧他放出来做静态成员变量，但是，尽可能不要用太多全局变量

else 静态成员变量是在栈上的，不属于对象的，属于类级别的，他相当于就是个全局变量，只是作用在类里面而已

![image-20240614204038397](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204038397.png)

区别是普通方法存在this指针，静态方法是没有this指针的

静态方法是不需要对象的，不产生this指针，就不需要对象的地址，可以在作用域里面调用它

static静态成员方法

![image-20240614204812277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204812277.png)

普通成员方法

![image-20240614204829141](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614204829141.png)

常成员方法

![image-20240614205207642](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205207642.png)

const类型的形参👆

常对象的方法必须使用常对象的指针

只要是只读操作的成员方法，一律定义成常成员方法

const常成员方法-》const CGOODS *this

1. 属于类的作用域
2. 调用依赖一个对象，普通对象或者常成员对象都可以
3. 可以调用访问对象的私有成员，但是只能读，不能写

![image-20240614205743776](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205743776.png)

三种成员方法总结

![image-20240614205823292](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614205823292.png)

如果定义一个普通类的成员变量，我们需要添加一个类的作用域

指向一个普通成员的时候一定要带上对象

![image-20240614210732783](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614210732783.png)

指向成员方法的指针

一定要依赖对象

![image-20240614212710062](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240614212710062.png)

如何定义函数指针指向类的static成员方法

```c++
#include <iostream>

class MyClass {
public:
    static void staticMethod(int value) {
        std::cout << "Static method called with value: " << value << std::endl;
    }
};

int main() {
    // 定义函数指针类型
    typedef void (*StaticMethodPtr)(int);

    // 声明并初始化函数指针，指向类的静态成员方法
    StaticMethodPtr ptr = &MyClass::staticMethod;

    // 使用函数指针调用静态成员方法
    ptr(42);

    return 0;
}
```





#### 模板

##### 理解模板

c++模板的意义是：可以对类型也可以进行参数化了

int sum(int a,int b){return a+b;}

函数模板《=是不进行编译的,因为类型不知道

模板的实例化《= 函数调用点进行实例化

模板函数《《=才是编译器所编译的



模板类型参数 typename/class

模板非类型参数



模板的实参推演==》可以根据用户传入的实参类型进行推断

模板的特例化（专用化）

模板函数，模板的特例化，非模板函数的重载关系







![image-20240616140824969](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616140824969.png)

模板函数实例化只用实例一次

如果是这里的compare函数是（10.5，20）；

![image-20240616141123517](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616141123517.png)

这样子会导致错误，类型错误

所以需要compare<int>(30,40.5);这样子，强制转换了一下

所以在这里说，函数模板是不参加编译的

在调用点进行实例化，注重功能实现

对于某些类型来说，编译器根据用户给的数据进行的推断是有错误的-》这个时候需要进行特例化

比如针对compare模板函数，提供const char*类型特例化版本

![image-20240616143827353](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143827353.png)

还有非模板函数

![image-20240616143958255](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616143958255.png)

这三个的共存时候，比如compare（"aaa","bbb");

会优先调用非模板函数

如果是

![image-20240616144141339](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616144141339.png)

则优先调用特例化模板，看他有没有指明模板的使用，优先把compare处理成函数名字，没有的话，才去找compare模板

模板声明

![image-20240616152024668](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152024668.png)

因为模板是不编译的，所以别再一个文件定义了，别的文件就直接使用，你得进行声明

所以一般是放在头文件中，然后再源文件中使用include包含

![image-20240616152512220](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616152512220.png)





##### 函数模板

模板的非类型参数，都是常量，只能使用而不能修改

这里面只能用整形的int，char，short，long

![image-20240616153659948](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616153659948.png)

指定类型，常量，

函数的非类型模板参数必须是整数类型（整数或者地址/引用都可以）都是常量

 ![image-20240616154037174](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616154037174.png)

##### 

##### 类模板

```c++
template<typename T>
class SeqStack // 模板名称+类型参数列表=类名称
{
public:
    //构造和析构函数名不用加<T> ,其他的出现模板的地方都加上类型参数列表
  SeqStack(int size=10);
  ~SeqStack()；
  SeqStack(const SeqStack<T> &stack);
  
private:
  T *_pstack;
  int _top;
  int _size;

};
int main()
{
  return 0;
}
```

如果写成员方法，只读操作的话，那就const加上限制，这样子普通对象能调用，常对象也能调用

赋值三部曲

1. 防止自赋值![image-20240616204121844](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204121844.png)

2. 释放原来的空间![image-20240616204145882](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204145882.png)
3. 根据大小开辟空间![image-20240616204206595](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240616204206595.png)

以上是赋值运算符的重载

```c++
T *ptmp = new T[_size * 2];
//像这样子的写法，就是一个模板类的使用，T作为一个占位符，将在具体实例化时由实际类型进行使用，如果是int那就是编译器自动确认为int
```

class类名的时候会实例化一个类

##### 简单介绍下类模板的选择性实例化

在 C++ 中，类模板的选择性实例化（Explicit Specialization）和部分实例化（Partial Specialization）是非常有用的特性，允许你为某些特定类型或类型组合提供特化的实现，而无需影响到其他类型的实现。以下是对这两种技术的详细讲解：

###### 1. 类模板的完全特化（Explicit Specialization）

完全特化是为特定类型提供完全不同的实现。在这种情况下，你可以为模板参数的特定类型定义一个特殊版本的类。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化版本，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;
    MyClass<int> obj2;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

###### 2. 类模板的部分特化（Partial Specialization）

部分特化允许你为模板参数的某些特定组合提供特化实现，而不需要完全特化整个模板。部分特化比完全特化更灵活，因为它只需特化部分参数。

###### 示例

```cpp
#include <iostream>

// 通用模板类定义
template <typename T, typename U>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 部分特化，针对第二个参数为 int 的情况
template <typename T>
class MyClass<T, int> {
public:
    void display() {
        std::cout << "Partial specialization: second parameter is int" << std::endl;
    }
};

// 部分特化，针对第一个参数为 int 的情况
template <typename U>
class MyClass<int, U> {
public:
    void display() {
        std::cout << "Partial specialization: first parameter is int" << std::endl;
    }
};

int main() {
    MyClass<double, double> obj1;
    MyClass<double, int> obj2;
    MyClass<int, double> obj3;

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Partial specialization: second parameter is int
    obj3.display();  // 输出: Partial specialization: first parameter is int

    return 0;
}
```

###### 选择性实例化的应用

选择性实例化在以下情况下特别有用：

1. **优化特定类型**：为特定类型提供优化实现。例如，针对常用的 `int` 类型，可以提供更高效的算法或数据结构。
2. **处理特殊行为**：某些类型可能需要特殊处理。例如，处理指针类型时可能需要特化模板以避免常见的错误或提供特殊的行为。
3. **类型特性**：某些类型可能具有不同的特性，需要不同的实现来处理。例如，浮点数和整数的处理方式可能有所不同。

##### 总结

类模板的选择性实例化通过完全特化和部分特化提供了灵活性，允许你为特定类型或类型组合提供特化实现。理解和掌握这两个特性，可以使你的模板代码更加通用和高效，同时在需要时提供特定的优化和行为。



### 简单讲解模板类，类模板，实例化

在C++中，类模板、模板类、和类模板的实例化是模板编程的重要概念。这些概念之间的关系如下：

##### 类模板（Class Template）

类模板是一种蓝图或模板，用于定义一个可以处理多种不同数据类型的类。它允许你编写通用的类定义，并在需要时使用具体的类型进行实例化。

##### 定义类模板

```cpp
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};
```

- `template <typename T>`：这是模板参数列表，告诉编译器这是一个模板类，`T`是一个占位符，表示某种类型。
- `class MyClass`：定义了一个类模板`MyClass`，这个类可以处理任何类型`T`。

##### 模板类（Template Class）

当类模板使用具体类型进行实例化时，生成的类称为模板类。模板类是类模板的具体化版本，每个模板参数对应一个具体类型。

##### 实例化模板类

```cpp
MyClass<int> intObj;     // 实例化一个模板类，T 被替换为 int
MyClass<double> dblObj;  // 实例化一个模板类，T 被替换为 double
```

- `MyClass<int>`：表示一个模板类，`T`被具体化为`int`类型。
- `MyClass<double>`：表示一个模板类，`T`被具体化为`double`类型。

##### 类模板的实例化（Instantiation of Class Template）

类模板的实例化是将类模板用具体的类型参数替换模板参数，从而生成模板类的过程。这个过程可以是显式的（用户在代码中明确指定类型）或隐式的（编译器自动推导类型）。

#### 显式实例化

```cpp
MyClass<int> intObj;     // 显式实例化
MyClass<double> dblObj;  // 显式实例化
```

##### 隐式实例化

当类模板用于函数模板中时，编译器可以根据传递的参数类型自动推导模板参数，从而隐式实例化类模板。

```cpp
template <typename T>
void function() {
    MyClass<T> obj;  // 隐式实例化，编译器根据函数模板的参数推导 T 的类型
}
```

##### 关系总结

1. **类模板**：是一种通用的类定义，使用模板参数（如`typename T`）来表示将来的类型。它是一个蓝图，定义了类的结构和行为，但没有具体化任何类型。

2. **模板类**：是类模板经过实例化后的具体版本，模板参数被替换为具体类型。例如，当类模板`MyClass`使用`int`类型实例化时，就得到了一个模板类`MyClass<int>`。

3. **类模板的实例化**：是将类模板中的模板参数替换为具体类型的过程。可以通过显式指定类型来实例化（如`MyClass<int> intObj`），也可以在使用模板类时由编译器自动推导。

##### 示例

完整的示例展示了类模板的定义、实例化和生成模板类的过程：

```cpp
#include <iostream>

// 定义类模板
template <typename T>
class MyClass {
public:
    void display() {
        std::cout << "Generic template" << std::endl;
    }
};

// 特化类模板，针对 int 类型
template <>
class MyClass<int> {
public:
    void display() {
        std::cout << "Specialized template for int" << std::endl;
    }
};

int main() {
    MyClass<double> obj1;  // 使用 double 实例化类模板，生成模板类 MyClass<double>
    MyClass<int> obj2;     // 使用 int 实例化类模板，生成模板类 MyClass<int>，并使用特化版本

    obj1.display();  // 输出: Generic template
    obj2.display();  // 输出: Specialized template for int

    return 0;
}
```

在这个示例中：
- `MyClass`是一个类模板。
- `MyClass<double>`和`MyClass<int>`是模板类。
- `MyClass<double> obj1`和`MyClass<int> obj2`是类模板的实例化过程。

通过理解这三个概念及其关系，你可以更好地利用模板编程的强大功能来编写通用、灵活和高效的代码。





##### 容器空间配置器，在vector里面的

将内存开辟和析构分开

析构容器里面的元素，然后释放指针指向的容器里面的堆内存

在容器里面删除一个元素应该是 析构掉这个元素的对象，而不是释放这个元素的堆内存

###### 主要是做四件事

1. 内存开辟
2. 内存释放
3. 对象构造
4. 对象析构





#### 运算符重载

##### 学习复数类CComplex

* 不能返回一个局部对象或者局部变量的指针，或者引用等

```c++
//c++的运算符重载

class CComplex
{
public:
  CComplex(int r = 0,int i = 0)
      :mreal(r),mimage(i){}
  //CComplex operator+(const CComplex &src)
  //{
//    CComplex comp;
//    comp.mreal = this->mreal + src.mreal;
//    comp.mimage = this->mimage + src.mimage;
//    return comp;//不能返回一个局部对象或者局部变量的指针，或者引用等
  //    return CComplex(this->mreal + src.mreal,
   //             this->mimage + src.mimage);
  //}
  //因为已经由全局的了，可以屏蔽掉局部的函数
  CComplex operator++(int)
  {
    CComplex comp = *this;
    mreal += 1;
    mimage += 1;
    return comp;
    //为什么这个不可以返回引用呢，因为这是一个局部对象，所以不能这样子
  }
  CComplex& operator++()//返回辅助对象的一个引用，可以不产生临时对象
  {
    mreal += 1;
    mimage += 1;
    return *this;
  }
  void operator+=(const CComplex &src)
  {
    mreal += src.mreal;
    mimage += src.mimage;

  }
  void show(){cout << "real: " << mreal << " image: " << mimage << endl;}
private:
  int mreal;
  int mimage;
  friend CComplex operator+(const CComplex &lhs,const CComplex &rhs);
  friend ostream& operator<< (ostream &out ,const CComplex &src);
  friend istream& operator >> (istream &in ,CComplex &src);
};
CComplex operator+(const CComplex &lhs,const CComplex &rhs)
{
  cout << "nice" << endl;
  return CComplex(lhs.mreal + rhs.mreal,lhs.mimage+rhs.mimage);
}//全局的方法

ostream& operator<< (ostream &out ,const CComplex &src)
{
  out << "mreal: " << src.mreal << "mimage: " << src.mimage <<endl;
  return out;
}
istream& operator >> (istream &in ,CComplex &src)
{
  in >> src.mreal >> src.mimage;
  return in;

}//输入运算符的重载
int main(){
  CComplex complex(10,10);
  CComplex complex1(20,20);
  //加法运算符的重载函数
  CComplex complex2 = complex + complex1;
  complex2.show();
  CComplex complex3 = complex + 20;//相当于comp.operator + (20) int ->CCom CComplex(int);
  complex3.show();

//  CComplex complex4 =  20+complex ;
                                   // 这个就不行了，30在这里面没有生成形参对象，所以不存在生成临时对象
  //编译器在做对象运算的时候，会调用对线的运算重载函数（优先调用成员方法）；如果没有成员方法，那就在全局做哟ing与找合适的运算符重载函数
    CComplex complex4 =  20+complex ;
    complex4.show();
    complex4 = complex++;//++ 和-- 是单目运算符
    complex.show();
    complex4.show();
    complex4 = ++complex;
    complex.show();
    complex4.show();
    cout << "hh " << endl;

    complex2 +=complex;
    complex.show();
    complex2.show();
    cin >> complex >> complex1;
    cout << complex << complex1 << endl;

}
template<typename T>
void show(T a)
{
  cout << a << endl;

}
```



##### 单目运算符---->  ++ 和 --

在C++中，`++`运算符可以通过运算符重载进行自定义，以便适用于用户定义的类型。`++`运算符有两种形式：前置形式（prefix）和后置形式（postfix）。它们可以通过成员函数或友元函数来重载。下面我们分别介绍这两种形式的重载方法。

###### 前置形式（Prefix）

前置形式的运算符重载用于实现`++obj`的行为。其重载函数通常返回对自身的引用。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    ++counter;
    counter.display();  // 输出: Counter value: 1

    return 0;
}
```

在这个示例中，我们重载了前置形式的`++`运算符，使其对`value`执行自增操作，然后返回当前对象的引用。

###### 后置形式（Postfix）

后置形式的运算符重载用于实现`obj++`的行为。其重载函数需要一个整数类型的哑参数来与前置形式区分开。后置形式的运算符重载通常返回对象的副本。

###### 示例

```cpp
#include <iostream>

class Counter {
private:
    int value;

public:
    Counter() : value(0) {}

    // 重载前置 ++ 运算符
    Counter& operator++() {
        ++value;
        return *this;
    }

    // 重载后置 ++ 运算符
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }

    void display() const {
        std::cout << "Counter value: " << value << std::endl;
    }
};

int main() {
    Counter counter;
    counter++;
    counter.display();  // 输出: Counter value: 1

    ++counter;
    counter.display();  // 输出: Counter value: 2

    return 0;
}
```

在这个示例中，我们重载了后置形式的`++`运算符。该运算符先保存当前对象的副本，执行自增操作，然后返回保存的副本。

###### 总结

- 前置形式的`++`运算符重载不带参数，返回当前对象的引用。
- 后置形式的`++`运算符重载带有一个整数哑参数，返回自增前对象的副本。

通过重载这两种形式的`++`运算符，我们可以为自定义类型实现与内置类型类似的自增操作。





![image-20240618002923453](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240618002923453.png)



数组底层其实都是char类型，所以需要用char类型返回

![image-20240621004352323](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004352323.png)

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135342315.png" alt="image-20240620135342315" style="zoom:80%;" />

比如这里，因为我要返回括号里面的数字，所以重载了 [] ，然后返回，返回对象，可以修改

如果是加const在开头则不允许修改

![image-20240620135601765](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620135601765.png)





const char* c_str

![image-20240620230405890](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620230405890.png)

![image-20240620233018119](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233018119.png)

这种foreach的做法还是通过迭代器完成的

![image-20240620233136189](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240620233136189.png)

哈希和红黑树不适合用[]这个，这是支持随机存取的，其他的不支持





#### 迭代器失效问题

![image-20240621001905994](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621001905994.png)

非法操作👆

原因是这样，在你完成一次删除之后，会导致在这个范围内的迭代器失效了

![image-20240621002347928](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002347928.png)

![image-20240621002502908](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621002502908.png)

在删除和增加之后的迭代器会失效的，所以需要进行break

扩容也会发生失效，原来的迭代器就全部失效

进行这些操作之后，it就失效了

新的iteratr返回当前位置，后边的元素会往前挪，**那就是在容器的过程中，如果需要增加或者删除，就是连续多次的操作，一定需要进行更新**

![image-20240621004130942](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004130942.png)

这里需要添加两次，从而完成添加



以下是迭代器的初始条件

![image-20240621004609197](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004609197.png)



2. 不同迭代器是不能进行比较的

![image-20240621004510557](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004510557.png)

![image-20240621004905995](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621004905995.png)

👆迭代器失效增加代码

![image-20240621101634450](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621101634450.png)

通过这段代码，我们新生成容器某一个位置的迭代器





帮助理解，删除末尾元素的pop_back，我们可以理解成删除末尾元素，然后让迭代器失效

![image-20240621102156449](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102156449.png)

![image-20240621102226757](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102226757.png)

verify做检查迭代器

如果发现这个迭代器失效了，就把这个容器指针置为空指针





检查迭代器有效性

![image-20240621102711792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621102711792.png)



## 迭代器失效问题总结

在容器中进行删除和插入操作时，迭代器失效（iterator invalidation）是一个常见的问题。迭代器失效意味着在删除或插入操作之后，先前有效的迭代器可能会变得无效，不能再被安全地使用。如果在删除和插入操作之后不进行适当处理而继续使用这些迭代器，可能会导致程序崩溃或未定义行为。

### 迭代器失效的原因

#### 删除操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 当从 `std::vector` 或 `std::deque` 中删除元素时，**删除位置之后的所有迭代器**都会失效，因为元素需要被移动以填补空隙。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中删除元素时，只有指向被删除元素的迭代器会失效，其他迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中，删除操作只会使指向被删除元素的迭代器失效。

#### 插入操作

1. **序列容器（如 `std::vector`, `std::deque`）**:
   - 在 `std::vector` 或 `std::deque` 中插入元素时，如果插入导致容器重新分配内存，则所有迭代器都会失效。

2. **链表（如 `std::list`）**:
   - 在 `std::list` 中插入元素时，所有迭代器仍然有效。

3. **关联容器（如 `std::map`, `std::set`）**:
   - 在关联容器中插入元素不会使任何现有的迭代器失效。

### 处理迭代器失效的方法

1. **删除操作后的处理**:
   - 使用删除操作返回的新迭代器继续循环。
   - 在 `std::list` 这样的链表中，使用删除元素前的迭代器来继续操作。

2. **插入操作后的处理**:
   - 在序列容器中插入元素后，重新获取容器的迭代器。

### 示例代码

#### 删除操作

假设我们有一个 `std::vector<int>`，需要删除所有的偶数元素：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end();) {
        if (*it % 2 == 0) {
            it = vec.erase(it);  // erase 返回一个指向被删除元素之后的迭代器
        } else {
            ++it;
        }
    }

    // 输出剩余元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
//先检查这个，使其迭代器失效然后析构当前的对象，然后再构造一个新对象出来，然后把元素进行拷贝，完成拷贝构造，然后迭代器++
```

![image-20240621104413117](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621104413117.png)

#### 插入操作

假设我们有一个 `std::vector<int>`，需要在偶数前面插入 -1：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it % 2 == 0) {
            it = vec.insert(it, -1);  // insert 返回一个指向插入元素的迭代器
            ++it;  // 跳过新插入的元素
        }
    }

    // 输出修改后的元素
    for (int num : vec) {
        std::cout << num << " ";
    }

    return 0;
}
```

### 总结

- **删除操作**: 在删除元素后，必须使用 `erase` 返回的新迭代器继续循环。
- **插入操作**: 在插入元素后，必须更新迭代器以继续循环。

在容器进行插入和删除操作时，正确处理迭代器非常重要，以避免迭代器失效导致的程序错误。

## 深入理解new和delete原理

![image-20240621114916231](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621114916231.png)

```c++
Test *p2 = new Test[5];
delete []p2;

```

这看上去消耗了5*4=20个字节，实际上还要多一个，因为还得存储多一个，用来存储对象的个数5个

![image-20240621154742278](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621154742278.png)

然后存储完成之后，指针返回的地址是哪个呢，是0*104这个

，因为不需要让用户知道你的开辟内存地址，只需要知道你第一个对象的地址就好了

![image-20240621155521021](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155521021.png)

总结：free和delete的区别

![image-20240621155741578](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621155741578.png)





对象池部分

![image-20240621172300956](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240621172300956.png)

节点归还就直接吧节点归还的地方用作首届点





## 继承的本质

**继承的本质：**

1. 代码的复用![image-20240622093809546](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622093809546.png)在这个派生类下面的成员也可以是使用的，可以定义多一个ma，不会发生冲突，只要在这个作用域里面使用就行

2. 组和类之间的关系：a：组合 a part of ... 一部分关系 
   继承 b: a kind of 。。。 一种关系

3. | 继承方式                                                     | 基类的访问限定                                               | 派生类的访问限定                       | (main)外部的访问限定 |
   | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- | -------------------- |
   | public                                                       | public<br />protected<br />private(只有自己或者友元才能访问) | public<br />protected<br />不可见的    | Y<br />N<br />N      |
   | protected<br />（基类成员的访问限定，在派生类里面不可能超过继承方式的） | public<br />protected<br />private                           | protected<br />protected<br />不可见的 | N<br />N<br />N      |
   | private                                                      | public<br />protected<br />private                           | private<br />private<br />不可见的     | N<br />N<br />N      |

   **Public继承**：

   - 公有成员（public members）在派生类中保持为公有。
   - 保护成员（protected members）在派生类中保持为保护。
   - 私有成员（private members）在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Protected继承**：

   - 公有成员在派生类中变为保护。
   - 保护成员在派生类中保持为保护。
   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

   **Private继承**：

   - 公有成员在派生类中变为私有。

   - 保护成员在派生类中变为私有。

   - 私有成员在派生类中不可直接访问，但可以通过基类的公有或保护成员间接访问。

     **总结**：

     1. 外部只能访问对象public对象成员，另外两个类型的成员无法直接访问
     2. 在继承结构中，派生类可以继承过来的Private的成员，但是派生类却无法直接访问
     3. Protected 和 Private的区别？在基类中定义的对象，想被派生类访问，但是不想被外部访问，那么在基类中，把相关成员定义成Protected保护的，如果派生类和外部都不打算访问，那么在基类中，就把相关成员定义成Private私有的

**默认的继承方式是什么：**

要看派生类是class定义的，还是struct定义的？

class定义派生类，默认继承方式是Private

struct定义派生类，默认继承方式是Public

##### 问题合集

1. 派生类从继承可以继承来所有成员（变量和方法），除过构造函数和析构函数
   **派生类如何初始化从基类继承来的成员变量呢？**

   解答：通过调用基类相应的构造函数来初始化
   派生类的构造函数和析构函数，负责初始化和清理派生类部分
   派生类从基类继承来的成员的初始化和清理由谁来负责呢？是由基类的构造和析构函数来负责
   派生类对象构造和析构的过程是：

   ![image-20240622103246769](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622103246769.png)

   1. 派生类调用基类的构造函数，初始化从基类继承来的对象
   2. 调用派生类自己的构造函数，初始化派生类自己特有的成员
   3. 调用派生类的析构函数，释放派生类成员可能调用的外部资源（堆内存，文件）
   4. 调用基类的析构函数，释放派生类内存，从基类继承来的成员可能占用的外部资源（堆内存，文件）

## 重载，隐藏，覆盖

1. 重载关系：一组函数要重载，必须处于同一个作用域当中，而且函数名字相同，参数列表不同

2. 隐藏（作用域的隐藏）关系：在继承结构当中，派生类的同名成员，把基类的同名成员给隐藏调用了

   ===============================================================================

   ![image-20240622111630005](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622111630005.png)

![image-20240622113023118](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622113023118.png)

继承结构中的类型转换

1. 基类指针可以指向派生类对象，但只能访问基类部分的成员。 
2. 派生类指针指向基类对象会导致内存非法访问，因为指针类型与对象实际类型不匹配。 
3. 类型转换默认支持从派生类到基类的转换，但反向转换是不安全的。



**覆盖 **

基类和派生类的方法，返回值，函数名以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理程序函数，他们之间成为覆盖关系



## 虚函数，静态绑定和动态绑定

静态调用

![image-20240622115313795](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115313795.png)

![image-20240622115449046](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115449046.png)

总结一：

一个类里面定义了虚函数，那么编译阶段，编译器给这个类类型产生了一个位移的Vftable虚函数标，虚函数标重主要存储的内容是RTTI指针和虚函数的地址

![image-20240622115907217](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622115907217.png)

![image-20240622134440166](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622134440166.png)

总结四：如果派生类中的方法，和基类继承来的某个方法，返回值，函数名，参数列表都相同，而且派生类的方法是virtual虚函数，那么派生类的这个方法，自动处理成虚函数

覆盖指的是虚函数表里面的覆盖

![image-20240622141121060](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141121060.png)

动态绑定--》指的是函数的调用

![image-20240622141428550](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622141428550.png)

不带参数的先绑定

![image-20240622142316447](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622142316447.png)

![image-20240622143116277](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622143116277.png)

判断这些函数指向的时候的思路



### 静态绑定和动态绑定

**静态绑定**（Static Binding）和**动态绑定**（Dynamic Binding）是两种方法，用来在程序运行时确定函数调用的具体实现。

1. **静态绑定**：
   - 也称为早绑定（Early Binding）。
   - 在编译时确定函数调用。
   - 非虚函数和普通函数通常使用静态绑定。

2. **动态绑定**：
   - 也称为晚绑定（Late Binding）。
   - 在运行时确定函数调用。
   - 通过虚函数实现。

### 虚函数

**虚函数**是C++中的一种特殊成员函数，可以在基类中声明，并在派生类中重写（override）。虚函数使得在运行时通过基类指针或引用调用派生类的实现成为可能，这就是动态绑定的实现方式。

### 示例

让我们通过一个具体的例子来说明这些概念：

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    // 基类中的虚函数
    virtual void speak() {
        cout << "Animal speaks" << endl;
    }
    
    // 基类中的非虚函数
    void run() {
        cout << "Animal runs" << endl;
    }
};

class Dog : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Dog barks" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Dog runs" << endl;
    }
};

class Cat : public Animal {
public:
    // 重写基类的虚函数
    void speak() override {
        cout << "Cat meows" << endl;
    }

    // 重写基类的非虚函数
    void run() {
        cout << "Cat runs" << endl;
    }
};

int main() {
    Animal* animalPtr;
    Dog myDog;
    Cat myCat;

    // 静态绑定：调用非虚函数
    myDog.run(); // 输出 "Dog runs"
    myCat.run(); // 输出 "Cat runs"

    // 动态绑定：调用虚函数
    animalPtr = &myDog;
    animalPtr->speak(); // 输出 "Dog barks"

    animalPtr = &myCat;
    animalPtr->speak(); // 输出 "Cat meows"

    return 0;
}
```

### 解释

1. **Animal 类**：
   - `Animal` 是基类，包含一个虚函数 `speak()` 和一个非虚函数 `run()`。
   - `virtual` 关键字告诉编译器这个函数可以在派生类中重写。

2. **Dog 类和 Cat 类**：
   - `Dog` 和 `Cat` 是从 `Animal` 派生的类。
   - 它们都重写了 `speak()` 和 `run()` 函数，提供自己的实现。

3. **静态绑定**：
   - 当调用 `myDog.run()` 或 `myCat.run()` 时，编译器在编译时已经确定了具体调用 `Dog::run()` 或 `Cat::run()`。
   - 因此，这些调用是静态绑定的。

4. **动态绑定**：
   - 当通过基类指针 `animalPtr` 调用虚函数 `speak()` 时，编译器在运行时根据指针指向的具体对象类型（`Dog` 或 `Cat`）确定调用哪个 `speak()` 实现。
   - 这种在运行时确定函数调用的机制就是动态绑定。

### 动态绑定的实现

动态绑定通过虚函数表（vtable）和虚指针（vptr）实现。每个包含虚函数的类在编译时都会生成一个虚函数表，表中存储了该类的虚函数的地址。每个对象包含一个指向其类的虚函数表的指针。当通过基类指针调用虚函数时，程序会通过虚指针找到虚函数表，再从表中找到具体的函数地址并调用它。

### 总结

- **静态绑定**：在编译时确定函数调用，通常用于非虚函数。
- **动态绑定**：在运行时确定函数调用，通常用于虚函数，通过虚函数表实现。
- **虚函数**：使动态绑定成为可能，允许在基类中声明函数，并在派生类中重写。

理解这些概念可以帮助你更好地掌握面向对象编程和多态性的实现，从而编写出更灵活和可扩展的代码。





**问题一:哪些函数不能实现成虚函数?**
虚函数依赖:

1. 虚函数能产生地址，存储在vftable当中虚函数地址)

2. 对象必须存在(vfptr ->vftable ->虚函数地址）

   构造函数

   1. virtual+构造函数 NO!

      构造函数中(调用的任何函数，都是静态绑定的)调用虚函数，也不会发生静态绑定

      派生类对象构造过程   

      1. 先调用的是基类的构造函数

      2.  才调用派生类的构造函数

         **static静态成员方法  No!   virtual + static**

基类的析构函数是virtual虚函数，那么派生类的析构函数自动成为虚函数，

**问题二 ：虚析构函数，析构函数调用的时候对象是存在的！**

什么时候把基类的析构函数必须实现成虚函数?

基类的指针(引用)指向堆上new出来的派生类对象的时候， delete pb(基类的指针）

它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用

![image-20240622212335687](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622212335687.png)

## 什么时候动态绑定，什么时候静态绑定？

在C++中，是否使用动态绑定取决于是否通过基类指针或引用调用虚函数。让我们深入探讨何时使用静态绑定，何时使用动态绑定，以及虚函数在什么情况下不会触发动态绑定。

### 静态绑定 vs. 动态绑定

**静态绑定（Static Binding）**：
- 在编译时确定函数调用。
- 适用于普通函数和非虚函数。
- 适用于通过对象直接调用函数的情况。

**动态绑定（Dynamic Binding）**：
- 在运行时通过虚函数表确定函数调用。
- 适用于虚函数。
- 适用于通过基类指针或引用调用虚函数的情况。

### 何时使用动态绑定

动态绑定发生在以下情况下：
1. **通过基类指针或引用调用虚函数**：
   - 当使用基类指针或引用调用虚函数时，编译器无法在编译时确定具体调用的是哪一个派生类的实现，因此在运行时通过虚函数表进行解析。

```cpp
class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 动态绑定
}
```

2. **多态性**：
   - 当我们希望在运行时根据对象的实际类型执行不同的操作时，使用动态绑定。

### 何时使用静态绑定

静态绑定发生在以下情况下：
1. **非虚函数调用**：
   - 对于非虚函数，编译器在编译时已经知道该调用哪个函数实现，因此直接绑定。

```cpp
class Base {
public:
    void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    void show() {
        cout << "Derived::show" << endl;
    }
};

void display(Base* basePtr) {
    basePtr->show(); // 静态绑定
}
```

2. **通过对象直接调用虚函数**：
   - 当通过具体对象（而不是基类指针或引用）调用虚函数时，编译器在编译时也可以确定具体的调用。

```cpp
Derived d;
d.show(); // 静态绑定，因为对象类型已知
```

### 虚函数不触发动态绑定的情况

有几种情况下，尽管函数声明为虚函数，但不会触发动态绑定：

1. **通过对象直接调用虚函数**：
   - 如果你使用具体对象调用虚函数，编译器已经知道该对象的类型，因此不需要在运行时解析。

```cpp
Base b;
b.show(); // 静态绑定，调用 Base::show
Derived d;
d.show(); // 静态绑定，调用 Derived::show
```

2. **在构造函数或析构函数中调用虚函数**：
   - 在构造函数或析构函数中调用虚函数时，会使用当前类的版本，而不是派生类的版本。这是因为在构造函数和析构函数执行期间，派生类的部分可能尚未初始化或已经销毁。

```cpp
class Base {
public:
    Base() {
        show(); // 调用 Base::show
    }
    virtual void show() {
        cout << "Base::show" << endl;
    }
};

class Derived : public Base {
public:
    Derived() : Base() {}
    void show() override {
        cout << "Derived::show" << endl;
    }
};

Derived d; // 构造函数期间调用 Base::show
```

### 例子总结

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "Base::show" << endl;
    }

    void display() {
        cout << "Base::display" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show" << endl;
    }

    void display() {
        cout << "Derived::display" << endl;
    }
};

int main() {
    Base b;
    Derived d;
    Base* basePtr = &d;

    b.show();          // 静态绑定，调用 Base::show
    d.show();          // 静态绑定，调用 Derived::show
    basePtr->show();   // 动态绑定，调用 Derived::show

    b.display();       // 静态绑定，调用 Base::display
    d.display();       // 静态绑定，调用 Derived::display
    basePtr->display(); // 静态绑定，调用 Base::display (因为 display 不是虚函数)

    return 0;
}
```

### 结论

- **静态绑定**：在编译时确定函数调用。适用于非虚函数或通过对象直接调用虚函数的情况。
- **动态绑定**：在运行时确定函数调用。适用于通过基类指针或引用调用虚函数的情况。
- 虚函数在特定情况下（如通过对象直接调用或在构造函数和析构函数中调用）不会触发动态绑定。

![image-20240622220619120](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220619120.png)

![image-20240622220417219](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240622220417219.png)

### **解释在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本。**

理解 "在构造函数或析构函数中调用虚函数时，虚函数不会进行动态绑定，而是调用当前类的版本" 需要深入了解 C++ 的对象构造和虚函数的工作机制。以下是详细解释：

#### 背景知识

**虚函数表（vtable）**：
- 每个包含虚函数的类都有一个虚函数表（vtable），表中存储了该类的虚函数指针。
- 每个对象都有一个隐藏的指针（vptr），指向它所属类的虚函数表。

**动态绑定**：
- 当通过基类指针或引用调用虚函数时，实际调用的函数在运行时通过虚函数表决定。这称为动态绑定。

#### 构造函数和析构函数中的行为

#### 构造函数

1. **构造对象的顺序**：
   - 当一个派生类对象被构造时，首先会调用基类的构造函数，然后再调用派生类的构造函数。
   
2. **虚指针（vptr）的设置**：
   - 在调用基类构造函数时，对象的虚指针（vptr）指向基类的虚函数表。
   - 只有在派生类的构造函数开始执行时，对象的虚指针（vptr）才会被更新为指向派生类的虚函数表。

#### 析构函数

1. **析构对象的顺序**：
   - 当一个派生类对象被销毁时，首先会调用派生类的析构函数，然后再调用基类的析构函数。
   
2. **虚指针（vptr）的更新**：
   - 在派生类析构函数执行期间，对象的虚指针（vptr）指向派生类的虚函数表。
   - 只有在基类的析构函数开始执行时，对象的虚指针（vptr）才会被更新为指向基类的虚函数表。

#### 具体例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Base constructor\n";
        show(); // 调用 Base::show
    }
    virtual ~Base() {
        show(); // 调用 Base::show
        cout << "Base destructor\n";
    }
    virtual void show() {
        cout << "Base::show\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived constructor\n";
    }
    ~Derived() {
        cout << "Derived destructor\n";
    }
    void show() override {
        cout << "Derived::show\n";
    }
};

int main() {
    Derived d;
    return 0;
}
```

#### 分析

1. **构造过程**：
   - `Derived d;` 执行时，首先调用 `Base` 的构造函数。
   - 在 `Base` 的构造函数中，`show()` 被调用。
   - 此时，`Derived` 部分还未构造完成，对象的虚指针（vptr）仍然指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

2. **析构过程**：
   - `d` 离开作用域时，首先调用 `Derived` 的析构函数。
   - 在 `Derived` 的析构函数执行期间，对象的虚指针（vptr）指向 `Derived` 的虚函数表。
   - 因此，如果在 `Derived` 的析构函数中调用虚函数，将调用 `Derived` 的版本。
   - 接着调用 `Base` 的析构函数。
   - 在 `Base` 的析构函数中，`show()` 被调用。
   - 此时，`Derived` 部分已被销毁，对象的虚指针（vptr）已被更新为指向 `Base` 的虚函数表。
   - 因此，调用 `Base::show()`，输出 `Base::show`。

#### 输出

```
Base constructor
Base::show
Derived constructor
Derived destructor
Base::show
Base destructor
```

#### 总结

- **构造函数中调用虚函数**：由于对象的虚指针（vptr）还未指向派生类的虚函数表，虚函数调用会绑定到当前类（基类）的版本。
- **析构函数中调用虚函数**：由于对象的虚指针（vptr）已被更新为指向当前类（基类）的虚函数表，虚函数调用会绑定到当前类（基类）的版本。

这样设计的目的是为了确保在对象构造和析构过程中，调用的函数是已知的、有效的，并且不会导致访问未初始化或已销毁的对象部分。

## 理解多态
