![image-20240525191239287](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191239287.png)

不是所有的inline函数都会被编译器执行

在debug版本里面inline是不会被触发，只会咋release版本才会出现

内联函数和普通函数的区别，减少消耗，如果生成内联就不会生成函数符号

<img src="D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525191819982.png" alt="image-20240525191819982" style="zoom:80%;" />

可以进行查询





const

![image-20240525193453250](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525193453250.png)

可以通过指针进行修改，但是不推荐，因为不安全

![image-20240525211905648](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525211905648.png)

![image-20240525215017148](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525215017148.png)

单个元素的释放时不加中括号的，数组内存的释放才是加中括号的

![image-20240525220539564](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240525220539564.png)

delete和free
free无论时释放一个元素内存，还是释放数组内存都是一个标准的函数调用，传入这个内存的起始地址就好了

左值引用和初识右值引用那个



引用必须初始化

指针可以不用初始化，最好初始化





函数重载部分

![image-20240604101959870](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604101959870.png)

产生规则不同



重载需要 注意什么

首先得在一个作用域

不在一个作用域就不存在重载

什么是函数重载？

![image-20240604154750624](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240604154750624.png)

编译时期决定重载哪个版本

什么是多态？

静态（编译时期的）多态：函数重载

动态（运行时候的）多态：

c++在编译代码的时候产生函数符号的时候，是由这个函数名+参数类型组成的，c语言是不能重载的，产生函数符号的时候是由函数名来决定的



c++ 调用c ：无法直接调用

![image-20240605175858792](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605175858792.png)

这样子就可以调用，把c函数的声明括在extern“c”里面



c 调用c ++无法调用的话，那就也是extern

![image-20240605180403463](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180403463.png)

__FILE__

__LINE__

只要是c++编译器，都内置了这个宏__cplusplus

![image-20240605180725445](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605180725445.png)

![image-20240605181008848](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605181008848.png)

这种方式更加通用

在c和c++的编译器里面都是通用的

const修饰的变量不能够再作为左值，初始化完成后，值不能被修改。

**c里面可以不用初始化，c++必需初始化**

c里面const的不叫常量，叫做常变量

通过指针地址可以修改，const只是在表层不可以作为左值修改

c++的const

必须初始化的，叫常量

如果是通过传递的，那就叫常变量，因为初始值不是一个立即数，是一个变量

![image-20240605202005153](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605202005153.png)

得到的值是30 30 30



常量和普通变量的区别

1. 编译方式不同
2. 不能作为左值了

const修饰的量常出现的错误是：

1. 常量不能作为一个左值《= 直接修改常量的值
2. 不能把常量的地址泄露给一个普通的指针或者普通的引用变量《=可以间接修改



const和一级指针的结合：有两种情况

![image-20240605221540812](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605221540812.png)

通过指针解引用（*）指向内存的值，也就是说  p指向 a的地址， *p可以被复制，只是p被定为常量而已

const和指针转换的类型转换公式

int*   <=   const int*---->不允许的

const int*  <= int *  可以的



**const如果右边没有指针*的话，const是不参与类型的**

![image-20240605231656426](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605231656426.png)

以上的都是正确的



const和多级指针结合的时候必须两边都有const，否则就是错误

const 和二级指针的结合

![image-20240605232838210](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605232838210.png)



![image-20240605233107574](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605233107574.png)

反正就是** 转 ** ，不能两边不匹配

如果是const后面有 * ，那么就直接变成 const*   《  *

这样子是可以的



![image-20240605234134074](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240605234134074.png)

如果是这样会发生错误

const int ** <= int **,小变大了

改成const int *p = &a；就可以了



又或者const int* const* q = &p;那就是*q不可以赋值



在给定的代码中，我们有以下声明和初始化：

```cpp
int a = 10;
int *p = &a;
const int **q = &p;
```

让我们逐步解释这些声明和初始化的含义。

1. `int a = 10;`：声明并初始化一个整型变量 `a`，其值为 `10`。

2. `int *p = &a;`：声明并初始化一个整型指针 `p`，将 `p` 的值设置为 `a` 的地址。这意味着 `p` 指向了 `a`。

3. `const int **q = &p;`：声明并初始化一个指向指针的指针 `q`，该指针指向 `const int` 类型的数据。将 `q` 的值设置为指向 `p` 的地址。

现在我们来解释指针和 `const` 的传递。

- 一级指针 `p`：它是一个指向 `int` 类型数据的指针。通过 `p`，我们可以修改 `a` 的值。也就是说，`p` 是一个可变指针。

- 二级指针 `q`：它是一个指向指针的指针，指向 `const int` 类型的数据。这意味着 `q` 指向的指针 `p` 是一个指向 `const int` 类型数据的指针。通过 `q`，我们可以修改 `p` 的值，即改变 `p` 指向的地址。但是，由于 `q` 指向的指针 `p` 是指向 `const int` 类型的数据，所以我们不能通过 `q` 来修改 `a` 的值。

换句话说，指针的 `const` 传递是从右往左进行的。在这个例子中，`const` 限制了 `q` 指针指向的数据类型，即 `*p` 的类型，使其不能通过 `q` 修改数据。但是，我们仍然可以通过 `p` 来修改 `a` 的值，因为 `p` 不是 `const` 指针。

总结起来，一级指针 `p` 是可变指针，可以修改 `a` 的值，而二级指针 `q` 是指向 `const int` 类型的指针，可以修改 `p` 的值，但不能修改 `a` 的值。





![image-20240606221957506](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240606221957506.png)

类似这种，因为a是int，然后进行&a取地址，相当与int *，所以第二个语句没有毛病

然后总体的话是int* 和int*





引用和指针的区别

1. 左值引用和右值引用
2. 引用的示例

引用是一种更安全的指针

引用变量是把所引用的内存的地址先存下来

实参和形参是按照值传递

![image-20240608221002279](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221002279.png)

有类型是引用，没类型是取地址

引用变量的时候会有一个解引用操作

![image-20240608221722288](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608221722288.png)

第一个输出等于第三个输出

右值引用

![image-20240608222002322](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222002322.png)

![image-20240608222506499](D:\project\zixuecpp\Cpp-Primer-5th-Notes-CN-master\${photo}\image-20240608222506499.png)

这两种方式是一样的，都是右值引用，不同的是，下面哪个是被const定死了，上面那个是可以被修改的 

一个右值引用变量，本身是一个左值，在应用的时候必须产生临时量

右值引用

1. int && c =20;专门用来引用右值类型，指令上，可以自动产生临时量然后直接引用临时量 c = 40;
2. 右值引用变量本身是一个左值，只能用左值引用来引用他
3. 不能用一个右值引用变量，来引用一个左值

如果遇到很复杂的*&q = p；

那我们就进行还原，**q = &p；

如果p上面是常量指针，那就是错误的





详解new 和 delete

new 和malloc 

delete 和free

malloc  和 free 是c 的库函数

new和delete 是运算符

new 不仅可以做内存开辟，还可以做内存初始化操作

malloc开辟内存失败，是通过返回值和nullptr作比较；而new开辟内存失败，是通过抛出bad_alloc 类型的一场来判断的

```c++
int *q1 = new int[20]();
delete[]q1;
//这种写法是为了释放数组内存
//如果是释放一个元素的你直接delete就好了
int *p1 = new int[20]();
delete p1;
```

free是直接释放起始地址就好了，相对方便很多

new有多少种？

```c++
  //new有多少种？
  int *p1 = new int(20);
  cout << p1 <<endl;
  cout << *p1 <<endl;
  int *p2 = new (nothrow) int;
  cout << p2 <<endl;
  cout << *p2 <<endl;
  const int *p3 = new const int(40);
  cout << p3 <<endl;
  cout << *p3 <<endl;
  //定位new
  int data = 0;
  int *p4 = new (&data) int(50);//意思就是指定的内存块，定为int类型的值，值为50
  cout << data <<endl;
  
  return 0;
```

